<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>150店舗 配分シミュレーター</title>
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap"
    />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/icon?family=Material+Icons"
    />
    <script
      src="https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.production.min.js"
      crossorigin
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.production.min.js"
      crossorigin
    ></script>
    <script src="https://cdn.jsdelivr.net/npm/@babel/standalone@7.23.8/babel.min.js"></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mui/material@5.15.3/umd/material-ui.production.min.js"
      crossorigin
    ></script>
    <style>
      :root {
        color-scheme: light;
      }
      html,
      body {
        margin: 0;
        padding: 0;
        min-height: 100%;
        font-family: "Roboto", "Segoe UI", Helvetica, Arial, sans-serif;
        background: linear-gradient(180deg, #eef1f7 0%, #f7f8fb 100%);
      }
      #root {
        min-height: 100vh;
        display: flex;
      }
      @media (max-width: 600px) {
        body {
          background: #eef1f7;
        }
      }
      .sheet-container {
        max-height: 68vh;
        overflow: auto;
        border: 1px solid rgba(120, 130, 170, 0.25);
        border-radius: 12px;
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.7);
        background: rgba(255, 255, 255, 0.92);
      }
      .sheet-table {
        width: 100%;
        border-collapse: separate;
        border-spacing: 0;
        font-size: 0.82rem;
        color: #0f172a;
      }
      .sheet-table th,
      .sheet-table td {
        border: 1px solid #d6dbe8;
        padding: 4px 6px;
        background-color: #fff;
      }
      .sheet-table th {
        position: sticky;
        top: 0;
        z-index: 4;
        background: linear-gradient(180deg, #f8fbff 0%, #edf2ff 100%);
        font-weight: 600;
        color: #1f2a44;
        text-align: left;
      }
      .sheet-table th.align-right,
      .sheet-table td.align-right {
        text-align: right;
      }
      .sheet-table td.align-center {
        text-align: center;
      }
      .sheet-table th:first-child,
      .sheet-table td:first-child {
        position: sticky;
        left: 0;
        z-index: 3;
        background-color: #f8fafc;
        font-weight: 500;
        color: #475569;
      }
      .sheet-table tbody tr:nth-child(odd) td {
        background-color: #fbfcff;
      }
      .sheet-table tbody tr:hover td {
        background-color: #eef4ff;
      }
      .sheet-table tbody tr:focus-within td {
        background-color: #e2ecff;
        outline: 1px solid rgba(37, 99, 235, 0.7);
        outline-offset: -1px;
      }
      .sheet-table tbody tr.inactive td {
        background-color: #f1f5f9;
        color: #94a3b8;
      }
      .sheet-table tbody tr.inactive td:first-child {
        background-color: #e8edf5;
      }
      .sheet-table tbody tr.inactive .sheet-input:disabled {
        background-color: #e8edf5;
        color: #7b8ba6;
      }
      .sheet-table thead .header-controls-row th {
        background: linear-gradient(180deg, #e6f0ff 0%, #d9e7ff 100%);
        border-bottom: none;
        top: 0;
      }
      .sheet-table thead .header-label-row th {
        border-top: none;
        top: 52px;
      }
      .header-control-cell {
        background: linear-gradient(180deg, #e6f0ff 0%, #d9e7ff 100%);
        padding: 6px;
      }
      .header-control-empty {
        background: linear-gradient(180deg, #e6f0ff 0%, #d9e7ff 100%);
        padding: 6px;
      }
      .sheet-table th.basis-active {
        background: linear-gradient(180deg, #dbeafe 0%, #bfdbfe 100%);
      }
      .sheet-table td.basis-active {
        background-color: #f0f7ff;
      }
      .sheet-table tfoot td {
        position: sticky;
        bottom: 0;
        z-index: 2;
        background: linear-gradient(180deg, #edf2ff 0%, #e2e8fa 100%);
        font-weight: 600;
      }
      .sheet-table tfoot td:first-child {
        left: 0;
      }
      .row-index {
        text-align: center;
        font-variant-numeric: tabular-nums;
      }
      .sheet-table td.store-cell {
        display: flex;
        align-items: center;
        gap: 6px;
        min-width: 200px;
      }
      .sheet-table td.store-cell .store-name {
        flex: 1;
        white-space: nowrap;
      }
      .sheet-table td.metric-cell {
        min-width: 96px;
      }
      .sheet-input {
        width: 100%;
        border: none;
        background: transparent;
        font: inherit;
        text-align: right;
        color: inherit;
        padding: 0;
      }
      .sheet-input:focus {
        outline: none;
      }
      .sheet-input:disabled {
        opacity: 0.8;
        cursor: not-allowed;
      }
      .sheet-input::-webkit-outer-spin-button,
      .sheet-input::-webkit-inner-spin-button {
        -webkit-appearance: none;
        margin: 0;
      }
      .sheet-input[type="number"] {
        -moz-appearance: textfield;
      }
      .sheet-status-ok {
        color: #0f766e;
      }
      .sheet-status-warn {
        color: #b45309;
      }
      .sheet-status-over {
        color: #b91c1c;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <script type="text/babel">
      const {
        AppBar,
        Toolbar,
        Typography,
        CssBaseline,
        ThemeProvider,
        createTheme,
        Container,
        Paper,
        Box,
        Stack,
        TextField,
        Button,
        Chip,
        LinearProgress,
        Tooltip,
        IconButton,
        Grid,
        useMediaQuery,
        Checkbox,
        FormControl,
        FormLabel,
        FormGroup,
        FormControlLabel,
        Divider,
        Alert,
      } = MaterialUI;

      const DISTRIBUTION_BASES = [
        { id: "even", label: "均等" },
        { id: "sales", label: "売上" },
        { id: "area", label: "面積" },
        { id: "custom", label: "任意" },
        { id: "csv", label: "係数パターンCSV" },
      ];

      const BASIS_LABEL_LOOKUP = DISTRIBUTION_BASES.reduce((acc, base) => {
        acc[base.id] = base.label;
        return acc;
      }, {});

      const PATTERN_LABELS = {
        sales: "売上",
        area: "面積",
        customCoefficient: "任意係数",
        csvCoefficient: "CSV係数",
      };

      const theme = createTheme({
        palette: {
          primary: { main: "#1e3a8a" },
          secondary: { main: "#0284c7" },
          background: { default: "transparent", paper: "rgba(255,255,255,0.9)" },
        },
        shape: { borderRadius: 14 },
        typography: {
          button: { textTransform: "none", fontWeight: 600 },
        },
        components: {
          MuiButton: { defaultProps: { size: "small" } },
          MuiTextField: { defaultProps: { size: "small" } },
          MuiChip: { defaultProps: { size: "small" } },
          MuiIconButton: { defaultProps: { size: "small" } },
          MuiToolbar: { defaultProps: { variant: "dense" } },
          MuiCheckbox: { defaultProps: { size: "small" } },
        },
      });

      const pseudoRandom = (seed) => {
        const x = Math.sin(seed * 12.9898) * 43758.5453;
        return x - Math.floor(x);
      };

      const generateMetric = (seed, min, max) =>
        Math.round(min + pseudoRandom(seed) * (max - min));

      const DEFAULT_STORE_COUNT = 150;

      const buildStore = (idx) => {
        const no = String(idx + 1).padStart(3, "0");
        const seed = idx + 1;
        return {
          id: idx,
          name: `店舗 ${no}`,
          allocation: 0,
          include: true,
          sales: generateMetric(seed, 450, 2400),
          area: generateMetric(seed + 0.45, 60, 320),
          customCoefficient: 1,
          csvCoefficient: null,
        };
      };

      const buildStores = (count) =>
        Array.from({ length: count }, (_, idx) => buildStore(idx));

      const splitCsvLine = (line) => {
        const cells = [];
        let current = "";
        let inQuotes = false;
        for (let i = 0; i < line.length; i += 1) {
          const char = line[i];
          if (char === '"') {
            if (inQuotes && line[i + 1] === '"') {
              current += '"';
              i += 1;
            } else {
              inQuotes = !inQuotes;
            }
          } else if (char === "," && !inQuotes) {
            cells.push(current.trim());
            current = "";
          } else {
            current += char;
          }
        }
        cells.push(current.trim());
        return cells.map((cell) => cell.replace(/^"|"$/g, ""));
      };

      const parseNumeric = (value) => {
        if (value === undefined || value === null) return null;
        const trimmed = String(value).trim();
        if (!trimmed) return null;
        const cleaned = trimmed.replace(/[^\d.+-]/g, "");
        if (!cleaned || cleaned === "-" || cleaned === "+" || cleaned === ".") {
          return null;
        }
        const num = Number(cleaned);
        return Number.isFinite(num) ? num : null;
      };

      const parseBoolean = (value) => {
        if (value === undefined || value === null) return null;
        const normalized = String(value).trim().toLowerCase();
        if (!normalized) return null;
        if (
          ["1", "true", "t", "yes", "y", "on", "有", "対象"].includes(normalized)
        ) {
          return true;
        }
        if (
          ["0", "false", "f", "no", "n", "off", "無", "除外"].includes(normalized)
        ) {
          return false;
        }
        return null;
      };

      const parseMasterCsv = (text, stores) => {
        const rawLines = text.replace(/\r\n?/g, "\n").split("\n");
        if (!rawLines.length) {
          return {
            status: "error",
            message: "CSVにデータが含まれていません。",
            records: [],
            matched: 0,
            highestId: -1,
          };
        }
        let headerCells = null;
        const dataLines = [];
        rawLines.forEach((line) => {
          if (!headerCells) {
            if (line.trim()) {
              headerCells = splitCsvLine(line);
            }
          } else if (line.trim()) {
            dataLines.push(line);
          }
        });
        if (!headerCells) {
          return {
            status: "error",
            message: "ヘッダー行が見つかりませんでした。",
            records: [],
            matched: 0,
            highestId: -1,
          };
        }
        const headerKeys = headerCells.map((cell) => normalizeKey(cell));
        const findIndex = (aliases) =>
          headerKeys.findIndex((key) => aliases.includes(key));
        const indexMap = {
          no: findIndex([
            "no",
            "店舗番号",
            "番号",
            "id",
            "index",
            "storeid",
            "store_no",
          ]),
          name: findIndex(["店舗名", "店名", "name", "storename"]),
          sales: findIndex(["売上", "sales"]),
          area: findIndex(["面積", "area"]),
          customCoefficient: findIndex([
            "任意係数",
            "custom",
            "customcoefficient",
            "custom_coeff",
            "任意",
          ]),
          csvCoefficient: findIndex([
            "csv係数",
            "csv",
            "pattern",
            "csvcoefficient",
          ]),
          include: findIndex(["対象", "含める", "include", "active"]),
          allocation: findIndex(["配分", "配分値", "allocation"]),
        };
        if (indexMap.no === -1 && indexMap.name === -1) {
          return {
            status: "error",
            message: "店舗番号または店舗名の列が必要です。",
            records: [],
            matched: 0,
            highestId: -1,
          };
        }
        const nameMap = new Map(
          stores.map((store) => [normalizeKey(store.name), store])
        );
        const recordMap = new Map();
        dataLines.forEach((line) => {
          const cells = splitCsvLine(line);
          let targetIndex = null;
          let targetStore = null;
          if (indexMap.no !== -1) {
            const rawNo = cells[indexMap.no] ?? "";
            const digits = rawNo.replace(/[^\d-]/g, "");
            const parsed = Number.parseInt(digits, 10);
            if (Number.isFinite(parsed) && parsed >= 1) {
              targetIndex = parsed - 1;
              if (targetIndex < stores.length) {
                targetStore = stores[targetIndex];
              }
            }
          }
          if (!targetStore && indexMap.name !== -1) {
            const rawName = cells[indexMap.name] ?? "";
            const normalizedName = normalizeKey(rawName);
            if (nameMap.has(normalizedName)) {
              targetStore = nameMap.get(normalizedName);
              targetIndex = targetStore.id;
            }
          }
          if (targetIndex === null || targetIndex < 0) return;
          if (!targetStore && targetIndex < stores.length) {
            targetStore = stores[targetIndex];
          }
          const patch = {};
          let touched = false;
          if (indexMap.name !== -1) {
            const rawName = cells[indexMap.name] ?? "";
            if (rawName.trim()) {
              patch.name = rawName.trim();
              touched = true;
            }
          }
          if (indexMap.sales !== -1) {
            const value = parseNumeric(cells[indexMap.sales]);
            if (value !== null) {
              patch.sales = Math.max(0, Math.round(value));
              touched = true;
            }
          }
          if (indexMap.area !== -1) {
            const value = parseNumeric(cells[indexMap.area]);
            if (value !== null) {
              patch.area = Math.max(0, Math.round(value));
              touched = true;
            }
          }
          if (indexMap.customCoefficient !== -1) {
            const value = parseNumeric(cells[indexMap.customCoefficient]);
            if (value !== null) {
              patch.customCoefficient =
                Math.max(0, Math.round(value * 1000)) / 1000;
              touched = true;
            }
          }
          if (indexMap.csvCoefficient !== -1) {
            const raw = cells[indexMap.csvCoefficient] ?? "";
            if (!raw.trim()) {
              patch.csvCoefficient = null;
              touched = true;
            } else {
              const value = parseNumeric(raw);
              if (value !== null) {
                patch.csvCoefficient = value;
                touched = true;
              }
            }
          }
          if (indexMap.include !== -1) {
            const boolValue = parseBoolean(cells[indexMap.include]);
            if (boolValue !== null) {
              patch.include = boolValue;
              if (boolValue === false) {
                patch.allocation = 0;
              }
              touched = true;
            }
          }
          if (indexMap.allocation !== -1) {
            const value = parseNumeric(cells[indexMap.allocation]);
            if (value !== null) {
              patch.allocation = Math.max(0, Math.round(value));
              touched = true;
            }
          }
          if (!touched) return;
          const existing = recordMap.get(targetIndex);
          recordMap.set(targetIndex, {
            patch: existing ? { ...existing.patch, ...patch } : patch,
            create: existing
              ? existing.create
              : targetStore == null || targetStore === undefined,
          });
        });
        const records = [];
        let highestId = -1;
        recordMap.forEach((entry, id) => {
          records.push({ id, patch: entry.patch, create: entry.create });
          highestId = Math.max(highestId, id);
        });
        const matched = records.length;
        return {
          status: matched ? "success" : "warning",
          message: matched
            ? `${matched}件の店舗データを更新しました。`
            : "一致する店舗が見つかりませんでした。",
          records,
          matched,
          highestId,
        };
      };

      const normalizeKey = (value) => value.replace(/\s+/g, "").toLowerCase();

      const allocateEvenMap = (stores, total) => {
        const len = stores.length;
        if (!len) return new Map();
        const base = Math.floor(total / len);
        let remainder = total - base * len;
        const map = new Map();
        stores.forEach((store) => {
          const extra = remainder > 0 ? 1 : 0;
          if (remainder > 0) remainder -= 1;
          map.set(store.id, base + extra);
        });
        return map;
      };

      const computeWeightedDistribution = (
        stores,
        includedIds,
        total,
        weightSelector
      ) => {
        const included = stores.filter((store) => includedIds.has(store.id));
        if (!included.length) {
          return { nextStores: stores, weightSum: 0 };
        }
        const weights = included.map((store) => {
          const weight = Number(weightSelector(store));
          return {
            store,
            weight: Number.isFinite(weight) && weight > 0 ? weight : 0,
          };
        });
        const weightSum = weights.reduce((sum, item) => sum + item.weight, 0);
        const allocationMap =
          weightSum === 0
            ? allocateEvenMap(included, total)
            : (() => {
                const raw = weights.map((item) => ({
                  id: item.store.id,
                  ideal: (item.weight / weightSum) * total,
                }));
                const map = new Map();
                let remainder = total;
                raw.forEach((item) => {
                  const floored = Math.floor(item.ideal);
                  map.set(item.id, floored);
                  remainder -= floored;
                });
                const sorted = raw
                  .map((item) => ({
                    id: item.id,
                    fraction: item.ideal - Math.floor(item.ideal),
                  }))
                  .sort((a, b) => b.fraction - a.fraction);
                sorted.forEach((item) => {
                  if (remainder <= 0) return;
                  map.set(item.id, (map.get(item.id) || 0) + 1);
                  remainder -= 1;
                });
                return map;
              })();
        const nextStores = stores.map((store) => {
          if (!includedIds.has(store.id)) {
            return { ...store, allocation: 0 };
          }
          return { ...store, allocation: allocationMap.get(store.id) ?? 0 };
        });
        return { nextStores, weightSum };
      };

      const parseCoefficientCsv = (text, stores) => {
        const lines = text.replace(/\r\n?/g, "\n").split("\n");
        const nameMap = new Map(
          stores.map((store) => [normalizeKey(store.name), store])
        );
        const matchMap = new Map();
        lines.forEach((line) => {
          if (!line.trim()) return;
          const cells = line.split(/[,;\t]/).map((cell) => cell.trim());
          if (cells.length < 2) return;
          const key = cells[0];
          const numeric = Number(cells[1].replace(/[^0-9.+-]/g, ""));
          if (!Number.isFinite(numeric)) return;
          const digits = key.replace(/[^\d]/g, "");
          if (digits) {
            const index = Number.parseInt(digits, 10);
            if (Number.isFinite(index) && index >= 1 && index <= stores.length) {
              const store = stores[index - 1];
              matchMap.set(store.id, numeric);
              return;
            }
          }
          const normalized = normalizeKey(key);
          if (nameMap.has(normalized)) {
            matchMap.set(nameMap.get(normalized).id, numeric);
          }
        });
        return matchMap;
      };
      function useAllocations(
        initialTotal = 10000,
        initialStores = DEFAULT_STORE_COUNT
      ) {
        const initialStoreCount = Math.max(
          1,
          Number(initialStores) || DEFAULT_STORE_COUNT
        );
        const [total, setTotal] = React.useState(initialTotal);
        const [storeCount, setStoreCount] = React.useState(initialStoreCount);
        const [stores, setStores] = React.useState(() =>
          buildStores(initialStoreCount)
        );
        const [basis, setBasis] = React.useState("even");
        const [masterInfo, setMasterInfo] = React.useState(null);
        const [patternInfos, setPatternInfos] = React.useState({});

        const storesRef = React.useRef(stores);
        React.useEffect(() => {
          storesRef.current = stores;
        }, [stores]);

        React.useEffect(() => {
          setStores((prev) => {
            if (prev.length === storeCount) return prev;
            const next = [...prev];
            if (storeCount > prev.length) {
              for (let i = prev.length; i < storeCount; i += 1) {
                next.push(buildStore(i));
              }
            } else {
              next.length = storeCount;
            }
            return next.map((store, idx) => ({ ...store, id: idx }));
          });
        }, [storeCount]);

        const currentSum = React.useMemo(
          () => stores.reduce((sum, store) => sum + store.allocation, 0),
          [stores]
        );
        const difference = React.useMemo(
          () => Math.round(total) - currentSum,
          [total, currentSum]
        );
        const includedCount = React.useMemo(
          () => stores.filter((store) => store.include).length,
          [stores]
        );

        const handleStoreCountChange = React.useCallback((event) => {
          const digits = event.target.value.replace(/[^\d]/g, "");
          if (!digits) {
            setStoreCount(1);
            return;
          }
          const next = Math.max(1, Math.min(9999, Number(digits)));
          setStoreCount(next);
        }, []);

        const handleTotalChange = React.useCallback((event) => {
          const digits = event.target.value.replace(/[^\d]/g, "");
          const next = Number(digits);
          setTotal(Number.isFinite(next) ? next : 0);
        }, []);

        const handleAllocationChange = React.useCallback((index, event) => {
          const raw = Number(event.target.value);
          const next = Number.isFinite(raw) ? Math.max(0, Math.round(raw)) : 0;
          setStores((prev) =>
            prev.map((store, idx) =>
              idx === index ? { ...store, allocation: next } : store
            )
          );
        }, []);

        const toggleStoreInclude = React.useCallback((index) => {
          setStores((prev) =>
            prev.map((store, idx) =>
              idx === index
                ? {
                    ...store,
                    include: !store.include,
                    allocation: store.include ? 0 : store.allocation,
                  }
                : store
            )
          );
        }, []);

        const handleMetricChange = React.useCallback((index, key, event) => {
          const raw = Number(event.target.value);
          let value = Number.isFinite(raw) ? raw : 0;
          if (key === "customCoefficient") {
            value = Math.max(0, Math.round(value * 1000) / 1000);
          } else {
            value = Math.max(0, Math.round(value));
          }
          setStores((prev) =>
            prev.map((store, idx) =>
              idx === index ? { ...store, [key]: value } : store
            )
          );
        }, []);

        const handleMasterCsvUpload = React.useCallback((file) => {
          if (!file) return;
          const reader = new FileReader();
          reader.onload = (event) => {
            const text = event.target.result;
            if (typeof text !== "string") return;
            const latestStores = storesRef.current;
            const result = parseMasterCsv(text, latestStores);
            if (result.records.length) {
              setStores((prev) => {
                const next = [...prev];
                result.records.forEach(({ id, patch }) => {
                  while (next.length <= id) {
                    next.push(buildStore(next.length));
                  }
                  const base = next[id] ?? buildStore(id);
                  const updated = { ...base, ...patch, id };
                  if (patch.include === false) {
                    updated.allocation = 0;
                  }
                  next[id] = updated;
                });
                return next.map((store, idx) => ({ ...store, id: idx }));
              });
              if (result.highestId >= 0) {
                setStoreCount((prev) =>
                  Math.max(prev, result.highestId + 1)
                );
              }
            }
            const totalCount = result.highestId >= 0
              ? Math.max(storesRef.current.length, result.highestId + 1)
              : storesRef.current.length;
            setMasterInfo({
              fileName: file.name,
              matchedCount: result.matched,
              totalCount,
              status: result.status,
              message: result.message,
            });
          };
          reader.onerror = () => {
            setMasterInfo({
              fileName: file.name,
              matchedCount: 0,
              totalCount: storesRef.current.length,
              status: "error",
              message: "CSVの読み込みに失敗しました。",
            });
          };
          reader.readAsText(file, "utf-8");
        }, []);

        const clearMasterData = React.useCallback(() => {
          setStores((prev) =>
            prev.map((_, idx) => ({
              ...buildStore(idx),
              id: idx,
            }))
          );
          setMasterInfo(null);
        }, []);

        const dismissMasterInfo = React.useCallback(() => {
          setMasterInfo(null);
        }, []);

        const handlePatternUpload = React.useCallback((key, file) => {
          if (!file) return;
          const reader = new FileReader();
          reader.onload = (event) => {
            const text = event.target.result;
            if (typeof text !== "string") return;
            const latestStores = storesRef.current;
            const matches = parseCoefficientCsv(text, latestStores);
            const matchedCount = matches.size;
            if (matchedCount) {
              setStores((prev) =>
                prev.map((store) => {
                  if (!matches.has(store.id)) return store;
                  const rawValue = matches.get(store.id);
                  let value = rawValue;
                  if (key === "sales" || key === "area") {
                    value = Math.max(0, Math.round(rawValue));
                  } else if (key === "customCoefficient") {
                    value = Math.max(0, Math.round(rawValue * 1000)) / 1000;
                  }
                  return { ...store, [key]: value };
                })
              );
            }
            const label = PATTERN_LABELS[key] || key;
            setPatternInfos((prev) => ({
              ...prev,
              [key]: {
                fileName: file.name,
                matchedCount,
                totalCount: latestStores.length,
                status: matchedCount ? "success" : "warning",
                message: matchedCount
                  ? `${matchedCount}件の${label}を更新しました。`
                  : "一致する店舗が見つかりませんでした。",
              },
            }));
          };
          reader.onerror = () => {
            const latestStores = storesRef.current;
            const label = PATTERN_LABELS[key] || key;
            setPatternInfos((prev) => ({
              ...prev,
              [key]: {
                fileName: file.name,
                matchedCount: 0,
                totalCount: latestStores.length,
                status: "error",
                message: `${label}のCSVの読み込みに失敗しました。`,
              },
            }));
          };
          reader.readAsText(file, "utf-8");
        }, []);

        const dismissPatternInfo = React.useCallback((key) => {
          setPatternInfos((prev) => ({
            ...prev,
            [key]: null,
          }));
        }, []);

        const applyWeighted = React.useCallback(
          ({ getWeight, basisId }) => {
            const targetTotal = Math.max(0, Math.round(total));
            let meta = null;
            setStores((prev) => {
              const included = prev.filter((store) => store.include);
              if (!included.length) {
                if (basisId === "csv") {
                  meta = {
                    status: "error",
                    message: "配分対象の店舗が選択されていません。",
                  };
                }
                return prev;
              }
              const includedIds = new Set(
                included.map((store) => store.id)
              );
              const hasWeight = included.some((store) => {
                const weight = Number(getWeight(store));
                return Number.isFinite(weight) && weight > 0;
              });
              const { nextStores, weightSum } = computeWeightedDistribution(
                prev,
                includedIds,
                targetTotal,
                getWeight
              );
              if (basisId === "csv") {
                if (!hasWeight) {
                  meta = {
                    status: "error",
                    message: "CSV係数が設定されていない店舗が含まれています。",
                  };
                } else {
                  meta = {
                    status: weightSum === 0 ? "warning" : "success",
                    message:
                      weightSum === 0
                        ? "CSV係数の合計が0のため均等配分しました。"
                        : `${includedIds.size}店舗に係数配分を適用しました。`,
                  };
                }
              }
              return nextStores;
            });
            if (basisId === "csv" && meta) {
              setPatternInfos((prev) => ({
                ...prev,
                csvCoefficient: {
                  ...(prev.csvCoefficient || {}),
                  status: meta.status,
                  message: meta.message,
                  totalCount: storesRef.current.length,
                  fileName: prev.csvCoefficient?.fileName || "CSV係数",
                },
              }));
            }
          },
          [total]
        );

        const distribute = React.useCallback(
          (override) => {
            const active = override || basis;
            const getWeight =
              active === "sales"
                ? (store) => store.sales
                : active === "area"
                ? (store) => store.area
                : active === "custom"
                ? (store) => store.customCoefficient
                : active === "csv"
                ? (store) =>
                    Number.isFinite(Number(store.csvCoefficient))
                      ? Number(store.csvCoefficient)
                      : 0
                : () => 1;
            applyWeighted({ getWeight, basisId: active });
          },
          [basis, applyWeighted]
        );

        const applyDifference = React.useCallback(() => {
          setStores((prev) => {
            const target = Math.max(0, Math.round(total));
            const included = prev.filter((store) => store.include);
            if (!included.length) return prev;
            const current = included.reduce(
              (sum, store) => sum + store.allocation,
              0
            );
            const diff = target - current;
            if (diff === 0) return prev;
            if (diff > 0) {
              const len = included.length;
              const base = Math.floor(diff / len);
              let remainder = diff - base * len;
              return prev.map((store) => {
                if (!store.include) {
                  return { ...store, allocation: store.allocation };
                }
                const extra = base + (remainder > 0 ? 1 : 0);
                if (remainder > 0) remainder -= 1;
                return { ...store, allocation: store.allocation + extra };
              });
            }
            const positive = included.reduce(
              (sum, store) => sum + store.allocation,
              0
            );
            if (positive === 0 || target === 0) {
              return prev.map((store) =>
                store.include ? { ...store, allocation: 0 } : store
              );
            }
            const factor = target / positive;
            const provisional = included.map((store) => {
              const scaled = store.allocation * factor;
              const floored = Math.floor(scaled);
              return {
                id: store.id,
                floored,
                fraction: scaled - floored,
              };
            });
            let remain =
              target -
              provisional.reduce((sum, item) => sum + item.floored, 0);
            const sorted = [...provisional].sort(
              (a, b) => b.fraction - a.fraction
            );
            const allocationMap = new Map(
              provisional.map((item) => [item.id, item.floored])
            );
            sorted.forEach((item) => {
              if (remain <= 0) return;
              allocationMap.set(item.id, allocationMap.get(item.id) + 1);
              remain -= 1;
            });
            return prev.map((store) => {
              if (!store.include) return store;
              return { ...store, allocation: allocationMap.get(store.id) ?? 0 };
            });
          });
        }, [total]);

        const composeCsv = React.useCallback((rows) => {
          return rows
            .map((cells) =>
              cells
                .map((cell) =>
                  `"${String(cell ?? "").replace(/"/g, '""')}"`
                )
                .join(",")
            )
            .join("\r\n");
        }, []);

        const triggerCsvDownload = React.useCallback(
          (filename, rows) => {
            const csvContent = composeCsv(rows);
            const blob = new Blob([csvContent], {
              type: "text/csv;charset=utf-8;",
            });
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.href = url;
            link.download = filename;
            link.click();
            setTimeout(() => URL.revokeObjectURL(url), 0);
          },
          [composeCsv]
        );

        const downloadMasterTemplate = React.useCallback(() => {
          const baseStores =
            storesRef.current.length > 0
              ? storesRef.current
              : buildStores(storeCount);
          const sampleCount = Math.min(
            10,
            baseStores.length || DEFAULT_STORE_COUNT
          );
          const rows = [
            ["No", "店舗名", "売上", "面積", "任意係数", "対象", "配分値"],
            ...Array.from({ length: sampleCount }, (_, idx) => {
              const store = baseStores[idx] ?? buildStore(idx);
              return [
                String(idx + 1),
                store.name,
                store.sales,
                store.area,
                store.customCoefficient,
                store.include ? 1 : 0,
                store.allocation,
              ];
            }),
          ];
          triggerCsvDownload("master_template.csv", rows);
        }, [storeCount, triggerCsvDownload]);

        const downloadPatternTemplate = React.useCallback(
          (key) => {
            const label = PATTERN_LABELS[key] || key;
            const baseStores =
              storesRef.current.length > 0
                ? storesRef.current
                : buildStores(storeCount);
            const sampleCount = Math.min(
              10,
              baseStores.length || DEFAULT_STORE_COUNT
            );
            const rows = [
              ["No", label],
              ...Array.from({ length: sampleCount }, (_, idx) => {
                const store = baseStores[idx] ?? buildStore(idx);
                const value = store[key] ?? "";
                return [String(idx + 1), value];
              }),
            ];
            triggerCsvDownload(`${key}_template.csv`, rows);
          },
          [storeCount, triggerCsvDownload]
        );

        const handleCsvUpload = React.useCallback(
          (file) => handlePatternUpload("csvCoefficient", file),
          [handlePatternUpload]
        );

        const resetAll = React.useCallback(() => {
          setStores((prev) =>
            prev.map((store) => ({ ...store, allocation: 0 }))
          );
          setBasis("even");
        }, []);

        return {
          total,
          storeCount,
          stores,
          currentSum,
          difference,
          includedCount,
          basis,
          masterInfo,
          patternInfos,
          setBasis,
          handleStoreCountChange,
          handleTotalChange,
          handleAllocationChange,
          toggleStoreInclude,
          handleMetricChange,
          handleMasterCsvUpload,
          distribute,
          applyDifference,
          resetAll,
          handlePatternUpload,
          handleCsvUpload,
          downloadMasterTemplate,
          downloadPatternTemplate,
          clearMasterData,
          dismissMasterInfo,
          dismissPatternInfo,
        };
      }
      function SummaryPanel({
        total,
        storeCount,
        currentSum,
        difference,
        includedCount,
        onStoreCountChange,
        onTotalChange,
        basisLabel,
      }) {
        const completion =
          total === 0 ? 0 : Math.min(100, Math.round((currentSum / total) * 100));
        const differenceLabel =
          difference === 0
            ? "目標値に一致"
            : difference > 0
            ? `未配分 ${difference.toLocaleString()}`
            : `超過 ${Math.abs(difference).toLocaleString()}`;
        const differenceColor =
          difference === 0 ? "success" : difference > 0 ? "warning" : "error";
        return (
          <Stack spacing={1.5}>
            <Grid container spacing={1.25}>
              <Grid item xs={6} md={3}>
                <TextField
                  label="店舗数"
                  value={storeCount}
                  onChange={onStoreCountChange}
                  fullWidth
                  type="number"
                  inputProps={{ min: 1, step: 1 }}
                />
              </Grid>
              <Grid item xs={6} md={3}>
                <TextField
                  label="目標総数"
                  value={total.toLocaleString()}
                  onChange={onTotalChange}
                  fullWidth
                  inputProps={{ inputMode: "numeric", pattern: "[0-9,]*" }}
                />
              </Grid>
              <Grid item xs={6} md={3}>
                <TextField
                  label="配分済み"
                  value={currentSum.toLocaleString()}
                  InputProps={{ readOnly: true }}
                  fullWidth
                />
              </Grid>
              <Grid item xs={6} md={3}>
                <TextField
                  label="配分対象店舗"
                  value={`${includedCount} 店`}
                  InputProps={{ readOnly: true }}
                  fullWidth
                />
              </Grid>
            </Grid>
            <LinearProgress
              variant="determinate"
              value={completion}
              sx={{ height: 8, borderRadius: 999 }}
            />
            <Stack
              direction={{ xs: "column", sm: "row" }}
              spacing={1}
              justifyContent="space-between"
            >
              <Chip label={`完了率 ${completion}%`} color="primary" variant="outlined" />
              <Chip label={`モード: ${basisLabel}`} variant="outlined" />
              <Chip label={differenceLabel} color={differenceColor} variant="outlined" />
            </Stack>
          </Stack>
        );
      }

      function DistributionControls({
        bases,
        basis,
        onBasisChange,
        onDistribute,
        onApplyDiff,
        includedCount,
        total,
      }) {
        const canDistribute = includedCount > 0 && total > 0;
        return (
          <Stack spacing={1.5}>
            <Grid container spacing={1.25} alignItems="flex-start">
              <Grid item xs={12} md={8}>
                <FormControl component="fieldset" variant="standard">
                  <FormLabel sx={{ fontWeight: 600 }}>配分モード</FormLabel>
                  <FormGroup
                    row
                    sx={{ flexWrap: { xs: "wrap", sm: "nowrap" }, gap: 0.5 }}
                  >
                    {bases.map((item) => (
                      <FormControlLabel
                        key={item.id}
                        control={
                          <Checkbox
                            checked={basis === item.id}
                            onChange={() => {
                              onBasisChange(item.id);
                              onDistribute(item.id);
                            }}
                          />
                        }
                        label={item.label}
                      />
                    ))}
                  </FormGroup>
                </FormControl>
              </Grid>
              <Grid item xs={12} md={4}>
                <Stack
                  direction="row"
                  spacing={1}
                  justifyContent={{ xs: "flex-start", md: "flex-end" }}
                >
                  <Chip
                    label={`対象店舗 ${includedCount}店`}
                    variant="outlined"
                    color="primary"
                  />
                  <Chip label={`総数 ${total.toLocaleString()}`} variant="outlined" />
                </Stack>
              </Grid>
            </Grid>
            <Stack
              direction={{ xs: "column", sm: "row" }}
              spacing={1}
              justifyContent="space-between"
            >
              <Stack direction={{ xs: "column", sm: "row" }} spacing={1}>
                <Button
                  variant="contained"
                  color="primary"
                  startIcon={<span className="material-icons">play_circle</span>}
                  onClick={() => onDistribute()}
                  disabled={!canDistribute}
                >
                  配分を実行
                </Button>
                <Button
                  variant="outlined"
                  color="secondary"
                  startIcon={<span className="material-icons">tune</span>}
                  onClick={onApplyDiff}
                  disabled={includedCount === 0}
                >
                  差分を調整
                </Button>
              </Stack>
              {basis === "csv" && (
                <Chip color="secondary" label="CSV係数モード" sx={{ alignSelf: "center" }} />
              )}
            </Stack>
          </Stack>
        );
      }
      function AllocationTable({
        stores,
        onAllocationChange,
        onToggleInclude,
        onMetricChange,
        total,
        currentSum,
        difference,
        dense,
        basis,
        masterInfo,
        patternInfos,
        onMasterUpload,
        onPatternUpload,
        onDownloadMasterTemplate,
        onDownloadPatternTemplate,
        onDismissMasterInfo,
        onDismissPatternInfo,
        onResetMaster,
      }) {
        const tableRef = React.useRef(null);
        const masterFileInputRef = React.useRef(null);
        const salesFileInputRef = React.useRef(null);
        const areaFileInputRef = React.useRef(null);
        const customFileInputRef = React.useRef(null);
        const csvFileInputRef = React.useRef(null);
        const patternColumns = React.useMemo(
          () => [
            { key: "sales", label: PATTERN_LABELS.sales, ref: salesFileInputRef },
            { key: "area", label: PATTERN_LABELS.area, ref: areaFileInputRef },
            {
              key: "customCoefficient",
              label: PATTERN_LABELS.customCoefficient,
              ref: customFileInputRef,
            },
            {
              key: "csvCoefficient",
              label: PATTERN_LABELS.csvCoefficient,
              ref: csvFileInputRef,
            },
          ],
          []
        );
        const editableColumns = React.useMemo(
          () => ["allocation", "sales", "area", "customCoefficient"],
          []
        );
        const tryFocus = React.useCallback(
          (rowIndex, columnKey) => {
            if (!tableRef.current) return false;
            if (rowIndex < 0 || rowIndex >= stores.length) return false;
            const selector = `input.sheet-input[data-row-index="${rowIndex}"][data-col-key="${columnKey}"]`;
            const next = tableRef.current.querySelector(selector);
            if (next && !next.disabled) {
              next.focus();
              if (typeof next.select === "function") next.select();
              return true;
            }
            return false;
          },
          [stores.length]
        );
        const handleCellKeyDown = React.useCallback(
          (event, rowIndex, columnKey) => {
            const { key } = event;
            if (key === "ArrowRight" || key === "ArrowLeft") {
              const step = key === "ArrowRight" ? 1 : -1;
              const currentIdx = editableColumns.indexOf(columnKey);
              if (currentIdx === -1) return;
              for (
                let nextIdx = currentIdx + step;
                nextIdx >= 0 && nextIdx < editableColumns.length;
                nextIdx += step
              ) {
                if (tryFocus(rowIndex, editableColumns[nextIdx])) {
                  event.preventDefault();
                  return;
                }
              }
            } else if (key === "ArrowDown" || key === "ArrowUp") {
              const step = key === "ArrowDown" ? 1 : -1;
              for (
                let nextRow = rowIndex + step;
                nextRow >= 0 && nextRow < stores.length;
                nextRow += step
              ) {
                if (tryFocus(nextRow, columnKey)) {
                  event.preventDefault();
                  return;
                }
              }
            } else if (key === "Enter") {
              for (
                let nextRow = rowIndex + 1;
                nextRow < stores.length;
                nextRow += 1
              ) {
                if (tryFocus(nextRow, columnKey)) {
                  event.preventDefault();
                  return;
                }
              }
              event.preventDefault();
            }
          },
          [editableColumns, stores.length, tryFocus]
        );
        const diffText =
          difference === 0
            ? "配分値は目標に一致しています"
            : difference > 0
            ? `未配分 ${difference.toLocaleString()}`
            : `超過 ${Math.abs(difference).toLocaleString()}`;
        const diffClass =
          difference === 0
            ? "sheet-status-ok"
            : difference > 0
            ? "sheet-status-warn"
            : "sheet-status-over";
        const highlightMap = {
          even: "allocation",
          sales: "sales",
          area: "area",
          custom: "customCoefficient",
          csv: "csvCoefficient",
        };
        const highlightKey = highlightMap[basis] || null;
        const severityFor = (status) =>
          status === "error"
            ? "error"
            : status === "warning"
            ? "warning"
            : "success";
        const alerts = [];
        if (masterInfo && masterInfo.message) {
          alerts.push({
            key: "master",
            label: masterInfo.fileName || "マスターCSV",
            info: masterInfo,
            severity: severityFor(masterInfo.status),
            onClose: onDismissMasterInfo,
            onReset: masterInfo.status === "success" ? onResetMaster : null,
          });
        }
        Object.entries(patternInfos || {}).forEach(([key, info]) => {
          if (!info || !info.message) return;
          alerts.push({
            key,
            label: info.fileName || PATTERN_LABELS[key] || key,
            info,
            severity: severityFor(info.status),
            onClose: () => onDismissPatternInfo(key),
            onReset: null,
          });
        });
        let runningTotal = 0;
        return (
          <Box
            className="sheet-container"
            sx={{ maxHeight: dense ? "56vh" : "68vh" }}
            role="region"
            aria-label="店舗別配分一覧"
          >
            {alerts.length > 0 && (
              <Stack spacing={0.75} sx={{ mb: 1.25 }}>
                {alerts.map((alert) => (
                  <Alert
                    key={alert.key}
                    severity={alert.severity}
                    action={
                      <Stack direction="row" spacing={0.5} alignItems="center">
                        {alert.onReset && (
                          <Button size="small" onClick={alert.onReset}>
                            リセット
                          </Button>
                        )}
                        <IconButton
                          size="small"
                          onClick={alert.onClose}
                          aria-label="通知を閉じる"
                        >
                          <span className="material-icons" style={{ fontSize: 18 }}>
                            close
                          </span>
                        </IconButton>
                      </Stack>
                    }
                  >
                    <Stack
                      direction={{ xs: "column", sm: "row" }}
                      spacing={1}
                      alignItems={{ xs: "flex-start", sm: "center" }}
                    >
                      <span>{alert.info.message}</span>
                      <Chip
                        label={alert.label}
                        sx={{ ml: { sm: "auto" } }}
                      />
                    </Stack>
                  </Alert>
                ))}
              </Stack>
            )}
            <table className="sheet-table" ref={tableRef}>
              <thead>
                <tr className="header-controls-row">
                  <th className="row-index header-control-empty" />
                  <th className="header-control-cell">
                    <Stack spacing={0.5}>
                      <Stack
                        direction="row"
                        spacing={0.5}
                        alignItems="center"
                        flexWrap="wrap"
                      >
                        <Button
                          size="small"
                          variant="outlined"
                          startIcon={<span className="material-icons">table_view</span>}
                          onClick={() => masterFileInputRef.current?.click()}
                        >
                          読み込む
                        </Button>
                        <Button
                          size="small"
                          variant="text"
                          onClick={onDownloadMasterTemplate}
                        >
                          テンプレート
                        </Button>
                      </Stack>
                    </Stack>
                    <input
                      type="file"
                      accept=".csv"
                      ref={masterFileInputRef}
                      style={{ display: "none" }}
                      onChange={(event) => {
                        const file = event.target.files?.[0];
                        if (file) onMasterUpload(file);
                        event.target.value = "";
                      }}
                    />
                  </th>
                  <th className="header-control-empty" />
                  <th className="header-control-empty" />
                  {patternColumns.map((column) => (
                    <th
                      key={column.key}
                      className="align-right header-control-cell"
                    >
                      <Stack
                        spacing={0.5}
                        alignItems={{ xs: "flex-start", sm: "flex-end" }}
                      >
                        <Stack
                          direction="row"
                          spacing={0.5}
                          alignItems="center"
                          flexWrap="wrap"
                          sx={{ justifyContent: { xs: "flex-start", sm: "flex-end" } }}
                        >
                          <Button
                            size="small"
                            variant="outlined"
                            startIcon={
                              <span className="material-icons">upload_file</span>
                            }
                            onClick={() => column.ref.current?.click()}
                          >
                            読み込む
                          </Button>
                          <Button
                            size="small"
                            variant="text"
                            onClick={() => onDownloadPatternTemplate(column.key)}
                          >
                            テンプレート
                          </Button>
                        </Stack>
                      </Stack>
                      <input
                        type="file"
                        accept=".csv"
                        ref={column.ref}
                        style={{ display: "none" }}
                        onChange={(event) => {
                          const file = event.target.files?.[0];
                          if (file) onPatternUpload(column.key, file);
                          event.target.value = "";
                        }}
                      />
                    </th>
                  ))}
                </tr>
                <tr className="header-label-row">
                  <th className="row-index">No.</th>
                  <th>店舗（配分対象）</th>
                  <th
                    className={`align-right metric-cell ${
                      highlightKey === "allocation" ? "basis-active" : ""
                    }`}
                  >
                    配分値
                  </th>
                  <th className="align-right metric-cell">累計</th>
                  <th
                    className={`align-right metric-cell ${
                      highlightKey === "sales" ? "basis-active" : ""
                    }`}
                  >
                    売上
                  </th>
                  <th
                    className={`align-right metric-cell ${
                      highlightKey === "area" ? "basis-active" : ""
                    }`}
                  >
                    面積
                  </th>
                  <th
                    className={`align-right metric-cell ${
                      highlightKey === "customCoefficient" ? "basis-active" : ""
                    }`}
                  >
                    任意係数
                  </th>
                  <th
                    className={`align-right metric-cell ${
                      highlightKey === "csvCoefficient" ? "basis-active" : ""
                    }`}
                  >
                    CSV係数
                  </th>
                </tr>
              </thead>
              <tbody>
                {stores.map((store, idx) => {
                  runningTotal += store.allocation;
                  return (
                    <tr
                      key={store.id}
                      className={store.include ? undefined : "inactive"}
                    >
                      <td className="row-index">
                        {String(idx + 1).padStart(3, "0")}
                      </td>
                      <td className="store-cell">
                        <Checkbox
                          checked={store.include}
                          onChange={() => onToggleInclude(idx)}
                          inputProps={{
                            "aria-label": `${store.name}を配分対象に含める`,
                          }}
                          sx={{ p: 0.25 }}
                        />
                        <span className="store-name">{store.name}</span>
                      </td>
                      <td
                        className={`align-right metric-cell ${
                          highlightKey === "allocation" ? "basis-active" : ""
                        }`}
                      >
                        <input
                          type="number"
                          className="sheet-input"
                          value={store.allocation}
                          onChange={(event) => onAllocationChange(idx, event)}
                          onKeyDown={(event) =>
                            handleCellKeyDown(event, idx, "allocation")
                          }
                          min={0}
                          step={1}
                          inputMode="numeric"
                          aria-label={`${store.name} の配分値`}
                          onFocus={(event) => event.target.select()}
                          disabled={!store.include}
                          data-row-index={idx}
                          data-col-key="allocation"
                        />
                      </td>
                      <td className="align-right metric-cell">
                        {runningTotal.toLocaleString()}
                      </td>
                      <td
                        className={`align-right metric-cell ${
                          highlightKey === "sales" ? "basis-active" : ""
                        }`}
                      >
                        <input
                          type="number"
                          className="sheet-input"
                          value={store.sales}
                          onChange={(event) => onMetricChange(idx, "sales", event)}
                          onKeyDown={(event) =>
                            handleCellKeyDown(event, idx, "sales")
                          }
                          min={0}
                          step={1}
                          inputMode="numeric"
                          aria-label={`${store.name} の売上係数`}
                          data-row-index={idx}
                          data-col-key="sales"
                        />
                      </td>
                      <td
                        className={`align-right metric-cell ${
                          highlightKey === "area" ? "basis-active" : ""
                        }`}
                      >
                        <input
                          type="number"
                          className="sheet-input"
                          value={store.area}
                          onChange={(event) => onMetricChange(idx, "area", event)}
                          onKeyDown={(event) =>
                            handleCellKeyDown(event, idx, "area")
                          }
                          min={0}
                          step={1}
                          inputMode="numeric"
                          aria-label={`${store.name} の面積係数`}
                          data-row-index={idx}
                          data-col-key="area"
                        />
                      </td>
                      <td
                        className={`align-right metric-cell ${
                          highlightKey === "customCoefficient" ? "basis-active" : ""
                        }`}
                      >
                        <input
                          type="number"
                          className="sheet-input"
                          value={store.customCoefficient}
                          onChange={(event) =>
                            onMetricChange(idx, "customCoefficient", event)
                          }
                          onKeyDown={(event) =>
                            handleCellKeyDown(event, idx, "customCoefficient")
                          }
                          min={0}
                          step={0.1}
                          inputMode="decimal"
                          aria-label={`${store.name} の任意係数`}
                          data-row-index={idx}
                          data-col-key="customCoefficient"
                        />
                      </td>
                      <td
                        className={`align-right metric-cell ${
                          highlightKey === "csvCoefficient" ? "basis-active" : ""
                        }`}
                      >
                        {store.csvCoefficient !== null
                          ? Number(store.csvCoefficient).toLocaleString(undefined, {
                              maximumFractionDigits: 3,
                            })
                          : "―"}
                      </td>
                    </tr>
                  );
                })}
              </tbody>
              <tfoot>
                <tr>
                  <td colSpan="4">配分済み合計</td>
                  <td className="align-right" colSpan="2">
                    {currentSum.toLocaleString()}
                  </td>
                  <td className="align-right" colSpan="2">
                    目標 {total.toLocaleString()}
                  </td>
                </tr>
                <tr>
                  <td colSpan="6">差分</td>
                  <td className={`align-right ${diffClass}`} colSpan="2">
                    {diffText}
                  </td>
                </tr>
              </tfoot>
            </table>
          </Box>
        );
      }

      function App() {
        const {
          total,
          storeCount,
          stores,
          currentSum,
          difference,
          includedCount,
          basis,
          masterInfo,
          patternInfos,
          setBasis,
          handleStoreCountChange,
          handleTotalChange,
          handleAllocationChange,
          toggleStoreInclude,
          handleMetricChange,
          handleMasterCsvUpload,
          distribute,
          applyDifference,
          resetAll,
          handlePatternUpload,
          downloadMasterTemplate,
          downloadPatternTemplate,
          clearMasterData,
          dismissMasterInfo,
          dismissPatternInfo,
        } = useAllocations();
        const isMobile = useMediaQuery(theme.breakpoints.down("sm"));
        const basisLabel = BASIS_LABEL_LOOKUP[basis] || "未選択";
        return (
          <ThemeProvider theme={theme}>
            <CssBaseline />
            <Box sx={{ display: "flex", flexDirection: "column", minHeight: "100vh" }}>
              <AppBar position="sticky" elevation={8}>
                <Toolbar sx={{ gap: 1 }}>
                  <Typography variant="h6" sx={{ flexGrow: 1, fontWeight: 700 }}>
                    150店舗 配分シミュレーター
                  </Typography>
                  <Tooltip title="配分値をすべて 0 にリセット">
                    <IconButton color="inherit" onClick={resetAll}>
                      <span className="material-icons">refresh</span>
                    </IconButton>
                  </Tooltip>
                </Toolbar>
              </AppBar>
              <Container
                maxWidth="lg"
                sx={{
                  py: { xs: 1, md: 1.75 },
                  flexGrow: 1,
                  width: "100%",
                  display: "flex",
                  flexDirection: "column",
                  gap: 2.5,
                }}
              >
                <Paper
                  elevation={6}
                  sx={{
                    p: { xs: 1.25, md: 2 },
                    display: "flex",
                    flexDirection: "column",
                    gap: 1.5,
                  }}
                >
                  <Typography variant="subtitle1" fontWeight={700}>
                    配分コントロール
                  </Typography>
                  <SummaryPanel
                    total={total}
                    storeCount={storeCount}
                    currentSum={currentSum}
                    difference={difference}
                    includedCount={includedCount}
                    onStoreCountChange={handleStoreCountChange}
                    onTotalChange={handleTotalChange}
                    basisLabel={basisLabel}
                  />
                  <Divider />
                  <DistributionControls
                    bases={DISTRIBUTION_BASES}
                    basis={basis}
                    onBasisChange={setBasis}
                    onDistribute={distribute}
                    onApplyDiff={applyDifference}
                    includedCount={includedCount}
                    total={total}
                  />
                </Paper>
                <Paper
                  elevation={4}
                  sx={{
                    flexGrow: 1,
                    display: "flex",
                    flexDirection: "column",
                    minHeight: 0,
                  }}
                >
                  <Box
                    sx={{
                      px: { xs: 1.25, md: 2 },
                      py: { xs: 1.25, md: 1.75 },
                      borderBottom: "1px solid rgba(0,0,0,0.08)",
                      display: "flex",
                      flexDirection: "column",
                      gap: 0.5,
                    }}
                  >
                    <Typography variant="subtitle1" fontWeight={600}>
                      店舗別配分
                    </Typography>
                    <Typography variant="body2" color="text.secondary">
                      チェックボックスで配分対象を切り替え、指標に応じた配分モードで再計算できます。
                      マスターCSVで店舗属性を更新し、係数パターンCSVで店舗ごとの配分係数を反映できます。
                    </Typography>
                  </Box>
                  <Box sx={{ flexGrow: 1, minHeight: 0 }}>
                    <AllocationTable
                      stores={stores}
                      onAllocationChange={handleAllocationChange}
                      onToggleInclude={toggleStoreInclude}
                      onMetricChange={handleMetricChange}
                      total={total}
                      currentSum={currentSum}
                      difference={difference}
                      dense={isMobile}
                      basis={basis}
                      masterInfo={masterInfo}
                      patternInfos={patternInfos}
                      onMasterUpload={handleMasterCsvUpload}
                      onPatternUpload={handlePatternUpload}
                      onDownloadMasterTemplate={downloadMasterTemplate}
                      onDownloadPatternTemplate={downloadPatternTemplate}
                      onDismissMasterInfo={dismissMasterInfo}
                      onDismissPatternInfo={dismissPatternInfo}
                      onResetMaster={clearMasterData}
                    />
                  </Box>
                </Paper>
              </Container>
            </Box>
          </ThemeProvider>
        );
      }

      ReactDOM.createRoot(document.getElementById("root")).render(<App />);
    </script>
  </body>
</html>
