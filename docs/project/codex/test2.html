<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>店舗配分シミュレーター</title>
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap"
    />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/icon?family=Material+Icons"
    />
    <script
      src="https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.production.min.js"
      crossorigin
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.production.min.js"
      crossorigin
    ></script>
    <script src="https://cdn.jsdelivr.net/npm/@babel/standalone@7.23.8/babel.min.js"></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mui/material@5.15.3/umd/material-ui.production.min.js"
      crossorigin
    ></script>
    <style>
      :root {
        color-scheme: light;
      }
      * {
        box-sizing: border-box;
      }
      html,
      body {
        margin: 0;
        padding: 0;
        min-height: 100%;
        font-family: "Roboto", "Segoe UI", Helvetica, Arial, sans-serif;
        background: linear-gradient(180deg, #eef2f8 0%, #f6f7fb 100%);
      }
      #root {
        width: 100%;
        min-height: 100vh;
        display: flex;
      }
      @media (max-width: 600px) {
        body {
          background: #eef2f8;
        }
      }
      .sheet-container {
        width: 100%;
        max-height: 70vh;
        overflow: auto;
        border: 1px solid rgba(120, 130, 170, 0.25);
        border-radius: 12px;
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.7);
        background: rgba(255, 255, 255, 0.95);
      }
      .sheet-table {
        width: 100%;
        border-collapse: separate;
        border-spacing: 0;
        font-size: 0.82rem;
        color: #0f172a;
      }
      .sheet-table th,
      .sheet-table td {
        border: 1px solid #d6dbe8;
        padding: 6px 6px;
        background-color: #fff;
      }
      .sheet-table th {
        position: sticky;
        z-index: 4;
        background: linear-gradient(180deg, #f8fbff 0%, #eff5ff 100%);
        font-weight: 600;
        color: #1f2a44;
        text-align: left;
      }
      .sheet-table thead tr:first-child th {
        top: 0;
      }
      .sheet-table thead tr:nth-child(2) th {
        top: 52px;
      }
      .sheet-table th.align-right,
      .sheet-table td.align-right {
        text-align: right;
      }
      .sheet-table td.align-center {
        text-align: center;
      }
      .sheet-table th:first-child,
      .sheet-table td:first-child {
        position: sticky;
        left: 0;
        z-index: 5;
        background-color: #f8fafc;
        font-weight: 500;
        color: #475569;
      }
      .sheet-table thead tr:first-child th:first-child,
      .sheet-table thead tr:nth-child(2) th:first-child {
        z-index: 6;
      }
      .sheet-table tbody tr:nth-child(odd) td {
        background-color: #fbfcff;
      }
      .sheet-table tbody tr:hover td {
        background-color: #eef4ff;
      }
      .sheet-table tbody tr:focus-within td {
        background-color: #e2ecff;
        outline: 1px solid rgba(37, 99, 235, 0.7);
        outline-offset: -1px;
      }
      .sheet-table tbody tr.inactive td {
        background-color: #f1f5f9;
        color: #94a3b8;
      }
      .sheet-table tbody tr.inactive td:first-child {
        background-color: #e8edf5;
      }
      .sheet-table tbody tr.inactive .sheet-input:disabled {
        background-color: #e8edf5;
        color: #7b8ba6;
      }
      .sheet-table th.basis-active {
        background: linear-gradient(180deg, #dbeafe 0%, #bfd8ff 100%);
      }
      .sheet-table td.basis-active {
        background-color: #eff5ff;
      }
      .sheet-table tfoot td {
        position: sticky;
        bottom: 0;
        z-index: 2;
        background: linear-gradient(180deg, #eff4ff 0%, #e4ebff 100%);
        font-weight: 600;
      }
      .sheet-table tfoot td:first-child {
        left: 0;
      }
      .row-index {
        text-align: center;
        font-variant-numeric: tabular-nums;
      }
      .sheet-table td.store-cell {
        display: flex;
        align-items: center;
        gap: 6px;
        min-width: 220px;
      }
      .sheet-table td.store-cell .store-name {
        flex: 1;
        white-space: nowrap;
      }
      .sheet-table td.metric-cell {
        min-width: 110px;
      }
      .sheet-table td.adjust-cell {
        min-width: 90px;
      }
      .sheet-input {
        width: 100%;
        border: none;
        background: transparent;
        font: inherit;
        text-align: right;
        color: inherit;
        padding: 0;
      }
      .sheet-input:focus {
        outline: none;
      }
      .sheet-input:disabled {
        opacity: 0.8;
        cursor: not-allowed;
      }
      .sheet-input::-webkit-outer-spin-button,
      .sheet-input::-webkit-inner-spin-button {
        -webkit-appearance: none;
        margin: 0;
      }
      .sheet-input[type="number"] {
        -moz-appearance: textfield;
      }
      .header-control-cell {
        background: linear-gradient(180deg, #e6f0ff 0%, #d9e7ff 100%);
        border-bottom: none;
        padding: 6px;
      }
      .header-control-empty {
        background: linear-gradient(180deg, #e6f0ff 0%, #d9e7ff 100%);
        border-bottom: none;
        padding: 6px;
      }
      .sheet-status-ok {
        color: #15803d;
      }
      .sheet-status-warn {
        color: #b45309;
      }
      .sheet-status-over {
        color: #b91c1c;
      }
      .no-print {
        display: block;
      }
      @media print {
        body {
          background: #fff;
        }
        .no-print {
          display: none !important;
        }
        .sheet-container {
          border: none;
          max-height: none;
        }
        .sheet-table th,
        .sheet-table td {
          font-size: 10pt;
        }
      }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <script type="text/babel">
      const {
        AppBar,
        Toolbar,
        Typography,
        CssBaseline,
        ThemeProvider,
        createTheme,
        Container,
        Paper,
        Box,
        Stack,
        TextField,
        Button,
        Chip,
        LinearProgress,
        Checkbox,
        IconButton,
        Tooltip,
        Alert,
        Divider,
        useMediaQuery,
      } = MaterialUI;

      const DISTRIBUTION_BASES = [
        { id: "even", label: "均等" },
        { id: "sales", label: "売上" },
        { id: "area", label: "面積" },
        { id: "custom", label: "任意" },
        { id: "csv", label: "CSV" },
      ];

      const PATTERN_LABELS = {
        sales: "売上",
        area: "面積",
        customCoefficient: "任意係数",
        csvCoefficient: "CSV係数",
      };

      const defaultAdjustments = () => ({
        sales: 0,
        area: 0,
        customCoefficient: 0,
        csvCoefficient: 0,
      });

      const pseudoRandom = (seed) => {
        const x = Math.sin(seed * 12.9898) * 43758.5453;
        return x - Math.floor(x);
      };

      const generateMetric = (seed, min, max) =>
        Math.round(min + pseudoRandom(seed) * (max - min));

      const buildStore = (idx) => {
        const no = String(idx + 1).padStart(3, "0");
        const seed = idx + 1;
        return {
          id: idx,
          name: `店舗 ${no}`,
          allocation: 0,
          include: true,
          manual: false,
          sales: generateMetric(seed, 450, 2400),
          area: generateMetric(seed + 0.45, 60, 320),
          customCoefficient: 1,
          csvCoefficient: null,
          adjustments: defaultAdjustments(),
        };
      };

      const splitCsvLine = (line) => {
        const cells = [];
        let current = "";
        let inQuotes = false;
        for (let i = 0; i < line.length; i += 1) {
          const char = line[i];
          if (char === '"') {
            if (inQuotes && line[i + 1] === '"') {
              current += '"';
              i += 1;
            } else {
              inQuotes = !inQuotes;
            }
          } else if (char === "," && !inQuotes) {
            cells.push(current.trim());
            current = "";
          } else {
            current += char;
          }
        }
        cells.push(current.trim());
        return cells.map((cell) => cell.replace(/^"|"$/g, ""));
      };

      const normalizeKey = (value) =>
        value
          .trim()
          .toLowerCase()
          .replace(/\s+/g, "")
          .replace(/[（）()]/g, "");

      const parseNumeric = (value) => {
        if (value === undefined || value === null) return null;
        const trimmed = String(value).trim();
        if (!trimmed) return null;
        const cleaned = trimmed.replace(/[^\d.+-]/g, "");
        if (!cleaned || cleaned === "-" || cleaned === "+" || cleaned === ".") {
          return null;
        }
        const num = Number(cleaned);
        return Number.isFinite(num) ? num : null;
      };

      const parseBoolean = (value) => {
        if (value === undefined || value === null) return null;
        const normalized = String(value).trim().toLowerCase();
        if (!normalized) return null;
        if (
          ["1", "true", "t", "yes", "y", "on", "有", "対象", "include"].includes(
            normalized
          )
        ) {
          return true;
        }
        if (
          ["0", "false", "f", "no", "n", "off", "無", "除外", "exclude"].includes(
            normalized
          )
        ) {
          return false;
        }
        return null;
      };
      const parseMasterCsv = (text, stores) => {
        const rawLines = text.replace(/\r\n?/g, "\n").split("\n");
        const lines = rawLines.filter((line) => line.trim().length > 0);
        if (!lines.length) {
          return {
            status: "error",
            message: "CSVにデータが含まれていません。",
            records: [],
            matched: 0,
            highestId: -1,
          };
        }
        const headerCells = splitCsvLine(lines[0]);
        const headerKeys = headerCells.map((cell) => normalizeKey(cell));
        const findIndex = (aliases) =>
          headerKeys.findIndex((key) => aliases.includes(key));
        const indexMap = {
          no: findIndex(["no", "店舗番号", "番号", "id", "storeid", "store_no", "index"]),
          name: findIndex(["店舗名", "店名", "name", "storename"]),
          sales: findIndex(["売上", "sales"]),
          area: findIndex(["面積", "area"]),
          customCoefficient: findIndex([
            "任意係数",
            "custom",
            "customcoefficient",
            "custom_coeff",
          ]),
          csvCoefficient: findIndex(["csv係数", "csv", "pattern", "csvcoefficient"]),
          salesAdjust: findIndex(["売上調整", "売上調整%", "salesadjust", "salesadjustment"]),
          areaAdjust: findIndex(["面積調整", "面積調整%", "areaadjust", "areaadjustment"]),
          customAdjust: findIndex([
            "任意調整",
            "任意調整%",
            "customadjust",
            "customadjustment",
          ]),
          csvAdjust: findIndex(["csv調整", "csv調整%", "csvadjust", "csvadjustment"]),
          include: findIndex(["対象", "含める", "include", "active"]),
          allocation: findIndex(["配分", "配分値", "allocation", "配分額"]),
          manual: findIndex(["手動", "manual"]),
        };
        if (indexMap.no === -1 && indexMap.name === -1) {
          return {
            status: "error",
            message: "店舗番号または店舗名の列が必要です。",
            records: [],
            matched: 0,
            highestId: -1,
          };
        }
        const records = new Map();
        const nameMap = new Map(
          stores.map((store) => [normalizeKey(store.name), store])
        );
        lines.slice(1).forEach((line) => {
          const cells = splitCsvLine(line);
          if (!cells.length) return;
          let targetIndex = null;
          if (indexMap.no !== -1) {
            const rawNo = cells[indexMap.no] ?? "";
            const digits = rawNo.replace(/[^\d-]/g, "");
            const parsed = Number.parseInt(digits, 10);
            if (Number.isFinite(parsed) && parsed >= 1) {
              targetIndex = parsed - 1;
            }
          }
          if (targetIndex === null && indexMap.name !== -1) {
            const rawName = cells[indexMap.name] ?? "";
            const normalized = normalizeKey(rawName);
            if (nameMap.has(normalized)) {
              targetIndex = nameMap.get(normalized).id;
            }
          }
          if (targetIndex === null || targetIndex < 0) return;
          const patch = {};
          const adjustments = {};
          let touched = false;
          if (indexMap.name !== -1) {
            const rawName = cells[indexMap.name] ?? "";
            if (rawName.trim()) {
              patch.name = rawName.trim();
              touched = true;
            }
          }
          if (indexMap.sales !== -1) {
            const value = parseNumeric(cells[indexMap.sales]);
            if (value !== null) {
              patch.sales = Math.max(0, Math.round(value));
              touched = true;
            }
          }
          if (indexMap.salesAdjust !== -1) {
            const value = parseNumeric(cells[indexMap.salesAdjust]);
            if (value !== null) {
              adjustments.sales = Math.max(-1000, Math.min(1000, value));
              touched = true;
            }
          }
          if (indexMap.area !== -1) {
            const value = parseNumeric(cells[indexMap.area]);
            if (value !== null) {
              patch.area = Math.max(0, Math.round(value));
              touched = true;
            }
          }
          if (indexMap.areaAdjust !== -1) {
            const value = parseNumeric(cells[indexMap.areaAdjust]);
            if (value !== null) {
              adjustments.area = Math.max(-1000, Math.min(1000, value));
              touched = true;
            }
          }
          if (indexMap.customCoefficient !== -1) {
            const value = parseNumeric(cells[indexMap.customCoefficient]);
            if (value !== null) {
              patch.customCoefficient =
                Math.max(0, Math.round(value * 1000) / 1000);
              touched = true;
            }
          }
          if (indexMap.customAdjust !== -1) {
            const value = parseNumeric(cells[indexMap.customAdjust]);
            if (value !== null) {
              adjustments.customCoefficient = Math.max(-1000, Math.min(1000, value));
              touched = true;
            }
          }
          if (indexMap.csvCoefficient !== -1) {
            const value = parseNumeric(cells[indexMap.csvCoefficient]);
            if (value !== null) {
              patch.csvCoefficient = value;
              touched = true;
            }
          }
          if (indexMap.csvAdjust !== -1) {
            const value = parseNumeric(cells[indexMap.csvAdjust]);
            if (value !== null) {
              adjustments.csvCoefficient = Math.max(-1000, Math.min(1000, value));
              touched = true;
            }
          }
          if (Object.keys(adjustments).length) {
            patch.adjustments = adjustments;
          }
          if (indexMap.include !== -1) {
            const boolValue = parseBoolean(cells[indexMap.include]);
            if (boolValue !== null) {
              patch.include = boolValue;
              touched = true;
            }
          }
          if (indexMap.allocation !== -1) {
            const value = parseNumeric(cells[indexMap.allocation]);
            if (value !== null) {
              patch.allocation = Math.max(0, Math.round(value));
              patch.manual = true;
              touched = true;
            }
          }
          if (indexMap.manual !== -1) {
            const boolValue = parseBoolean(cells[indexMap.manual]);
            if (boolValue !== null) {
              patch.manual = boolValue;
              touched = true;
            }
          }
          if (!touched) return;
          const existing = records.get(targetIndex);
          const mergedPatch = existing
            ? { ...existing.patch, ...patch }
            : { ...patch };
          if (patch.adjustments && existing && existing.patch.adjustments) {
            mergedPatch.adjustments = {
              ...existing.patch.adjustments,
              ...patch.adjustments,
            };
          }
          records.set(targetIndex, {
            patch: mergedPatch,
          });
        });
        const entries = Array.from(records.entries()).map(([id, value]) => ({
          id,
          patch: value.patch,
        }));
        const matched = entries.length;
        const highestId = entries.reduce((max, entry) => Math.max(max, entry.id), -1);
        return {
          status: matched ? "success" : "warning",
          message: matched
            ? `${matched}件の店舗データを更新しました。`
            : "一致する店舗が見つかりませんでした。",
          records: entries,
          matched,
          highestId,
        };
      };

      const parseCoefficientCsv = (text, stores) => {
        const lines = text.replace(/\r\n?/g, "\n").split("\n");
        const nameMap = new Map(
          stores.map((store) => [normalizeKey(store.name), store])
        );
        const matchMap = new Map();
        lines.forEach((line) => {
          if (!line.trim()) return;
          const cells = line.split(/[,;\t]/).map((cell) => cell.trim());
          if (cells.length < 2) return;
          const key = cells[0];
          const numeric = Number(cells[1].replace(/[^0-9.+-]/g, ""));
          if (!Number.isFinite(numeric)) return;
          const digits = key.replace(/[^\d]/g, "");
          if (digits) {
            const index = Number.parseInt(digits, 10);
            if (Number.isFinite(index) && index >= 1 && index <= stores.length) {
              const store = stores[index - 1];
              matchMap.set(store.id, numeric);
              return;
            }
          }
          const normalized = normalizeKey(key);
          if (nameMap.has(normalized)) {
            matchMap.set(nameMap.get(normalized).id, numeric);
          }
        });
        return matchMap;
      };
      const getWeightedValue = (store, basisKey) => {
        const adjustments = {
          ...defaultAdjustments(),
          ...(store.adjustments || {}),
        };
        const adjusted = (key, value) =>
          Math.max(0, Number(value) || 0) * (1 + (Number(adjustments[key]) || 0) / 100);
        switch (basisKey) {
          case "sales":
            return adjusted("sales", store.sales);
          case "area":
            return adjusted("area", store.area);
          case "custom":
            return adjusted("customCoefficient", store.customCoefficient);
          case "csv":
            return adjusted("csvCoefficient", store.csvCoefficient);
          default:
            return 1;
        }
      };

      const distributeAmong = (stores, amount, weightFn) => {
        const map = new Map();
        if (!stores.length || amount <= 0) return map;
        const weights = stores.map((store) => {
          const weight = Number(weightFn(store));
          return Number.isFinite(weight) && weight > 0 ? weight : 0;
        });
        const weightSum = weights.reduce((sum, weight) => sum + weight, 0);
        if (weightSum === 0) {
          const base = Math.floor(amount / stores.length);
          let remainder = amount - base * stores.length;
          stores.forEach((store) => {
            const extra = remainder > 0 ? 1 : 0;
            map.set(store.id, base + extra);
            if (remainder > 0) remainder -= 1;
          });
          return map;
        }
        const raw = stores.map((store, index) => ({
          store,
          ideal: (weights[index] / weightSum) * amount,
        }));
        let remainder = amount;
        raw.forEach(({ store, ideal }) => {
          const floored = Math.floor(ideal);
          map.set(store.id, floored);
          remainder -= floored;
        });
        const sorted = raw
          .map(({ store, ideal }) => ({
            id: store.id,
            fraction: ideal - Math.floor(ideal),
          }))
          .sort((a, b) => b.fraction - a.fraction);
        sorted.forEach(({ id }) => {
          if (remainder <= 0) return;
          map.set(id, (map.get(id) || 0) + 1);
          remainder -= 1;
        });
        return map;
      };

      const distributeStores = (inputStores, basisKey, targetTotal) => {
        const total = Math.max(0, Math.round(targetTotal));
        const normalized = inputStores.map((store, idx) => ({
          ...store,
          id: idx,
          include: store.include !== false,
          manual: !!store.manual,
          allocation: Math.max(0, Math.round(Number(store.allocation) || 0)),
          adjustments: {
            ...defaultAdjustments(),
            ...(store.adjustments || {}),
          },
        }));
        const included = normalized.filter((store) => store.include);
        if (!included.length) {
          return normalized.map((store) => ({
            ...store,
            allocation: 0,
            manual: false,
          }));
        }
        const manualStores = included.filter((store) => store.manual);
        let manualSum = manualStores.reduce((sum, store) => sum + store.allocation, 0);
        if (manualSum > total) {
          manualSum = total;
        }
        const remainder = Math.max(0, total - manualSum);
        const autoStores = included.filter((store) => !store.manual);
        const basisId = basisKey || "even";
        const allocationMap =
          autoStores.length && remainder > 0
            ? distributeAmong(autoStores, remainder, (store) =>
                getWeightedValue(store, basisId)
              )
            : new Map();
        return normalized.map((store) => {
          if (!store.include) {
            return { ...store, allocation: 0, manual: false };
          }
          if (store.manual) {
            return {
              ...store,
              allocation: Math.max(0, Math.round(store.allocation)),
            };
          }
          const value = allocationMap.get(store.id) ?? 0;
          return { ...store, allocation: value };
        });
      };
      function useAllocations(
        initialTotal = 10000,
        initialStores = 150
      ) {
        const initialStoreCount = Math.max(
          1,
          Number(initialStores) || 150
        );
        const [total, setTotal] = React.useState(initialTotal);
        const [storeCount, setStoreCount] = React.useState(initialStoreCount);
        const [basis, setBasis] = React.useState("even");
        const [stores, setStores] = React.useState(() =>
          distributeStores(
            Array.from({ length: initialStoreCount }, (_, idx) => buildStore(idx)),
            "even",
            initialTotal
          )
        );
        const [masterInfo, setMasterInfo] = React.useState(null);
        const [patternInfos, setPatternInfos] = React.useState({});
        const storesRef = React.useRef(stores);
        const basisRef = React.useRef(basis);
        React.useEffect(() => {
          storesRef.current = stores;
        }, [stores]);
        React.useEffect(() => {
          basisRef.current = basis;
        }, [basis]);

        React.useEffect(() => {
          setStores((prev) => {
            const adjusted = (() => {
              const next = [...prev];
              if (storeCount > prev.length) {
                for (let i = prev.length; i < storeCount; i += 1) {
                  next.push(buildStore(i));
                }
              } else if (storeCount < prev.length) {
                next.length = storeCount;
              }
              return next.map((store, idx) => ({ ...store, id: idx }));
            })();
            return distributeStores(adjusted, basisRef.current, total);
          });
        }, [storeCount, total]);

        const currentSum = React.useMemo(
          () => stores.reduce((sum, store) => sum + store.allocation, 0),
          [stores]
        );
        const difference = React.useMemo(
          () => Math.round(total) - currentSum,
          [total, currentSum]
        );
        const includedCount = React.useMemo(
          () => stores.filter((store) => store.include).length,
          [stores]
        );

        const handleStoreCountChange = React.useCallback((event) => {
          const digits = event.target.value.replace(/[^\d]/g, "");
          if (!digits) {
            setStoreCount(1);
            return;
          }
          const next = Math.max(1, Math.min(9999, Number(digits)));
          setStoreCount(next);
        }, []);

        const handleTotalChange = React.useCallback((event) => {
          const digits = event.target.value.replace(/[^\d]/g, "");
          const next = Number(digits);
          setTotal(Number.isFinite(next) ? next : 0);
        }, []);

        const updateStores = React.useCallback(
          (mutator, nextBasis = basisRef.current, nextTotal = total) => {
            setStores((prev) => {
              const updated = mutator(prev.map((store) => ({ ...store })));
              return distributeStores(updated, nextBasis, nextTotal);
            });
          },
          [total]
        );
        const handleAllocationChange = React.useCallback(
          (index, value) => {
            const next = Math.max(0, Math.round(value || 0));
            updateStores((prev) =>
              prev.map((store, idx) =>
                idx === index
                  ? { ...store, allocation: next, manual: true }
                  : store
              )
            );
          },
          [updateStores]
        );

        const releaseManualAllocation = React.useCallback(
          (index) => {
            updateStores((prev) =>
              prev.map((store, idx) =>
                idx === index ? { ...store, manual: false } : store
              )
            );
          },
          [updateStores]
        );

        const toggleStoreInclude = React.useCallback(
          (index) => {
            updateStores((prev) =>
              prev.map((store, idx) => {
                if (idx !== index) return store;
                if (store.include) {
                  return {
                    ...store,
                    include: false,
                    manual: false,
                    allocation: 0,
                  };
                }
                return { ...store, include: true };
              })
            );
          },
          [updateStores]
        );

        const toggleAllIncludes = React.useCallback(
          (include) => {
            updateStores((prev) =>
              prev.map((store) => ({
                ...store,
                include,
                manual: include ? store.manual : false,
                allocation: include ? store.allocation : 0,
              }))
            );
          },
          [updateStores]
        );

        const handleMetricChange = React.useCallback(
          (index, key, value) => {
            if (key === "name") {
              updateStores((prev) =>
                prev.map((store, idx) =>
                  idx === index ? { ...store, name: value } : store
                )
              );
              return;
            }
            let nextValue = Number(value);
            if (key === "customCoefficient") {
              nextValue = Math.max(
                0,
                Math.round((Number(value) || 0) * 1000) / 1000
              );
            } else if (key === "csvCoefficient") {
              nextValue = Number.isFinite(nextValue) ? nextValue : null;
            } else {
              nextValue = Math.max(0, Math.round(Number(value) || 0));
            }
            updateStores((prev) =>
              prev.map((store, idx) =>
                idx === index ? { ...store, [key]: nextValue } : store
              )
            );
          },
          [updateStores]
        );

        const handleAdjustmentChange = React.useCallback(
          (index, key, value) => {
            const nextValue = Math.max(
              -1000,
              Math.min(1000, Math.round((Number(value) || 0) * 10) / 10)
            );
            updateStores((prev) =>
              prev.map((store, idx) =>
                idx === index
                  ? {
                      ...store,
                      adjustments: {
                        ...defaultAdjustments(),
                        ...(store.adjustments || {}),
                        [key]: nextValue,
                      },
                    }
                  : store
              )
            );
          },
          [updateStores]
        );
        const handleMasterCsvUpload = React.useCallback(
          (file) => {
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
              const text = event.target.result;
              if (typeof text !== "string") return;
              const result = parseMasterCsv(text, storesRef.current);
              if (result.records.length) {
                updateStores((prev) => {
                  const next = [...prev];
                  result.records.forEach(({ id, patch }) => {
                    while (next.length <= id) {
                      next.push(buildStore(next.length));
                    }
                    const base = next[id] ?? buildStore(id);
                    const nextAdjustments = {
                      ...defaultAdjustments(),
                      ...(base.adjustments || {}),
                      ...(patch.adjustments || {}),
                    };
                    const updated = {
                      ...base,
                      ...patch,
                      adjustments: nextAdjustments,
                      id,
                    };
                    if (patch.allocation !== undefined) {
                      updated.allocation = Math.max(0, Math.round(patch.allocation));
                      updated.manual = patch.manual !== false;
                    }
                    if (patch.manual !== undefined) {
                      updated.manual = patch.manual;
                    }
                    if (patch.include === false) {
                      updated.manual = false;
                      updated.allocation = 0;
                    }
                    next[id] = updated;
                  });
                  if (result.highestId >= 0 && result.highestId + 1 > storeCount) {
                    setStoreCount(result.highestId + 1);
                  }
                  return next;
                });
              }
              const totalCount =
                result.highestId >= 0
                  ? Math.max(storesRef.current.length, result.highestId + 1)
                  : storesRef.current.length;
              setMasterInfo({
                fileName: file.name,
                matchedCount: result.matched,
                totalCount,
                status: result.status,
                message: result.message,
              });
            };
            reader.onerror = () => {
              setMasterInfo({
                fileName: file.name,
                matchedCount: 0,
                totalCount: storesRef.current.length,
                status: "error",
                message: "CSVの読み込みに失敗しました。",
              });
            };
            reader.readAsText(file, "utf-8");
          },
          [storeCount, updateStores]
        );

        const handlePatternUpload = React.useCallback(
          (key, file) => {
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
              const text = event.target.result;
              if (typeof text !== "string") return;
              const matches = parseCoefficientCsv(text, storesRef.current);
              const matchedCount = matches.size;
              if (matchedCount) {
                updateStores((prev) =>
                  prev.map((store) => {
                    if (!matches.has(store.id)) return store;
                    const rawValue = matches.get(store.id);
                    let value = rawValue;
                    if (key === "sales" || key === "area") {
                      value = Math.max(0, Math.round(rawValue));
                    } else if (key === "customCoefficient") {
                      value = Math.max(0, Math.round(rawValue * 1000) / 1000);
                    }
                    return { ...store, [key]: value };
                  })
                );
              }
              const label = PATTERN_LABELS[key] || key;
              setPatternInfos((prev) => ({
                ...prev,
                [key]: {
                  fileName: file.name,
                  matchedCount,
                  totalCount: storesRef.current.length,
                  status: matchedCount ? "success" : "warning",
                  message: matchedCount
                    ? `${matchedCount}件の${label}を更新しました。`
                    : "一致する店舗が見つかりませんでした。",
                },
              }));
            };
            reader.onerror = () => {
              const label = PATTERN_LABELS[key] || key;
              setPatternInfos((prev) => ({
                ...prev,
                [key]: {
                  fileName: file.name,
                  matchedCount: 0,
                  totalCount: storesRef.current.length,
                  status: "error",
                  message: `${label}のCSVの読み込みに失敗しました。`,
                },
              }));
            };
            reader.readAsText(file, "utf-8");
          },
          [updateStores]
        );

        const dismissMasterInfo = React.useCallback(() => {
          setMasterInfo(null);
        }, []);

        const dismissPatternInfo = React.useCallback((key) => {
          setPatternInfos((prev) => ({
            ...prev,
            [key]: null,
          }));
        }, []);

        const changeBasis = React.useCallback(
          (nextBasis) => {
            setBasis(nextBasis);
            updateStores((prev) => prev, nextBasis, total);
          },
          [total, updateStores]
        );

        const distribute = React.useCallback(() => {
          updateStores((prev) => prev);
        }, [updateStores]);

        const applyDifference = React.useCallback(() => {
          updateStores((prev) => prev);
        }, [updateStores]);

        const clearMasterData = React.useCallback(() => {
          updateStores((prev) => prev.map((_, idx) => buildStore(idx)));
          setMasterInfo(null);
        }, [updateStores]);

        const resetAll = React.useCallback(() => {
          updateStores((prev) =>
            prev.map((store) => ({
              ...store,
              allocation: 0,
              manual: false,
            }))
          );
          setBasis("even");
        }, [updateStores]);
        const composeCsv = React.useCallback((rows) => {
          return rows
            .map((cells) =>
              cells
                .map((cell) =>
                  `"${String(cell ?? "").replace(/"/g, '""')}"`
                )
                .join(",")
            )
            .join("\r\n");
        }, []);

        const triggerCsvDownload = React.useCallback(
          (filename, rows) => {
            const csvContent = composeCsv(rows);
            const blob = new Blob([csvContent], {
              type: "text/csv;charset=utf-8;",
            });
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.href = url;
            link.download = filename;
            link.click();
            setTimeout(() => URL.revokeObjectURL(url), 0);
          },
          [composeCsv]
        );

        const downloadMasterTemplate = React.useCallback(() => {
          const baseStores =
            storesRef.current.length > 0
              ? storesRef.current
              : Array.from({ length: storeCount }, (_, idx) => buildStore(idx));
          const sampleCount = Math.min(
            10,
            baseStores.length || 150
          );
          const rows = [
            [
              "No",
              "店舗名",
              "売上",
              "売上調整%",
              "面積",
              "面積調整%",
              "任意係数",
              "任意調整%",
              "CSV係数",
              "CSV調整%",
              "対象",
              "配分値",
            ],
            ...Array.from({ length: sampleCount }, (_, idx) => {
              const store = baseStores[idx] ?? buildStore(idx);
              const adjustments = {
                ...defaultAdjustments(),
                ...(store.adjustments || {}),
              };
              return [
                String(idx + 1),
                store.name,
                store.sales,
                adjustments.sales,
                store.area,
                adjustments.area,
                store.customCoefficient,
                adjustments.customCoefficient,
                store.csvCoefficient ?? "",
                adjustments.csvCoefficient,
                store.include ? 1 : 0,
                store.allocation,
              ];
            }),
          ];
          triggerCsvDownload("master_template.csv", rows);
        }, [storeCount, triggerCsvDownload]);

        const downloadPatternTemplate = React.useCallback(
          (key) => {
            const label = PATTERN_LABELS[key] || key;
            const baseStores =
              storesRef.current.length > 0
                ? storesRef.current
                : Array.from({ length: storeCount }, (_, idx) => buildStore(idx));
            const sampleCount = Math.min(
              10,
              baseStores.length || 150
            );
            const rows = [
              ["No", label],
              ...Array.from({ length: sampleCount }, (_, idx) => {
                const store = baseStores[idx] ?? buildStore(idx);
                const value = store[key] ?? "";
                return [String(idx + 1), value];
              }),
            ];
            triggerCsvDownload(`${key}_template.csv`, rows);
          },
          [storeCount, triggerCsvDownload]
        );

        const downloadAllocationCsv = React.useCallback(() => {
          const rows = [
            [
              "No",
              "店舗名",
              "配分値",
              "対象",
              "売上",
              "売上調整%",
              "面積",
              "面積調整%",
              "任意係数",
              "任意調整%",
              "CSV係数",
              "CSV調整%",
            ],
            ...storesRef.current.map((store, idx) => {
              const adjustments = {
                ...defaultAdjustments(),
                ...(store.adjustments || {}),
              };
              return [
                String(idx + 1),
                store.name,
                store.allocation,
                store.include ? 1 : 0,
                store.sales,
                adjustments.sales,
                store.area,
                adjustments.area,
                store.customCoefficient,
                adjustments.customCoefficient,
                store.csvCoefficient ?? "",
                adjustments.csvCoefficient,
              ];
            }),
          ];
          triggerCsvDownload("allocation_export.csv", rows);
        }, [triggerCsvDownload]);

        const printAllocations = React.useCallback(() => {
          window.print();
        }, []);

        return {
          total,
          storeCount,
          stores,
          currentSum,
          difference,
          includedCount,
          basis,
          masterInfo,
          patternInfos,
          handleStoreCountChange,
          handleTotalChange,
          handleAllocationChange,
          releaseManualAllocation,
          toggleStoreInclude,
          toggleAllIncludes,
          handleMetricChange,
          handleAdjustmentChange,
          handleMasterCsvUpload,
          handlePatternUpload,
          dismissPatternInfo,
          distribute,
          applyDifference,
          resetAll,
          downloadMasterTemplate,
          downloadPatternTemplate,
          downloadAllocationCsv,
          printAllocations,
          clearMasterData,
          dismissMasterInfo,
          changeBasis,
        };
      }
      function SummaryPanel({
        total,
        storeCount,
        currentSum,
        difference,
        includedCount,
        onStoreCountChange,
        onTotalChange,
        basisLabel,
        onDownloadCsv,
        onPrint,
      }) {
        const completion =
          total === 0 ? 0 : Math.min(100, Math.round((currentSum / total) * 100));
        const differenceLabel =
          difference === 0
            ? "目標値に一致"
            : difference > 0
            ? `未配分 ${difference.toLocaleString()}`
            : `超過 ${Math.abs(difference).toLocaleString()}`;
        const differenceColor =
          difference === 0 ? "success" : difference > 0 ? "warning" : "error";
        return (
          <Stack spacing={1.5} className="no-print">
            <Grid container spacing={1.25}>
              <Grid item xs={12} md={3}>
                <TextField
                  label="店舗数"
                  value={storeCount}
                  onChange={onStoreCountChange}
                  fullWidth
                  type="number"
                  inputProps={{ min: 1, step: 1 }}
                />
              </Grid>
              <Grid item xs={12} md={3}>
                <TextField
                  label="目標総数"
                  value={total.toLocaleString()}
                  onChange={onTotalChange}
                  fullWidth
                  inputProps={{ inputMode: "numeric", pattern: "[0-9,]*" }}
                />
              </Grid>
              <Grid item xs={6} md={3}>
                <TextField
                  label="配分済み"
                  value={currentSum.toLocaleString()}
                  InputProps={{ readOnly: true }}
                  fullWidth
                />
              </Grid>
              <Grid item xs={6} md={3}>
                <TextField
                  label="配分対象店舗"
                  value={`${includedCount} 店`}
                  InputProps={{ readOnly: true }}
                  fullWidth
                />
              </Grid>
            </Grid>
            <LinearProgress
              variant="determinate"
              value={completion}
              sx={{ height: 8, borderRadius: 999 }}
            />
            <Stack
              direction={{ xs: "column", md: "row" }}
              spacing={1}
              alignItems={{ xs: "flex-start", md: "center" }}
              justifyContent="space-between"
            >
              <Stack direction="row" spacing={1} alignItems="center">
                <Chip label={`モード: ${basisLabel}`} variant="outlined" />
                <Chip label={`完了率 ${completion}%`} color="primary" variant="outlined" />
                <Chip label={differenceLabel} color={differenceColor} variant="outlined" />
              </Stack>
              <Stack direction="row" spacing={1}>
                <Button
                  variant="outlined"
                  startIcon={<span className="material-icons">download</span>}
                  onClick={onDownloadCsv}
                >
                  配分CSV出力
                </Button>
                <Button
                  variant="outlined"
                  startIcon={<span className="material-icons">print</span>}
                  onClick={onPrint}
                >
                  印刷
                </Button>
              </Stack>
            </Stack>
          </Stack>
        );
      }

      function TopActions({
        onDistribute,
        onAdjust,
        onSelectAll,
        onReset,
      }) {
        return (
          <Stack
            direction={{ xs: "column", md: "row" }}
            spacing={1}
            alignItems={{ xs: "stretch", md: "center" }}
            justifyContent="space-between"
            className="no-print"
          >
            <Stack direction={{ xs: "column", sm: "row" }} spacing={1}>
              <Button
                variant="contained"
                color="primary"
                startIcon={<span className="material-icons">sync</span>}
                onClick={onDistribute}
              >
                配分を再計算
              </Button>
              <Button
                variant="outlined"
                color="secondary"
                startIcon={<span className="material-icons">tune</span>}
                onClick={onAdjust}
              >
                差分を調整
              </Button>
            </Stack>
            <Stack direction={{ xs: "column", sm: "row" }} spacing={1}>
              <Button
                variant="outlined"
                startIcon={<span className="material-icons">done_all</span>}
                onClick={() => onSelectAll(true)}
              >
                全選択
              </Button>
              <Button
                variant="outlined"
                startIcon={<span className="material-icons">layers_clear</span>}
                onClick={() => onSelectAll(false)}
              >
                全解除
              </Button>
              <Button
                variant="text"
                startIcon={<span className="material-icons">restart_alt</span>}
                onClick={onReset}
              >
                全リセット
              </Button>
            </Stack>
          </Stack>
        );
      }
      function AllocationTable({
        stores,
        basis,
        onBasisChange,
        onAllocationChange,
        onReleaseManual,
        onToggleInclude,
        onToggleAll,
        allSelected,
        someSelected,
        onMetricChange,
        onAdjustmentChange,
        total,
        currentSum,
        difference,
        dense,
        masterInfo,
        patternInfos,
        onMasterUpload,
        onPatternUpload,
        onDownloadMasterTemplate,
        onDownloadPatternTemplate,
        onDismissMasterInfo,
        onDismissPatternInfo,
        onResetMaster,
      }) {
        const tableRef = React.useRef(null);
        const masterInputRef = React.useRef(null);
        const fileInputRefs = React.useRef({});
        const editableColumns = React.useMemo(
          () => ["allocation", "sales", "area", "customCoefficient"],
          []
        );
        const tryFocus = React.useCallback((rowIndex, columnKey) => {
          if (!tableRef.current) return false;
          if (rowIndex < 0 || rowIndex >= stores.length) return false;
          const selector = `input.sheet-input[data-row-index="${rowIndex}"][data-col-key="${columnKey}"]`;
          const next = tableRef.current.querySelector(selector);
          if (next && !next.disabled) {
            next.focus();
            if (typeof next.select === "function") next.select();
            return true;
          }
          return false;
        }, [stores.length]);

        const handleCellKeyDown = React.useCallback(
          (event, rowIndex, columnKey) => {
            const key = event.key;
            if (key === "ArrowRight" || key === "ArrowLeft") {
              const step = key === "ArrowRight" ? 1 : -1;
              const currentIdx = editableColumns.indexOf(columnKey);
              if (currentIdx === -1) return;
              for (
                let nextIdx = currentIdx + step;
                nextIdx >= 0 && nextIdx < editableColumns.length;
                nextIdx += step
              ) {
                if (tryFocus(rowIndex, editableColumns[nextIdx])) {
                  event.preventDefault();
                  return;
                }
              }
            } else if (key === "ArrowDown" || key === "ArrowUp") {
              const step = key === "ArrowDown" ? 1 : -1;
              for (
                let nextRow = rowIndex + step;
                nextRow >= 0 && nextRow < stores.length;
                nextRow += step
              ) {
                if (tryFocus(nextRow, columnKey)) {
                  event.preventDefault();
                  return;
                }
              }
            } else if (key === "Enter") {
              for (
                let nextRow = rowIndex + 1;
                nextRow < stores.length;
                nextRow += 1
              ) {
                if (tryFocus(nextRow, columnKey)) {
                  event.preventDefault();
                  return;
                }
              }
              event.preventDefault();
            }
          },
          [editableColumns, stores.length, tryFocus]
        );
        const patternColumns = React.useMemo(
          () => [
            { key: "sales", label: "売上" },
            { key: "area", label: "面積" },
            { key: "customCoefficient", label: "任意係数" },
            { key: "csvCoefficient", label: "CSV係数" },
          ],
          []
        );

        const alerts = [];
        if (masterInfo && masterInfo.message) {
          alerts.push({
            key: "master",
            info: masterInfo,
            label: masterInfo.fileName || "マスターCSV",
            severity:
              masterInfo.status === "error"
                ? "error"
                : masterInfo.status === "warning"
                ? "warning"
                : "success",
            onClose: onDismissMasterInfo,
            onReset: masterInfo.status === "success" ? onResetMaster : null,
          });
        }
        Object.entries(patternInfos || {}).forEach(([key, info]) => {
          if (!info || !info.message) return;
          alerts.push({
            key,
            info,
            label: info.fileName || PATTERN_LABELS[key] || key,
            severity:
              info.status === "error"
                ? "error"
                : info.status === "warning"
                ? "warning"
                : "success",
            onClose: () => onDismissPatternInfo(key),
            onReset: null,
          });
        });

        const diffText =
          difference === 0
            ? "配分値は目標に一致しています"
            : difference > 0
            ? `未配分 ${difference.toLocaleString()}`
            : `超過 ${Math.abs(difference).toLocaleString()}`;
        const diffClass =
          difference === 0
            ? "sheet-status-ok"
            : difference > 0
            ? "sheet-status-warn"
            : "sheet-status-over";

        const basisForColumn = {
          sales: "sales",
          area: "area",
          customCoefficient: "custom",
          csvCoefficient: "csv",
        };
        return (
          <Box>
            {alerts.length > 0 && (
              <Stack spacing={0.75} sx={{ mb: 1.25 }} className="no-print">
                {alerts.map((alert) => (
                  <Alert
                    key={alert.key}
                    severity={alert.severity}
                    action={
                      <Stack direction="row" spacing={0.5} alignItems="center">
                        {alert.onReset && (
                          <Button size="small" onClick={alert.onReset}>
                            リセット
                          </Button>
                        )}
                        <IconButton
                          size="small"
                          onClick={alert.onClose}
                          aria-label="通知を閉じる"
                        >
                          <span className="material-icons" style={{ fontSize: 18 }}>
                            close
                          </span>
                        </IconButton>
                      </Stack>
                    }
                  >
                    <Stack
                      direction={{ xs: "column", sm: "row" }}
                      spacing={1}
                      alignItems={{ xs: "flex-start", sm: "center" }}
                    >
                      <span>{alert.info.message}</span>
                      <Chip label={alert.label} sx={{ ml: { sm: "auto" } }} />
                    </Stack>
                  </Alert>
                ))}
              </Stack>
            )}
            <Box className="sheet-container" ref={tableRef}>
              <table className="sheet-table">
                <thead>
                  <tr className="header-controls-row">
                    <th className="header-control-empty">
                      <Checkbox
                        size="small"
                        checked={allSelected}
                        indeterminate={!allSelected && someSelected}
                        onChange={(event) => onToggleAll(event.target.checked)}
                      />
                    </th>
                    <th className="header-control-cell">
                      <Stack spacing={0.5} alignItems={{ xs: "flex-start", sm: "flex-start" }}>
                        <Stack direction="row" spacing={0.5} flexWrap="wrap">
                          <Button
                            size="small"
                            variant="outlined"
                            startIcon={<span className="material-icons">table_view</span>}
                            onClick={() => masterInputRef.current?.click()}
                          >
                            マスター読込
                          </Button>
                          <Button
                            size="small"
                            variant="text"
                            onClick={onDownloadMasterTemplate}
                          >
                            テンプレート
                          </Button>
                        </Stack>
                      </Stack>
                      <input
                        type="file"
                        accept=".csv"
                        ref={masterInputRef}
                        style={{ display: "none" }}
                        onChange={(event) => {
                          const file = event.target.files?.[0];
                          if (file) onMasterUpload(file);
                          event.target.value = "";
                        }}
                      />
                    </th>
                    <th className="header-control-cell">
                      <Stack direction="row" spacing={0.5} alignItems="center">
                        <Checkbox
                          size="small"
                          checked={basis === "even"}
                          onChange={() => onBasisChange("even")}
                        />
                        <Typography variant="caption">均等</Typography>
                      </Stack>
                    </th>
                    <th className="header-control-empty" />
                    {patternColumns.map((column) => {
                      if (!fileInputRefs.current[column.key]) {
                        fileInputRefs.current[column.key] = React.createRef();
                      }
                      return (
                        <React.Fragment key={column.key}>
                          <th className="align-right header-control-cell">
                            <Stack
                              direction="row"
                              spacing={0.5}
                              alignItems="center"
                              justifyContent="flex-end"
                              flexWrap="wrap"
                            >
                              <Checkbox
                                size="small"
                                checked={basis === basisForColumn[column.key]}
                                onChange={() => onBasisChange(basisForColumn[column.key])}
                              />
                              <Typography variant="caption">{column.label}</Typography>
                              <Button
                                size="small"
                                variant="outlined"
                                startIcon={<span className="material-icons">upload_file</span>}
                                onClick={() => fileInputRefs.current[column.key].current?.click()}
                              >
                                読込
                              </Button>
                              <Button
                                size="small"
                                variant="text"
                                onClick={() => onDownloadPatternTemplate(column.key)}
                              >
                                テンプレ
                              </Button>
                            </Stack>
                            <input
                              type="file"
                              accept=".csv"
                              ref={fileInputRefs.current[column.key]}
                              style={{ display: "none" }}
                              onChange={(event) => {
                                const file = event.target.files?.[0];
                                if (file) onPatternUpload(column.key, file);
                                event.target.value = "";
                              }}
                            />
                          </th>
                          <th className="align-right header-control-empty" />
                        </React.Fragment>
                      );
                    })}
                  </tr>
                  <tr className="header-label-row">
                    <th className="row-index">No.</th>
                    <th>店舗（配分対象）</th>
                    <th className={`align-right metric-cell ${basis === "even" ? "basis-active" : ""}`}>
                      配分値
                    </th>
                    <th className="align-right metric-cell">累計</th>
                    {patternColumns.map((column) => (
                      <React.Fragment key={`label-${column.key}`}>
                        <th
                          className={`align-right metric-cell ${
                            basis === basisForColumn[column.key] ? "basis-active" : ""
                          }`}
                        >
                          {column.label}
                        </th>
                        <th className="align-right adjust-cell">調整%</th>
                      </React.Fragment>
                    ))}
                  </tr>
                </thead>
                <tbody>
                  {stores.map((store, idx) => {
                    const runningTotal = stores
                      .slice(0, idx + 1)
                      .reduce((sum, item) => sum + item.allocation, 0);
                    const adjustments = {
                      ...defaultAdjustments(),
                      ...(store.adjustments || {}),
                    };
                    return (
                      <tr key={store.id} className={store.include ? undefined : "inactive"}>
                        <td className="row-index">{String(idx + 1).padStart(3, "0")}</td>
                        <td className="store-cell">
                          <Checkbox
                            size="small"
                            checked={store.include}
                            onChange={() => onToggleInclude(idx)}
                            inputProps={{
                              "aria-label": `${store.name}を配分対象に含める`,
                            }}
                          />
                          <TextField
                            variant="standard"
                            value={store.name}
                            onChange={(event) => onMetricChange(idx, "name", event.target.value)}
                            InputProps={{ disableUnderline: true }}
                            fullWidth
                          />
                        </td>
                        <td className={`align-right metric-cell ${basis === "even" ? "basis-active" : ""}`}>
                          <Box sx={{ display: "flex", alignItems: "center", gap: 0.5 }}>
                            <input
                              type="number"
                              className="sheet-input"
                              value={store.allocation}
                              onChange={(event) =>
                                onAllocationChange(idx, Number(event.target.value))
                              }
                              onKeyDown={(event) => handleCellKeyDown(event, idx, "allocation")}
                              data-row-index={idx}
                              data-col-key="allocation"
                              min={0}
                              step={1}
                              inputMode="numeric"
                              disabled={!store.include}
                            />
                            {store.manual && (
                              <Tooltip title="自動計算に戻す">
                                <IconButton size="small" onClick={() => onReleaseManual(idx)}>
                                  <span className="material-icons" style={{ fontSize: 18 }}>
                                    undo
                                  </span>
                                </IconButton>
                              </Tooltip>
                            )}
                          </Box>
                        </td>
                        <td className="align-right metric-cell">
                          {runningTotal.toLocaleString()}
                        </td>
                        {patternColumns.map((column) => (
                          <React.Fragment key={`${store.id}-${column.key}`}>
                            <td
                              className={`align-right metric-cell ${
                                basis === basisForColumn[column.key] ? "basis-active" : ""
                              }`}
                            >
                              <input
                                type="number"
                                className="sheet-input"
                                value={
                                  store[column.key] === null || store[column.key] === undefined
                                    ? ""
                                    : store[column.key]
                                }
                                onChange={(event) =>
                                  onMetricChange(idx, column.key, event.target.value)
                                }
                                onKeyDown={(event) =>
                                  handleCellKeyDown(event, idx, column.key)
                                }
                                data-row-index={idx}
                                data-col-key={column.key}
                                min={0}
                                step={column.key === "customCoefficient" ? 0.001 : 1}
                                inputMode={column.key === "customCoefficient" ? "decimal" : "numeric"}
                              />
                            </td>
                            <td className="align-right adjust-cell">
                              <input
                                type="number"
                                className="sheet-input"
                                value={adjustments[column.key] ?? 0}
                                onChange={(event) =>
                                  onAdjustmentChange(idx, column.key, event.target.value)
                                }
                                step={0.1}
                                inputMode="decimal"
                              />
                            </td>
                          </React.Fragment>
                        ))}
                      </tr>
                    );
                  })}
                </tbody>
                <tfoot>
                  <tr>
                    <td colSpan="3">配分済み合計</td>
                    <td className="align-right">{currentSum.toLocaleString()}</td>
                    <td colSpan="8" className="align-right">
                      目標 {total.toLocaleString()}
                    </td>
                  </tr>
                  <tr>
                    <td colSpan="3">差分</td>
                    <td colSpan="9" className={`align-right ${diffClass}`}>
                      {diffText}
                    </td>
                  </tr>
                </tfoot>
              </table>
            </Box>
          </Box>
        );
      }
      function App() {
        const {
          total,
          storeCount,
          stores,
          currentSum,
          difference,
          includedCount,
          basis,
          masterInfo,
          patternInfos,
          handleStoreCountChange,
          handleTotalChange,
          handleAllocationChange,
          releaseManualAllocation,
          toggleStoreInclude,
          toggleAllIncludes,
          handleMetricChange,
          handleAdjustmentChange,
          handleMasterCsvUpload,
          handlePatternUpload,
          dismissPatternInfo,
          distribute,
          applyDifference,
          resetAll,
          downloadMasterTemplate,
          downloadPatternTemplate,
          downloadAllocationCsv,
          printAllocations,
          clearMasterData,
          dismissMasterInfo,
          changeBasis,
        } = useAllocations();
        const isMobile = useMediaQuery("(max-width:900px)");
        const basisLabel =
          DISTRIBUTION_BASES.find((item) => item.id === basis)?.label || "未選択";
        const allSelected = stores.length > 0 && stores.every((store) => store.include);
        const someSelected = stores.some((store) => store.include) && !allSelected;
        const theme = React.useMemo(
          () =>
            createTheme({
              palette: {
                primary: { main: "#1d4ed8" },
                secondary: { main: "#0284c7" },
              },
              typography: {
                button: { textTransform: "none", fontWeight: 600 },
              },
              shape: { borderRadius: 16 },
            }),
          []
        );

        return (
          <ThemeProvider theme={theme}>
            <CssBaseline />
            <Box sx={{ display: "flex", flexDirection: "column", width: "100%" }}>
              <AppBar position="sticky" elevation={8} className="no-print">
                <Toolbar sx={{ gap: 1 }}>
                  <Typography variant="h6" sx={{ flexGrow: 1, fontWeight: 700 }}>
                    店舗配分シミュレーター
                  </Typography>
                  <Tooltip title="配分値と設定を初期化">
                    <IconButton color="inherit" onClick={resetAll}>
                      <span className="material-icons">refresh</span>
                    </IconButton>
                  </Tooltip>
                </Toolbar>
              </AppBar>
              <Container
                maxWidth={false}
                disableGutters
                sx={{
                  px: { xs: 1.5, md: 3.5 },
                  py: { xs: 2, md: 3 },
                  width: "100%",
                  flexGrow: 1,
                }}
              >
                <Stack spacing={2.5} sx={{ width: "100%" }}>
                  <Paper elevation={6} sx={{ p: { xs: 1.5, md: 2.5 } }}>
                    <SummaryPanel
                      total={total}
                      storeCount={storeCount}
                      currentSum={currentSum}
                      difference={difference}
                      includedCount={includedCount}
                      onStoreCountChange={handleStoreCountChange}
                      onTotalChange={handleTotalChange}
                      basisLabel={basisLabel}
                      onDownloadCsv={downloadAllocationCsv}
                      onPrint={printAllocations}
                    />
                  </Paper>
                  <Paper
                    elevation={4}
                    sx={{
                      p: { xs: 1.5, md: 2 },
                      display: "flex",
                      flexDirection: "column",
                      gap: 1.5,
                    }}
                  >
                    <TopActions
                      onDistribute={distribute}
                      onAdjust={applyDifference}
                      onSelectAll={toggleAllIncludes}
                      onReset={resetAll}
                    />
                    <Divider className="no-print" />
                    <AllocationTable
                      stores={stores}
                      basis={basis}
                      onBasisChange={changeBasis}
                      onAllocationChange={handleAllocationChange}
                      onReleaseManual={releaseManualAllocation}
                      onToggleInclude={toggleStoreInclude}
                      onToggleAll={toggleAllIncludes}
                      allSelected={allSelected}
                      someSelected={someSelected}
                      onMetricChange={handleMetricChange}
                      onAdjustmentChange={handleAdjustmentChange}
                      total={total}
                      currentSum={currentSum}
                      difference={difference}
                      dense={isMobile}
                      masterInfo={masterInfo}
                      patternInfos={patternInfos}
                      onMasterUpload={handleMasterCsvUpload}
                      onPatternUpload={handlePatternUpload}
                      onDownloadMasterTemplate={downloadMasterTemplate}
                      onDownloadPatternTemplate={downloadPatternTemplate}
                      onDismissMasterInfo={dismissMasterInfo}
                      onDismissPatternInfo={dismissPatternInfo}
                      onResetMaster={clearMasterData}
                    />
                  </Paper>
                </Stack>
              </Container>
            </Box>
          </ThemeProvider>
        );
      }

      ReactDOM.createRoot(document.getElementById("root")).render(<App />);
    </script>
  </body>
</html>
