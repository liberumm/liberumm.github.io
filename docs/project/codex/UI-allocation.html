<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>150店舗 配分シミュレーター</title>
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap"
    />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/icon?family=Material+Icons"
    />
    <script
      src="https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.production.min.js"
      crossorigin
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.production.min.js"
      crossorigin
    ></script>
    <script src="https://cdn.jsdelivr.net/npm/@babel/standalone@7.23.8/babel.min.js"></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mui/material@5.15.3/umd/material-ui.production.min.js"
      crossorigin
    ></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
      :root {
        color-scheme: light;
      }
      html,
      body {
        margin: 0;
        padding: 0;
        min-height: 100%;
        font-family: "Roboto", "Segoe UI", Helvetica, Arial, sans-serif;
        background: linear-gradient(180deg, #eef1f7 0%, #f7f8fb 100%);
        width: 100%;
        overflow-x: hidden;
      }
      #root {
        min-height: 100vh;
        display: flex;
        width: 100%;
      }
      @media (max-width: 600px) {
        body {
          background: #eef1f7;
        }
        #root {
          min-height: 100vh;
        }
      }
      .sheet-container {
        overflow: auto;
        -webkit-overflow-scrolling: touch;
        border: 1px solid rgba(120, 130, 170, 0.25);
        border-radius: 12px;
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.7);
        background: rgba(255, 255, 255, 0.92);
      }
      @media (max-width: 600px) {
        .sheet-container {
          max-height: 60vh;
          border-radius: 8px;
        }
      }
      .sheet-table {
        width: 100%;
        border-collapse: separate;
        border-spacing: 0;
        font-size: 0.82rem;
        color: #0f172a;
      }
      .sheet-table th,
      .sheet-table td {
        border: 1px solid #d6dbe8;
        padding: 4px 6px;
        background-color: #fff;
      }
      .sheet-table th {
        position: sticky;
        top: 0;
        z-index: 4;
        background: linear-gradient(180deg, #f8fbff 0%, #edf2ff 100%);
        font-weight: 600;
        color: #1f2a44;
        text-align: left;
      }
      .sheet-table th.align-right,
      .sheet-table td.align-right {
        text-align: right;
      }
      .sheet-table td.align-center {
        text-align: center;
      }
      .sheet-table th:first-child,
      .sheet-table td:first-child {
        position: sticky;
        left: 0;
        z-index: 3;
        background-color: #f8fafc;
        font-weight: 500;
        color: #475569;
      }
      .sheet-table tbody tr:nth-child(odd) td {
        background-color: #fbfcff;
      }
      .sheet-table tbody tr:hover td {
        background-color: #eef4ff;
      }
      .sheet-table tbody tr:focus-within td {
        background-color: #e2ecff;
        outline: 1px solid rgba(37, 99, 235, 0.7);
        outline-offset: -1px;
      }
      .sheet-table tbody tr.inactive td {
        background-color: #f1f5f9;
        color: #94a3b8;
      }
      .sheet-table tbody tr.inactive td:first-child {
        background-color: #e8edf5;
      }
      .sheet-table tbody tr.inactive .sheet-input:disabled {
        background-color: #e8edf5;
        color: #7b8ba6;
      }
      .sheet-input.fixed-input {
        background-color: #fed7aa;
      }
      .sheet-table thead .header-controls-row th {
        background: linear-gradient(180deg, #e6f0ff 0%, #d9e7ff 100%);
        border-bottom: none;
        top: 0;
      }
      .sheet-table thead .header-mode-row th {
        border-top: none;
        border-bottom: none;
        top: 52px;
        background: linear-gradient(180deg, #d9e7ff 0%, #ccdeff 100%);
      }
      .sheet-table thead .header-label-row th {
        border-top: none;
        top: 84px;
        cursor: pointer;
      }
      .sheet-table thead .header-label-row th:hover {
        background: linear-gradient(180deg, #ccdeff 0%, #b3d4ff 100%);
      }
      .header-control-cell {
        background: linear-gradient(180deg, #e6f0ff 0%, #d9e7ff 100%);
        padding: 6px;
      }
      .header-control-empty {
        background: linear-gradient(180deg, #e6f0ff 0%, #d9e7ff 100%);
        padding: 6px;
      }
      .sheet-table th.basis-active {
        background: linear-gradient(180deg, #dbeafe 0%, #bfdbfe 100%);
      }
      .sheet-table td.basis-active {
        background-color: #f0f7ff;
      }
      .sheet-table tfoot td {
        position: sticky;
        bottom: 0;
        z-index: 2;
        background: linear-gradient(180deg, #edf2ff 0%, #e2e8fa 100%);
        font-weight: 600;
      }
      .sheet-table tfoot td:first-child {
        left: 0;
      }
      .row-index {
        text-align: center;
        font-variant-numeric: tabular-nums;
      }
      .sheet-table td.store-cell {
        display: flex;
        align-items: center;
        gap: 6px;
      }
      .sheet-table td.store-cell .store-name {
        flex: 1;
        white-space: nowrap;
      }
      .sheet-table td.metric-cell {
        white-space: nowrap;
      }
      @media (max-width: 1200px) {
        .sheet-table {
          font-size: 0.75rem;
        }
      }
      @media (max-width: 600px) {
        .sheet-table {
          font-size: 0.7rem;
        }
      }
      .sheet-input {
        width: 100%;
        border: none;
        background: transparent;
        font: inherit;
        text-align: right;
        color: inherit;
        padding: 0;
      }
      .sheet-input:focus {
        outline: none;
      }
      .sheet-input:disabled {
        opacity: 0.8;
        cursor: not-allowed;
      }
      .sheet-input::-webkit-outer-spin-button,
      .sheet-input::-webkit-inner-spin-button {
        -webkit-appearance: none;
        margin: 0;
      }
      .sheet-input[type="number"] {
        -moz-appearance: textfield;
      }
      .sheet-status-ok {
        color: #0f766e;
      }
      .sheet-status-warn {
        color: #b45309;
      }
      .sheet-status-over {
        color: #b91c1c;
      }
      @media print {
        body * {
          visibility: hidden;
        }
        .sheet-container, .sheet-container * {
          visibility: visible;
        }
        .sheet-container {
          position: absolute;
          left: 0;
          top: 0;
          max-height: none;
          overflow: visible;
        }
      }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <script type="text/babel">
      const {
        AppBar,
        Toolbar,
        Typography,
        CssBaseline,
        ThemeProvider,
        createTheme,
        Container,
        Paper,
        Box,
        Stack,
        TextField,
        Button,
        Chip,
        LinearProgress,
        Tooltip,
        IconButton,
        Grid,
        useMediaQuery,
        Checkbox,
        FormControl,
        FormLabel,
        FormGroup,
        FormControlLabel,
        Divider,
        Alert,
      } = MaterialUI;

      const DISTRIBUTION_BASES = [
        { id: "even", label: "均等" },
        { id: "sales", label: "売上" },
        { id: "area", label: "面積" },
        { id: "custom", label: "任意" },
        { id: "csv", label: "係数パターンCSV" },
      ];

      const BASIS_LABEL_LOOKUP = DISTRIBUTION_BASES.reduce((acc, base) => {
        acc[base.id] = base.label;
        return acc;
      }, {});

      const PATTERN_LABELS = {
        sales: "売上",
        area: "面積",
        customCoefficient: "任意係数",
        csvCoefficient: "CSV係数",
      };

      const theme = createTheme({
        palette: {
          primary: { main: "#1e3a8a" },
          secondary: { main: "#0284c7" },
          background: { default: "transparent", paper: "rgba(255,255,255,0.9)" },
        },
        shape: { borderRadius: 14 },
        typography: {
          button: { textTransform: "none", fontWeight: 600 },
        },
        components: {
          MuiButton: { defaultProps: { size: "small" } },
          MuiTextField: { defaultProps: { size: "small" } },
          MuiChip: { defaultProps: { size: "small" } },
          MuiIconButton: { defaultProps: { size: "small" } },
          MuiToolbar: { defaultProps: { variant: "dense" } },
          MuiCheckbox: { defaultProps: { size: "small" } },
        },
      });

      const pseudoRandom = (seed) => {
        const x = Math.sin(seed * 12.9898) * 43758.5453;
        return x - Math.floor(x);
      };

      const generateMetric = (seed, min, max) =>
        Math.round(min + pseudoRandom(seed) * (max - min));

      const DEFAULT_STORE_COUNT = 150;

      const buildStore = (idx) => {
        const no = String(idx + 1).padStart(3, "0");
        const seed = idx + 1;
        return {
          id: idx,
          name: `店舗 ${no}`,
          allocation: 0,
          include: true,
          sales: generateMetric(seed, 450, 2400),
          salesAdjust: 0,
          area: generateMetric(seed + 0.45, 60, 320),
          areaAdjust: 0,
          customCoefficient: 1,
          customAdjust: 0,
          csvCoefficient: null,
          csvAdjust: 0,
          fixedAllocation: null,
        };
      };

      const buildStores = (count) =>
        Array.from({ length: count }, (_, idx) => buildStore(idx));

      const splitCsvLine = (line) => {
        const cells = [];
        let current = "";
        let inQuotes = false;
        for (let i = 0; i < line.length; i += 1) {
          const char = line[i];
          if (char === '"') {
            if (inQuotes && line[i + 1] === '"') {
              current += '"';
              i += 1;
            } else {
              inQuotes = !inQuotes;
            }
          } else if (char === "," && !inQuotes) {
            cells.push(current.trim());
            current = "";
          } else {
            current += char;
          }
        }
        cells.push(current.trim());
        return cells.map((cell) => cell.replace(/^"|"$/g, ""));
      };

      const parseNumeric = (value) => {
        if (value === undefined || value === null) return null;
        const trimmed = String(value).trim();
        if (!trimmed) return null;
        const cleaned = trimmed.replace(/[^\d.+-]/g, "");
        if (!cleaned || cleaned === "-" || cleaned === "+" || cleaned === ".") {
          return null;
        }
        const num = Number(cleaned);
        return Number.isFinite(num) ? num : null;
      };

      const parseBoolean = (value) => {
        if (value === undefined || value === null) return null;
        const normalized = String(value).trim().toLowerCase();
        if (!normalized) return null;
        if (
          ["1", "true", "t", "yes", "y", "on", "有", "対象"].includes(normalized)
        ) {
          return true;
        }
        if (
          ["0", "false", "f", "no", "n", "off", "無", "除外"].includes(normalized)
        ) {
          return false;
        }
        return null;
      };

      const parseMasterCsv = (text, stores) => {
        const rawLines = text.replace(/\r\n?/g, "\n").split("\n");
        if (!rawLines.length) {
          return {
            status: "error",
            message: "CSVにデータが含まれていません。",
            records: [],
            matched: 0,
            highestId: -1,
          };
        }
        let headerCells = null;
        const dataLines = [];
        rawLines.forEach((line) => {
          if (!headerCells) {
            if (line.trim()) {
              headerCells = splitCsvLine(line);
            }
          } else if (line.trim()) {
            dataLines.push(line);
          }
        });
        if (!headerCells) {
          return {
            status: "error",
            message: "ヘッダー行が見つかりませんでした。",
            records: [],
            matched: 0,
            highestId: -1,
          };
        }
        const headerKeys = headerCells.map((cell) => normalizeKey(cell));
        const findIndex = (aliases) =>
          headerKeys.findIndex((key) => aliases.includes(key));
        const indexMap = {
          no: findIndex([
            "no",
            "店舗番号",
            "番号",
            "id",
            "index",
            "storeid",
            "store_no",
          ]),
          name: findIndex(["店舗名", "店名", "name", "storename"]),
          sales: findIndex(["売上", "sales"]),
          area: findIndex(["面積", "area"]),
          customCoefficient: findIndex([
            "任意係数",
            "custom",
            "customcoefficient",
            "custom_coeff",
            "任意",
          ]),
          csvCoefficient: findIndex([
            "csv係数",
            "csv",
            "pattern",
            "csvcoefficient",
          ]),
          include: findIndex(["対象", "含める", "include", "active"]),
          allocation: findIndex(["配分", "配分値", "allocation"]),
        };
        if (indexMap.no === -1 && indexMap.name === -1) {
          return {
            status: "error",
            message: "店舗番号または店舗名の列が必要です。",
            records: [],
            matched: 0,
            highestId: -1,
          };
        }
        const nameMap = new Map(
          stores.map((store) => [normalizeKey(store.name), store])
        );
        const recordMap = new Map();
        dataLines.forEach((line) => {
          const cells = splitCsvLine(line);
          let targetIndex = null;
          let targetStore = null;
          if (indexMap.no !== -1) {
            const rawNo = cells[indexMap.no] ?? "";
            const digits = rawNo.replace(/[^\d-]/g, "");
            const parsed = Number.parseInt(digits, 10);
            if (Number.isFinite(parsed) && parsed >= 1) {
              targetIndex = parsed - 1;
              if (targetIndex < stores.length) {
                targetStore = stores[targetIndex];
              }
            }
          }
          if (!targetStore && indexMap.name !== -1) {
            const rawName = cells[indexMap.name] ?? "";
            const normalizedName = normalizeKey(rawName);
            if (nameMap.has(normalizedName)) {
              targetStore = nameMap.get(normalizedName);
              targetIndex = targetStore.id;
            }
          }
          if (targetIndex === null || targetIndex < 0) return;
          if (!targetStore && targetIndex < stores.length) {
            targetStore = stores[targetIndex];
          }
          const patch = {};
          let touched = false;
          if (indexMap.name !== -1) {
            const rawName = cells[indexMap.name] ?? "";
            if (rawName.trim()) {
              patch.name = rawName.trim();
              touched = true;
            }
          }
          if (indexMap.sales !== -1) {
            const value = parseNumeric(cells[indexMap.sales]);
            if (value !== null) {
              patch.sales = Math.max(0, Math.round(value));
              touched = true;
            }
          }
          if (indexMap.area !== -1) {
            const value = parseNumeric(cells[indexMap.area]);
            if (value !== null) {
              patch.area = Math.max(0, Math.round(value));
              touched = true;
            }
          }
          if (indexMap.customCoefficient !== -1) {
            const value = parseNumeric(cells[indexMap.customCoefficient]);
            if (value !== null) {
              patch.customCoefficient =
                Math.max(0, Math.round(value * 1000)) / 1000;
              touched = true;
            }
          }
          if (indexMap.csvCoefficient !== -1) {
            const raw = cells[indexMap.csvCoefficient] ?? "";
            if (!raw.trim()) {
              patch.csvCoefficient = null;
              touched = true;
            } else {
              const value = parseNumeric(raw);
              if (value !== null) {
                patch.csvCoefficient = value;
                touched = true;
              }
            }
          }
          if (indexMap.include !== -1) {
            const boolValue = parseBoolean(cells[indexMap.include]);
            if (boolValue !== null) {
              patch.include = boolValue;
              if (boolValue === false) {
                patch.allocation = 0;
              }
              touched = true;
            }
          }
          if (indexMap.allocation !== -1) {
            const value = parseNumeric(cells[indexMap.allocation]);
            if (value !== null) {
              patch.allocation = Math.max(0, Math.round(value));
              touched = true;
            }
          }
          if (!touched) return;
          const existing = recordMap.get(targetIndex);
          recordMap.set(targetIndex, {
            patch: existing ? { ...existing.patch, ...patch } : patch,
            create: existing
              ? existing.create
              : targetStore == null || targetStore === undefined,
          });
        });
        const records = [];
        let highestId = -1;
        recordMap.forEach((entry, id) => {
          records.push({ id, patch: entry.patch, create: entry.create });
          highestId = Math.max(highestId, id);
        });
        const matched = records.length;
        return {
          status: matched ? "success" : "warning",
          message: matched
            ? `${matched}件の店舗データを更新しました。`
            : "一致する店舗が見つかりませんでした。",
          records,
          matched,
          highestId,
        };
      };

      const normalizeKey = (value) => value.replace(/\s+/g, "").toLowerCase();

      const allocateEvenMap = (stores, total) => {
        const len = stores.length;
        if (!len) return new Map();
        const base = Math.floor(total / len);
        let remainder = total - base * len;
        const map = new Map();
        stores.forEach((store) => {
          const extra = remainder > 0 ? 1 : 0;
          if (remainder > 0) remainder -= 1;
          map.set(store.id, base + extra);
        });
        return map;
      };

      const computeWeightedDistribution = (
        stores,
        includedIds,
        total,
        weightSelector
      ) => {
        const included = stores.filter((store) => includedIds.has(store.id));
        if (!included.length) {
          return { nextStores: stores, weightSum: 0 };
        }
        const weights = included.map((store) => {
          const weight = Number(weightSelector(store));
          return {
            store,
            weight: Number.isFinite(weight) && weight > 0 ? weight : 0,
          };
        });
        const weightSum = weights.reduce((sum, item) => sum + item.weight, 0);
        const allocationMap =
          weightSum === 0
            ? allocateEvenMap(included, total)
            : (() => {
                const raw = weights.map((item) => ({
                  id: item.store.id,
                  ideal: (item.weight / weightSum) * total,
                }));
                const map = new Map();
                let remainder = total;
                raw.forEach((item) => {
                  const floored = Math.floor(item.ideal);
                  map.set(item.id, floored);
                  remainder -= floored;
                });
                const sorted = raw
                  .map((item) => ({
                    id: item.id,
                    fraction: item.ideal - Math.floor(item.ideal),
                  }))
                  .sort((a, b) => b.fraction - a.fraction);
                sorted.forEach((item) => {
                  if (remainder <= 0) return;
                  map.set(item.id, (map.get(item.id) || 0) + 1);
                  remainder -= 1;
                });
                return map;
              })();
        const nextStores = stores.map((store) => {
          if (!includedIds.has(store.id)) {
            return { ...store, allocation: 0 };
          }
          return { ...store, allocation: allocationMap.get(store.id) ?? 0 };
        });
        return { nextStores, weightSum };
      };

      const parseCoefficientCsv = (text, stores) => {
        const lines = text.replace(/\r\n?/g, "\n").split("\n");
        const nameMap = new Map(
          stores.map((store) => [normalizeKey(store.name), store])
        );
        const matchMap = new Map();
        lines.forEach((line) => {
          if (!line.trim()) return;
          const cells = line.split(/[,;\t]/).map((cell) => cell.trim());
          if (cells.length < 2) return;
          const key = cells[0];
          const numeric = Number(cells[1].replace(/[^0-9.+-]/g, ""));
          if (!Number.isFinite(numeric)) return;
          const digits = key.replace(/[^\d]/g, "");
          if (digits) {
            const index = Number.parseInt(digits, 10);
            if (Number.isFinite(index) && index >= 1 && index <= stores.length) {
              const store = stores[index - 1];
              matchMap.set(store.id, numeric);
              return;
            }
          }
          const normalized = normalizeKey(key);
          if (nameMap.has(normalized)) {
            matchMap.set(nameMap.get(normalized).id, numeric);
          }
        });
        return matchMap;
      };
      function useAllocations(
        initialTotal = 10000,
        initialStores = DEFAULT_STORE_COUNT
      ) {
        const initialStoreCount = Math.max(
          1,
          Number(initialStores) || DEFAULT_STORE_COUNT
        );
        const [total, setTotal] = React.useState(initialTotal);
        const [storeCount, setStoreCount] = React.useState(initialStoreCount);
        const [stores, setStores] = React.useState(() =>
          buildStores(initialStoreCount)
        );
        const [basis, setBasis] = React.useState("even");
        const [masterInfo, setMasterInfo] = React.useState(null);
        const [patternInfos, setPatternInfos] = React.useState({});
        const [allSelected, setAllSelected] = React.useState(true);
        const [selectedRow, setSelectedRow] = React.useState(null);
        const [sortConfig, setSortConfig] = React.useState({ key: null, direction: "asc" });
        const [activeTab, setActiveTab] = React.useState(0);
        const [history, setHistory] = React.useState([]);
        const [historyIndex, setHistoryIndex] = React.useState(-1);
        const [topSelectCount, setTopSelectCount] = React.useState(0);
        const [bottomSelectCount, setBottomSelectCount] = React.useState(0);

        const storesRef = React.useRef(stores);
        React.useEffect(() => {
          storesRef.current = stores;
        }, [stores]);

        React.useEffect(() => {
          setStores((prev) => {
            if (prev.length === storeCount) return prev;
            const next = [...prev];
            if (storeCount > prev.length) {
              for (let i = prev.length; i < storeCount; i += 1) {
                next.push(buildStore(i));
              }
            } else {
              next.length = storeCount;
            }
            return next.map((store, idx) => ({ ...store, id: idx }));
          });
        }, [storeCount]);

        const currentSum = React.useMemo(
          () => stores.reduce((sum, store) => sum + store.allocation, 0),
          [stores]
        );
        const difference = React.useMemo(
          () => Math.round(total) - currentSum,
          [total, currentSum]
        );
        const includedCount = React.useMemo(
          () => stores.filter((store) => store.include).length,
          [stores]
        );

        const handleStoreCountChange = React.useCallback((event) => {
          const digits = event.target.value.replace(/[^\d]/g, "");
          if (!digits) {
            setStoreCount(1);
            return;
          }
          const next = Math.max(1, Math.min(9999, Number(digits)));
          setStoreCount(next);
        }, []);

        const handleTotalChange = React.useCallback((event) => {
          const digits = event.target.value.replace(/[^\d]/g, "");
          const next = Number(digits);
          setTotal(Number.isFinite(next) ? next : 0);
        }, []);

        const handleAllocationChange = React.useCallback((index, event) => {
          const raw = Number(event.target.value);
          const next = Number.isFinite(raw) ? Math.max(0, Math.round(raw)) : 0;
          setStores((prev) => {
            const newStores = prev.map((store, idx) =>
              idx === index ? { ...store, allocation: next, fixedAllocation: next } : store
            );
            saveHistory(newStores);
            return newStores;
          });
        }, [saveHistory]);

        const toggleStoreInclude = React.useCallback((index) => {
          setStores((prev) =>
            prev.map((store, idx) =>
              idx === index
                ? {
                    ...store,
                    include: !store.include,
                    allocation: store.include ? 0 : store.allocation,
                  }
                : store
            )
          );
        }, []);

        const handleMetricChange = React.useCallback((index, key, event) => {
          const raw = Number(event.target.value);
          let value = Number.isFinite(raw) ? raw : 0;
          if (key === "customCoefficient") {
            value = Math.max(0, Math.round(value * 1000) / 1000);
          } else if (key.includes("Adjust")) {
            value = Math.round(value);
          } else {
            value = Math.max(0, Math.round(value));
          }
          setStores((prev) =>
            prev.map((store, idx) =>
              idx === index ? { ...store, [key]: value } : store
            )
          );
        }, []);

        const handleMasterCsvUpload = React.useCallback((file) => {
          if (!file) return;
          const reader = new FileReader();
          reader.onload = (event) => {
            const text = event.target.result;
            if (typeof text !== "string") return;
            const latestStores = storesRef.current;
            const result = parseMasterCsv(text, latestStores);
            if (result.records.length) {
              setStores((prev) => {
                const next = [...prev];
                result.records.forEach(({ id, patch }) => {
                  while (next.length <= id) {
                    next.push(buildStore(next.length));
                  }
                  const base = next[id] ?? buildStore(id);
                  const updated = { ...base, ...patch, id };
                  if (patch.include === false) {
                    updated.allocation = 0;
                  }
                  next[id] = updated;
                });
                return next.map((store, idx) => ({ ...store, id: idx }));
              });
              if (result.highestId >= 0) {
                setStoreCount((prev) =>
                  Math.max(prev, result.highestId + 1)
                );
              }
            }
            const totalCount = result.highestId >= 0
              ? Math.max(storesRef.current.length, result.highestId + 1)
              : storesRef.current.length;
            setMasterInfo({
              fileName: file.name,
              matchedCount: result.matched,
              totalCount,
              status: result.status,
              message: result.message,
            });
          };
          reader.onerror = () => {
            setMasterInfo({
              fileName: file.name,
              matchedCount: 0,
              totalCount: storesRef.current.length,
              status: "error",
              message: "CSVの読み込みに失敗しました。",
            });
          };
          reader.readAsText(file, "utf-8");
        }, []);

        const clearMasterData = React.useCallback(() => {
          setStores((prev) =>
            prev.map((_, idx) => ({
              ...buildStore(idx),
              id: idx,
            }))
          );
          setMasterInfo(null);
        }, []);

        const dismissMasterInfo = React.useCallback(() => {
          setMasterInfo(null);
        }, []);

        const handlePatternUpload = React.useCallback((key, file) => {
          if (!file) return;
          const reader = new FileReader();
          reader.onload = (event) => {
            const text = event.target.result;
            if (typeof text !== "string") return;
            const latestStores = storesRef.current;
            const matches = parseCoefficientCsv(text, latestStores);
            const matchedCount = matches.size;
            if (matchedCount) {
              setStores((prev) =>
                prev.map((store) => {
                  if (!matches.has(store.id)) return store;
                  const rawValue = matches.get(store.id);
                  let value = rawValue;
                  if (key === "sales" || key === "area") {
                    value = Math.max(0, Math.round(rawValue));
                  } else if (key === "customCoefficient") {
                    value = Math.max(0, Math.round(rawValue * 1000)) / 1000;
                  }
                  return { ...store, [key]: value };
                })
              );
            }
            const label = PATTERN_LABELS[key] || key;
            setPatternInfos((prev) => ({
              ...prev,
              [key]: {
                fileName: file.name,
                matchedCount,
                totalCount: latestStores.length,
                status: matchedCount ? "success" : "warning",
                message: matchedCount
                  ? `${matchedCount}件の${label}を更新しました。`
                  : "一致する店舗が見つかりませんでした。",
              },
            }));
          };
          reader.onerror = () => {
            const latestStores = storesRef.current;
            const label = PATTERN_LABELS[key] || key;
            setPatternInfos((prev) => ({
              ...prev,
              [key]: {
                fileName: file.name,
                matchedCount: 0,
                totalCount: latestStores.length,
                status: "error",
                message: `${label}のCSVの読み込みに失敗しました。`,
              },
            }));
          };
          reader.readAsText(file, "utf-8");
        }, []);

        const dismissPatternInfo = React.useCallback((key) => {
          setPatternInfos((prev) => ({
            ...prev,
            [key]: null,
          }));
        }, []);

        const applyWeighted = React.useCallback(
          ({ getWeight, basisId }) => {
            const targetTotal = Math.max(0, Math.round(total));
            let meta = null;
            setStores((prev) => {
              const included = prev.filter((store) => store.include);
              if (!included.length) {
                if (basisId === "csv") {
                  meta = {
                    status: "error",
                    message: "配分対象の店舗が選択されていません。",
                  };
                }
                return prev;
              }
              const fixedStores = included.filter((s) => s.fixedAllocation !== null);
              const flexStores = included.filter((s) => s.fixedAllocation === null);
              const fixedSum = fixedStores.reduce((sum, s) => sum + (s.fixedAllocation || 0), 0);
              const remainingTotal = Math.max(0, targetTotal - fixedSum);
              
              const includedIds = new Set(flexStores.map((store) => store.id));
              const hasWeight = flexStores.some((store) => {
                const weight = Number(getWeight(store));
                return Number.isFinite(weight) && weight > 0;
              });
              
              const { nextStores: flexAllocated } = computeWeightedDistribution(
                flexStores,
                includedIds,
                remainingTotal,
                (store) => {
                  const baseWeight = getWeight(store);
                  const adjustKey = basisId === "sales" ? "salesAdjust" :
                                    basisId === "area" ? "areaAdjust" :
                                    basisId === "custom" ? "customAdjust" :
                                    basisId === "csv" ? "csvAdjust" : null;
                  const adjustFactor = adjustKey ? 1 + (store[adjustKey] || 0) / 100 : 1;
                  return baseWeight * adjustFactor;
                }
              );
              
              const allocationMap = new Map();
              fixedStores.forEach((s) => allocationMap.set(s.id, s.fixedAllocation));
              flexAllocated.forEach((s) => allocationMap.set(s.id, s.allocation));
              
              const nextStores = prev.map((store) => {
                if (!store.include) return { ...store, allocation: 0 };
                return { ...store, allocation: allocationMap.get(store.id) ?? 0 };
              });
              
              if (basisId === "csv") {
                if (!hasWeight && flexStores.length > 0) {
                  meta = {
                    status: "error",
                    message: "CSV係数が設定されていない店舗が含まれています。",
                  };
                } else {
                  meta = {
                    status: "success",
                    message: `${included.length}店舗に係数配分を適用しました。`,
                  };
                }
              }
              return nextStores;
            });
            if (basisId === "csv" && meta) {
              setPatternInfos((prev) => ({
                ...prev,
                csvCoefficient: {
                  ...(prev.csvCoefficient || {}),
                  status: meta.status,
                  message: meta.message,
                  totalCount: storesRef.current.length,
                  fileName: prev.csvCoefficient?.fileName || "CSV係数",
                },
              }));
            }
          },
          [total]
        );

        const distribute = React.useCallback(
          (override) => {
            const active = override || basis;
            const getWeight =
              active === "sales"
                ? (store) => store.sales
                : active === "area"
                ? (store) => store.area
                : active === "custom"
                ? (store) => store.customCoefficient
                : active === "csv"
                ? (store) =>
                    Number.isFinite(Number(store.csvCoefficient))
                      ? Number(store.csvCoefficient)
                      : 0
                : () => 1;
            applyWeighted({ getWeight, basisId: active });
          },
          [basis, applyWeighted]
        );

        const applyDifference = React.useCallback((mode = "all") => {
          setStores((prev) => {
            const target = Math.max(0, Math.round(total));
            const included = prev.filter((store) => store.include);
            if (!included.length) return prev;
            
            if (mode === "fixed") {
              const fixedStores = included.filter((s) => s.fixedAllocation !== null);
              const flexStores = included.filter((s) => s.fixedAllocation === null);
              const fixedSum = fixedStores.reduce((sum, s) => sum + (s.fixedAllocation || 0), 0);
              const remainingTotal = Math.max(0, target - fixedSum);
              
              if (!flexStores.length) return prev;
              
              const getWeight = basis === "sales" ? (store) => store.sales :
                                basis === "area" ? (store) => store.area :
                                basis === "custom" ? (store) => store.customCoefficient :
                                basis === "csv" ? (store) => Number.isFinite(Number(store.csvCoefficient)) ? Number(store.csvCoefficient) : 0 :
                                () => 1;
              
              const includedIds = new Set(flexStores.map((store) => store.id));
              const { nextStores: flexAllocated } = computeWeightedDistribution(
                flexStores,
                includedIds,
                remainingTotal,
                (store) => {
                  const baseWeight = getWeight(store);
                  const adjustKey = basis === "sales" ? "salesAdjust" :
                                    basis === "area" ? "areaAdjust" :
                                    basis === "custom" ? "customAdjust" :
                                    basis === "csv" ? "csvAdjust" : null;
                  const adjustFactor = adjustKey ? 1 + (store[adjustKey] || 0) / 100 : 1;
                  return baseWeight * adjustFactor;
                }
              );
              
              const flexMap = new Map();
              flexAllocated.forEach((s) => flexMap.set(s.id, s.allocation));
              
              return prev.map((store) => {
                if (!store.include) return store;
                if (store.fixedAllocation !== null) {
                  return { ...store, allocation: store.fixedAllocation };
                }
                return { ...store, allocation: flexMap.get(store.id) ?? 0 };
              });
            }
            
            const current = included.reduce(
              (sum, store) => sum + store.allocation,
              0
            );
            const diff = target - current;
            if (diff === 0) return prev;
            if (diff > 0) {
              const len = included.length;
              const base = Math.floor(diff / len);
              let remainder = diff - base * len;
              return prev.map((store) => {
                if (!store.include) {
                  return { ...store, allocation: store.allocation };
                }
                const extra = base + (remainder > 0 ? 1 : 0);
                if (remainder > 0) remainder -= 1;
                return { ...store, allocation: store.allocation + extra };
              });
            }
            const positive = included.reduce(
              (sum, store) => sum + store.allocation,
              0
            );
            if (positive === 0 || target === 0) {
              return prev.map((store) =>
                store.include ? { ...store, allocation: 0 } : store
              );
            }
            const factor = target / positive;
            const provisional = included.map((store) => {
              const scaled = store.allocation * factor;
              const floored = Math.floor(scaled);
              return {
                id: store.id,
                floored,
                fraction: scaled - floored,
              };
            });
            let remain =
              target -
              provisional.reduce((sum, item) => sum + item.floored, 0);
            const sorted = [...provisional].sort(
              (a, b) => b.fraction - a.fraction
            );
            const allocationMap = new Map(
              provisional.map((item) => [item.id, item.floored])
            );
            sorted.forEach((item) => {
              if (remain <= 0) return;
              allocationMap.set(item.id, allocationMap.get(item.id) + 1);
              remain -= 1;
            });
            return prev.map((store) => {
              if (!store.include) return store;
              return { ...store, allocation: allocationMap.get(store.id) ?? 0 };
            });
          });
        }, [total]);

        const composeCsv = React.useCallback((rows) => {
          return rows
            .map((cells) =>
              cells
                .map((cell) =>
                  `"${String(cell ?? "").replace(/"/g, '""')}"`
                )
                .join(",")
            )
            .join("\r\n");
        }, []);

        const triggerCsvDownload = React.useCallback(
          (filename, rows) => {
            const csvContent = composeCsv(rows);
            const blob = new Blob([csvContent], {
              type: "text/csv;charset=utf-8;",
            });
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.href = url;
            link.download = filename;
            link.click();
            setTimeout(() => URL.revokeObjectURL(url), 0);
          },
          [composeCsv]
        );

        const downloadMasterTemplate = React.useCallback(() => {
          const baseStores =
            storesRef.current.length > 0
              ? storesRef.current
              : buildStores(storeCount);
          const sampleCount = Math.min(
            10,
            baseStores.length || DEFAULT_STORE_COUNT
          );
          const rows = [
            ["No", "店舗名", "売上", "面積", "任意係数", "対象", "配分値"],
            ...Array.from({ length: sampleCount }, (_, idx) => {
              const store = baseStores[idx] ?? buildStore(idx);
              return [
                String(idx + 1),
                store.name,
                store.sales,
                store.area,
                store.customCoefficient,
                store.include ? 1 : 0,
                store.allocation,
              ];
            }),
          ];
          triggerCsvDownload("master_template.csv", rows);
        }, [storeCount, triggerCsvDownload]);

        const downloadPatternTemplate = React.useCallback(
          (key) => {
            const label = PATTERN_LABELS[key] || key;
            const baseStores =
              storesRef.current.length > 0
                ? storesRef.current
                : buildStores(storeCount);
            const sampleCount = Math.min(
              10,
              baseStores.length || DEFAULT_STORE_COUNT
            );
            const rows = [
              ["No", label],
              ...Array.from({ length: sampleCount }, (_, idx) => {
                const store = baseStores[idx] ?? buildStore(idx);
                const value = store[key] ?? "";
                return [String(idx + 1), value];
              }),
            ];
            triggerCsvDownload(`${key}_template.csv`, rows);
          },
          [storeCount, triggerCsvDownload]
        );

        const handleCsvUpload = React.useCallback(
          (file) => handlePatternUpload("csvCoefficient", file),
          [handlePatternUpload]
        );

        const handleBalanceImport = React.useCallback((file) => {
          if (!file) return;
          const reader = new FileReader();
          reader.onload = (event) => {
            const text = event.target.result;
            if (typeof text !== "string") return;
            const latestStores = storesRef.current;
            const result = parseMasterCsv(text, latestStores);
            if (result.records.length) {
              setStores((prev) => {
                const next = [...prev];
                result.records.forEach(({ id, patch }) => {
                  if (id < next.length && patch.allocation !== undefined) {
                    next[id] = { ...next[id], allocation: patch.allocation, fixedAllocation: null };
                  }
                });
                return next;
              });
            }
          };
          reader.readAsText(file, "utf-8");
        }, []);

        const downloadBalanceTemplate = React.useCallback(() => {
          const baseStores = storesRef.current.length > 0 ? storesRef.current : buildStores(storeCount);
          const sampleCount = Math.min(10, baseStores.length || DEFAULT_STORE_COUNT);
          const rows = [
            ["No", "店舗名", "配分値"],
            ...Array.from({ length: sampleCount }, (_, idx) => {
              const store = baseStores[idx] ?? buildStore(idx);
              return [String(idx + 1), store.name, store.allocation || 0];
            }),
          ];
          triggerCsvDownload("balance_template.csv", rows);
        }, [storeCount, triggerCsvDownload]);

        const saveHistory = React.useCallback((newStores) => {
          setHistory((prev) => {
            const newHistory = prev.slice(0, historyIndex + 1);
            newHistory.push(JSON.parse(JSON.stringify(newStores)));
            return newHistory.slice(-50);
          });
          setHistoryIndex((prev) => Math.min(prev + 1, 49));
        }, [historyIndex]);

        const undo = React.useCallback(() => {
          if (historyIndex > 0) {
            setHistoryIndex((prev) => prev - 1);
            setStores(JSON.parse(JSON.stringify(history[historyIndex - 1])));
          }
        }, [history, historyIndex]);

        const redo = React.useCallback(() => {
          if (historyIndex < history.length - 1) {
            setHistoryIndex((prev) => prev + 1);
            setStores(JSON.parse(JSON.stringify(history[historyIndex + 1])));
          }
        }, [history, historyIndex]);

        const resetFixedAllocations = React.useCallback(() => {
          setStores((prev) => {
            const newStores = prev.map((store) => ({ ...store, fixedAllocation: null }));
            saveHistory(newStores);
            return newStores;
          });
        }, [saveHistory]);

        const resetAll = React.useCallback(() => {
          setStores((prev) => {
            const newStores = prev.map((store) => ({ ...store, allocation: 0, fixedAllocation: null }));
            saveHistory(newStores);
            return newStores;
          });
          setBasis("even");
        }, [saveHistory]);

        const selectTopStores = React.useCallback(() => {
          if (topSelectCount <= 0) return;
          const sorted = [...stores].sort((a, b) => b.allocation - a.allocation);
          const topIds = new Set(sorted.slice(0, topSelectCount).map(s => s.id));
          setStores((prev) => prev.map((store) => ({ ...store, include: topIds.has(store.id) })));
        }, [stores, topSelectCount]);

        const selectBottomStores = React.useCallback(() => {
          if (bottomSelectCount <= 0) return;
          const sorted = [...stores].sort((a, b) => a.allocation - b.allocation);
          const bottomIds = new Set(sorted.slice(0, bottomSelectCount).map(s => s.id));
          setStores((prev) => prev.map((store) => ({ ...store, include: bottomIds.has(store.id) })));
        }, [stores, bottomSelectCount]);

        const exportTableCsv = React.useCallback(() => {
          const rows = [
            ["No", "店舗名", "配分値", "累計", "売上", "売上調整%", "面積", "面積調整%", "任意係数", "任意調整%", "CSV係数", "CSV調整%", "対象"],
            ...stores.map((store, idx) => [
              idx + 1,
              store.name,
              store.allocation,
              stores.slice(0, idx + 1).reduce((sum, s) => sum + s.allocation, 0),
              store.sales,
              store.salesAdjust,
              store.area,
              store.areaAdjust,
              store.customCoefficient,
              store.customAdjust,
              store.csvCoefficient ?? "",
              store.csvAdjust,
              store.include ? "対象" : "除外",
            ]),
          ];
          triggerCsvDownload(`store_allocation_${new Date().toISOString().slice(0, 10)}.csv`, rows);
        }, [stores, triggerCsvDownload]);

        const printTable = React.useCallback(() => {
          window.print();
        }, []);

        const toggleAllStores = React.useCallback((checked) => {
          setAllSelected(checked);
          setStores((prev) =>
            prev.map((store) => ({
              ...store,
              include: checked,
              allocation: checked ? store.allocation : 0,
            }))
          );
        }, []);

        const exportCsv = React.useCallback(() => {
          const rows = [
            ["No", "店舗名", "配分値", "累計", "売上", "売上調整%", "面積", "面積調整%", "任意係数", "任意調整%", "CSV係数", "CSV調整%", "対象"],
            ...stores.map((store, idx) => [
              idx + 1,
              store.name,
              store.allocation,
              stores.slice(0, idx + 1).reduce((sum, s) => sum + s.allocation, 0),
              store.sales,
              store.salesAdjust,
              store.area,
              store.areaAdjust,
              store.customCoefficient,
              store.customAdjust,
              store.csvCoefficient ?? "",
              store.csvAdjust,
              store.include ? "対象" : "除外",
            ]),
          ];
          triggerCsvDownload(`allocation_result_${new Date().toISOString().slice(0, 10)}.csv`, rows);
        }, [stores, triggerCsvDownload]);

        return {
          total,
          storeCount,
          stores,
          currentSum,
          difference,
          includedCount,
          basis,
          masterInfo,
          patternInfos,
          setBasis,
          handleStoreCountChange,
          handleTotalChange,
          handleAllocationChange,
          toggleStoreInclude,
          handleMetricChange,
          handleMasterCsvUpload,
          distribute,
          applyDifference,
          resetAll,
          handlePatternUpload,
          handleCsvUpload,
          downloadMasterTemplate,
          downloadPatternTemplate,
          clearMasterData,
          dismissMasterInfo,
          dismissPatternInfo,
          toggleAllStores,
          allSelected,
          exportCsv,
          printTable,
          selectedRow,
          setSelectedRow,
          sortConfig,
          setSortConfig,
          activeTab,
          setActiveTab,
          undo,
          redo,
          resetFixedAllocations,
          canUndo: historyIndex > 0,
          canRedo: historyIndex < history.length - 1,
          topSelectCount,
          setTopSelectCount,
          bottomSelectCount,
          setBottomSelectCount,
          selectTopStores,
          selectBottomStores,
          exportTableCsv,
          printTable,
          fixedCount: stores.filter(s => s.fixedAllocation !== null).length,
        };
      }
      function SummaryPanel({
        total,
        storeCount,
        currentSum,
        difference,
        includedCount,
        onStoreCountChange,
        onTotalChange,
        basisLabel,
        bases,
        basis,
        onBasisChange,
        onDistribute,
        onApplyDiff,
        topSelectCount,
        setTopSelectCount,
        bottomSelectCount,
        setBottomSelectCount,
        selectTopStores,
        selectBottomStores,
        fixedCount,
        undo,
        redo,
        resetFixedAllocations,
        canUndo,
        canRedo,
      }) {
        const completion = total === 0 ? 0 : Math.min(100, Math.round((currentSum / total) * 100));
        const canDistribute = includedCount > 0 && total > 0;
        return (
          <Stack spacing={1}>
            <Grid container spacing={1} alignItems="center">
              <Grid item xs={6} sm={3}>
                <TextField label="店舗数" value={storeCount} onChange={onStoreCountChange} fullWidth type="number" inputProps={{ min: 1 }} size="small" />
              </Grid>
              <Grid item xs={6} sm={3}>
                <TextField label="目標総数" value={total.toLocaleString()} onChange={onTotalChange} fullWidth size="small" />
              </Grid>
              <Grid item xs={6} sm={3}>
                <TextField label="配分済み" value={currentSum.toLocaleString()} InputProps={{ readOnly: true }} fullWidth size="small" />
              </Grid>
              <Grid item xs={6} sm={3}>
                <TextField label="対象店舗" value={`${includedCount}店`} InputProps={{ readOnly: true }} fullWidth size="small" />
              </Grid>
            </Grid>
            <Stack direction="row" spacing={0.5} flexWrap="wrap">
              {bases.map((item) => (
                <Chip
                  key={item.id}
                  label={item.label}
                  onClick={() => { onBasisChange(item.id); onDistribute(item.id); }}
                  color={basis === item.id ? "primary" : "default"}
                  variant={basis === item.id ? "filled" : "outlined"}
                  size="small"
                />
              ))}
            </Stack>
            <Stack direction="row" spacing={0.5} alignItems="center" flexWrap="wrap" sx={{ gap: 0.5 }}>
              <Button variant="outlined" onClick={selectTopStores} size="small">上位</Button>
              <TextField type="number" value={topSelectCount} onChange={(e) => setTopSelectCount(Math.max(0, Number(e.target.value)))} sx={{ width: { xs: 60, sm: 70 } }} size="small" inputProps={{ min: 0 }} />
              <Button variant="outlined" onClick={selectBottomStores} size="small">下位</Button>
              <TextField type="number" value={bottomSelectCount} onChange={(e) => setBottomSelectCount(Math.max(0, Number(e.target.value)))} sx={{ width: { xs: 60, sm: 70 } }} size="small" inputProps={{ min: 0 }} />
              <Typography variant="caption" sx={{ display: { xs: "none", sm: "inline" } }}>店舗を選択</Typography>
            </Stack>
            <Stack direction="row" spacing={0.5} alignItems="center">
              <LinearProgress variant="determinate" value={completion} sx={{ flexGrow: 1, height: 6, borderRadius: 999 }} />
              <Typography variant="caption" sx={{ minWidth: 40 }}>{completion}%</Typography>
            </Stack>
            <Stack direction="row" spacing={0.5} flexWrap="wrap" sx={{ gap: 0.5 }}>
              <Button variant="contained" onClick={() => onDistribute()} disabled={!canDistribute} size="small">配分実行</Button>
              <Button variant="outlined" onClick={() => onApplyDiff("all")} disabled={includedCount === 0} size="small">差分調整</Button>
              <Button variant="outlined" onClick={() => onApplyDiff("fixed")} disabled={includedCount === 0 || fixedCount === 0} size="small">手入力固定調整</Button>
              <Divider orientation="vertical" flexItem />
              <Tooltip title="元に戻す">
                <span>
                  <IconButton onClick={undo} disabled={!canUndo} size="small">
                    <span className="material-icons" style={{ fontSize: 18 }}>undo</span>
                  </IconButton>
                </span>
              </Tooltip>
              <Tooltip title="やり直す">
                <span>
                  <IconButton onClick={redo} disabled={!canRedo} size="small">
                    <span className="material-icons" style={{ fontSize: 18 }}>redo</span>
                  </IconButton>
                </span>
              </Tooltip>
              <Tooltip title="手入力値をリセット">
                <IconButton onClick={resetFixedAllocations} size="small">
                  <span className="material-icons" style={{ fontSize: 18 }}>clear</span>
                </IconButton>
              </Tooltip>
              <Divider orientation="vertical" flexItem />
              <Chip label={`差分: ${difference.toLocaleString()}`} color={difference === 0 ? "success" : difference > 0 ? "warning" : "error"} size="small" />
              {fixedCount > 0 && <Chip label={`手入力: ${fixedCount}店`} color="warning" size="small" />}
            </Stack>
          </Stack>
        );
      }

      function AllocationChart({ stores, basis, selectedRow, onImportBalance, onDownloadBalanceTemplate, onSelectRow }) {
        const chartRef = React.useRef(null);
        const balanceFileInputRef = React.useRef(null);
        const tooltipRef = React.useRef(null);
        const [sortOrder, setSortOrder] = React.useState("desc");
        const [rangeType, setRangeType] = React.useState("all");
        const [topCount, setTopCount] = React.useState(Math.ceil(stores.length * 0.2));
        const [bottomCount, setBottomCount] = React.useState(Math.ceil(stores.length * 0.2));
        const [collapsed, setCollapsed] = React.useState(false);
        
        React.useEffect(() => {
          const defaultCount = Math.ceil(stores.length * 0.2);
          setTopCount(defaultCount);
          setBottomCount(defaultCount);
        }, [stores.length]);
        
        const drawChart = React.useCallback(() => {
          if (!chartRef.current || !stores.length || collapsed) return;
          
          const container = chartRef.current;
          const width = Math.max(container.clientWidth, 300);
          const height = 300;
          const margin = { top: 20, right: 60, bottom: 60, left: 60 };
          
          d3.select(container).selectAll("*").remove();
          
          const svg = d3.select(container)
            .append("svg")
            .attr("width", width)
            .attr("height", height);
          
          const included = stores.filter(s => s.include);
          let data = included.map((s, i) => ({
            id: s.id,
            name: s.name,
            allocation: s.allocation,
            coefficient: basis === "sales" ? s.sales :
                        basis === "area" ? s.area :
                        basis === "custom" ? s.customCoefficient :
                        basis === "csv" ? (s.csvCoefficient || 0) : 1
          }));
          
          if (sortOrder === "desc") data.sort((a, b) => b.allocation - a.allocation);
          else if (sortOrder === "asc") data.sort((a, b) => a.allocation - b.allocation);
          
          if (rangeType === "top") data = data.slice(0, topCount);
          else if (rangeType === "bottom") data = data.slice(-bottomCount);
          
          const x = d3.scaleBand()
            .domain(data.map(d => d.name))
            .range([margin.left, width - margin.right])
            .padding(0.2);
          
          const y1 = d3.scaleLinear()
            .domain([0, d3.max(data, d => d.allocation) || 100])
            .nice()
            .range([height - margin.bottom, margin.top]);
          
          const y2 = d3.scaleLinear()
            .domain([0, d3.max(data, d => d.coefficient) || 100])
            .nice()
            .range([height - margin.bottom, margin.top]);
          
          svg.append("g")
            .attr("transform", `translate(0,${height - margin.bottom})`)
            .call(d3.axisBottom(x))
            .selectAll("text")
            .attr("transform", "rotate(-45)")
            .style("text-anchor", "end")
            .style("font-size", "9px");
          
          svg.append("g")
            .attr("transform", `translate(${margin.left},0)`)
            .call(d3.axisLeft(y1))
            .append("text")
            .attr("fill", "#000")
            .attr("transform", "rotate(-90)")
            .attr("y", -40)
            .attr("x", -height/2)
            .attr("text-anchor", "middle")
            .text("配分値");
          
          svg.append("g")
            .attr("transform", `translate(${width - margin.right},0)`)
            .call(d3.axisRight(y2))
            .append("text")
            .attr("fill", "#000")
            .attr("transform", "rotate(-90)")
            .attr("y", 40)
            .attr("x", -height/2)
            .attr("text-anchor", "middle")
            .text("係数");
          
          const tooltip = d3.select("body").selectAll(".chart-tooltip").data([null])
            .join("div")
            .attr("class", "chart-tooltip")
            .style("position", "absolute")
            .style("background", "rgba(0,0,0,0.8)")
            .style("color", "#fff")
            .style("padding", "8px")
            .style("border-radius", "4px")
            .style("font-size", "12px")
            .style("pointer-events", "none")
            .style("opacity", 0)
            .style("z-index", 9999);

          svg.selectAll(".bar")
            .data(data)
            .join("rect")
            .attr("class", "bar")
            .attr("x", d => x(d.name))
            .attr("y", d => y1(d.allocation))
            .attr("width", x.bandwidth())
            .attr("height", d => y1(0) - y1(d.allocation))
            .attr("fill", d => d.id === selectedRow ? "#ef4444" : "#1e3a8a")
            .attr("opacity", 0.7)
            .style("cursor", "pointer")
            .on("mouseover", function(event, d) {
              tooltip.transition().duration(200).style("opacity", 1);
              tooltip.html(`<strong>${d.name}</strong><br/>配分値: ${d.allocation.toLocaleString()}<br/>係数: ${typeof d.coefficient === 'number' ? d.coefficient.toLocaleString() : d.coefficient}`);
            })
            .on("mousemove", function(event) {
              tooltip.style("left", (event.pageX + 10) + "px").style("top", (event.pageY - 28) + "px");
            })
            .on("mouseout", function() {
              tooltip.transition().duration(200).style("opacity", 0);
            })
            .on("click", function(event, d) {
              onSelectRow(d.id);
            });
          
          svg.selectAll(".line")
            .data(data)
            .join("circle")
            .attr("cx", d => x(d.name) + x.bandwidth() / 2)
            .attr("cy", d => y2(d.coefficient))
            .attr("r", 3)
            .attr("fill", "#f59e0b");
          
        }, [stores, basis, sortOrder, rangeType, collapsed, selectedRow, topCount, bottomCount]);
        
        React.useEffect(() => {
          drawChart();
          const handleResize = () => setTimeout(drawChart, 100);
          window.addEventListener('resize', handleResize);
          return () => window.removeEventListener('resize', handleResize);
        }, [drawChart]);
        
        return (
          <Box>
            <Stack direction="row" spacing={{ xs: 0.25, sm: 0.5, md: 1 }} alignItems="center" flexWrap="wrap" sx={{ mb: { xs: 0.5, sm: 1 }, gap: { xs: 0.25, sm: 0.5 } }}>
              <IconButton size="small" onClick={() => setCollapsed(!collapsed)}>
                <span className="material-icons" style={{ fontSize: 20 }}>{collapsed ? "expand_more" : "expand_less"}</span>
              </IconButton>
              <Typography variant="subtitle2" fontWeight={600} sx={{ fontSize: { xs: "0.8rem", sm: "0.875rem" } }}>配分バランスグラフ</Typography>
              <Button size="small" variant={sortOrder === "desc" ? "contained" : "outlined"} onClick={() => setSortOrder("desc")} sx={{ fontSize: { xs: "0.7rem", sm: "0.75rem" } }}>多い順</Button>
              <Button size="small" variant={sortOrder === "asc" ? "contained" : "outlined"} onClick={() => setSortOrder("asc")} sx={{ fontSize: { xs: "0.7rem", sm: "0.75rem" } }}>少ない順</Button>
              <Button size="small" variant={sortOrder === "store" ? "contained" : "outlined"} onClick={() => setSortOrder("store")} sx={{ fontSize: { xs: "0.7rem", sm: "0.75rem" } }}>店舗順</Button>
              <Button size="small" variant={rangeType === "top" ? "contained" : "outlined"} onClick={() => setRangeType("top")} sx={{ fontSize: { xs: "0.7rem", sm: "0.75rem" } }}>上位</Button>
              <TextField size="small" type="number" value={topCount} onChange={(e) => setTopCount(Math.max(1, Number(e.target.value)))} sx={{ width: { xs: 50, sm: 70 } }} inputProps={{ min: 1, style: { fontSize: "0.75rem" } }} />
              <Button size="small" variant={rangeType === "bottom" ? "contained" : "outlined"} onClick={() => setRangeType("bottom")} sx={{ fontSize: { xs: "0.7rem", sm: "0.75rem" } }}>下位</Button>
              <TextField size="small" type="number" value={bottomCount} onChange={(e) => setBottomCount(Math.max(1, Number(e.target.value)))} sx={{ width: { xs: 50, sm: 70 } }} inputProps={{ min: 1, style: { fontSize: "0.75rem" } }} />
              <Button size="small" variant={rangeType === "all" ? "contained" : "outlined"} onClick={() => setRangeType("all")} sx={{ fontSize: { xs: "0.7rem", sm: "0.75rem" } }}>全店</Button>
              <Divider orientation="vertical" flexItem />
              <Button size="small" variant="outlined" startIcon={<span className="material-icons" style={{ fontSize: 16 }}>upload_file</span>} onClick={() => balanceFileInputRef.current?.click()} sx={{ fontSize: { xs: "0.7rem", sm: "0.75rem" } }}>配分データ読込</Button>
              <Button size="small" variant="text" onClick={onDownloadBalanceTemplate} sx={{ fontSize: { xs: "0.7rem", sm: "0.75rem" } }}>テンプレート</Button>
              <input type="file" accept=".csv" ref={balanceFileInputRef} style={{ display: "none" }} onChange={(event) => { const file = event.target.files?.[0]; if (file) onImportBalance(file); event.target.value = ""; }} />
            </Stack>
            {!collapsed && <Box ref={chartRef} sx={{ width: "100%", height: { xs: 250, sm: 300 } }} />}
          </Box>
        );
      }

      function SearchPanel({ stores, onSelectRow, onSwitchToTable }) {
        const [searchText, setSearchText] = React.useState("");
        const [searchResults, setSearchResults] = React.useState([]);

        const handleSearch = React.useCallback(() => {
          if (!searchText.trim()) {
            setSearchResults([]);
            return;
          }
          const query = searchText.toLowerCase();
          const results = stores.filter(store => 
            store.name.toLowerCase().includes(query) || 
            String(store.id + 1).includes(query)
          );
          setSearchResults(results);
        }, [searchText, stores]);

        const handleClear = React.useCallback(() => {
          setSearchText("");
          setSearchResults([]);
        }, []);

        const handleSelectStore = React.useCallback((storeId) => {
          onSelectRow(storeId);
          onSwitchToTable();
        }, [onSelectRow, onSwitchToTable]);

        return (
          <Stack spacing={1}>
            <Stack direction="row" spacing={0.5} alignItems="center">
              <TextField 
                label="店舗検索" 
                value={searchText} 
                onChange={(e) => setSearchText(e.target.value)}
                onKeyDown={(e) => e.key === "Enter" && handleSearch()}
                size="small"
                sx={{ flexGrow: 1 }}
                placeholder="店舗名またはNo."
              />
              <Button variant="contained" onClick={handleSearch} startIcon={<span className="material-icons" style={{ fontSize: 18 }}>search</span>}>検索</Button>
              <Button variant="outlined" onClick={handleClear} startIcon={<span className="material-icons" style={{ fontSize: 18 }}>clear</span>}>クリア</Button>
            </Stack>
            {searchResults.length > 0 && (
              <Box sx={{ maxHeight: 120, overflow: "auto", border: "1px solid #e0e0e0", borderRadius: 1, p: 0.5 }}>
                <Stack spacing={0.5}>
                  {searchResults.map(store => (
                    <Chip 
                      key={store.id}
                      label={`${String(store.id + 1).padStart(3, "0")} - ${store.name} (配分: ${store.allocation})`}
                      onClick={() => handleSelectStore(store.id)}
                      size="small"
                      sx={{ justifyContent: "flex-start", cursor: "pointer" }}
                    />
                  ))}
                </Stack>
              </Box>
            )}
          </Stack>
        );
      }

      function AllocationResult({ stores, basis, total }) {
        const resultRef = React.useRef(null);
        const includedStores = stores.filter(s => s.include);
        const basisName = BASIS_LABEL_LOOKUP[basis] || "未選択";
        
        const exportResult = () => {
          const rows = [
            ["配分モード", basisName],
            ["目標総数", total],
            ["配分対象店舗", `${includedStores.length}店`],
            ["配分済み合計", includedStores.reduce((sum, s) => sum + s.allocation, 0)],
            [],
            ["No.", "店舗名", "配分値", "係数"],
            ...includedStores.map((store, idx) => {
              const coeff = basis === "sales" ? store.sales :
                           basis === "area" ? store.area :
                           basis === "custom" ? store.customCoefficient :
                           basis === "csv" ? (store.csvCoefficient || 0) : 1;
              return [idx + 1, store.name, store.allocation, coeff];
            })
          ];
          const csv = rows.map(r => r.map(c => `"${c}"`).join(",")).join("\r\n");
          const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
          const url = URL.createObjectURL(blob);
          const link = document.createElement("a");
          link.href = url;
          link.download = `allocation_result_${new Date().toISOString().slice(0, 10)}.csv`;
          link.click();
          setTimeout(() => URL.revokeObjectURL(url), 0);
        };
        
        const printResult = () => {
          const printWindow = window.open("", "", "width=800,height=600");
          printWindow.document.write(`<html><head><title>配分結果</title><style>body{font-family:sans-serif;padding:20px;}table{width:100%;border-collapse:collapse;}th,td{border:1px solid #ddd;padding:8px;text-align:left;}</style></head><body>`);
          printWindow.document.write(resultRef.current.innerHTML);
          printWindow.document.write("</body></html>");
          printWindow.document.close();
          printWindow.print();
        };
        
        return (
          <Box>
            <Stack direction="row" spacing={{ xs: 0.5, sm: 1 }} alignItems="center" flexWrap="wrap" sx={{ mb: { xs: 0.5, sm: 1 }, gap: 0.5 }}>
              <Typography variant="subtitle2" fontWeight={600} sx={{ fontSize: { xs: "0.8rem", sm: "0.875rem" } }}>配分結果</Typography>
              <Button size="small" startIcon={<span className="material-icons" style={{ fontSize: 18 }}>download</span>} onClick={exportResult} sx={{ fontSize: { xs: "0.7rem", sm: "0.875rem" } }}>ダウンロード</Button>
              <Button size="small" startIcon={<span className="material-icons" style={{ fontSize: 18 }}>print</span>} onClick={printResult} sx={{ fontSize: { xs: "0.7rem", sm: "0.875rem" } }}>印刷</Button>
            </Stack>
            <Box ref={resultRef} sx={{ bgcolor: "#fff", borderRadius: 2, border: "1px solid #e0e0e0", p: { xs: 1, sm: 1.5 } }}>
                <Typography variant="h6" gutterBottom sx={{ fontSize: { xs: "1rem", sm: "1.25rem" } }}>配分結果サマリー</Typography>
                <Box sx={{ display: "flex", flexWrap: "wrap", gap: { xs: 1, sm: 2 }, mb: 2 }}>
                  <Box sx={{ flex: "1 1 45%" }}>
                    <Typography variant="body2" color="text.secondary" sx={{ fontSize: { xs: "0.75rem", sm: "0.875rem" } }}>配分モード</Typography>
                    <Typography variant="h6" sx={{ fontSize: { xs: "0.9rem", sm: "1.25rem" } }}>{basisName}</Typography>
                  </Box>
                  <Box sx={{ flex: "1 1 45%" }}>
                    <Typography variant="body2" color="text.secondary" sx={{ fontSize: { xs: "0.75rem", sm: "0.875rem" } }}>目標総数</Typography>
                    <Typography variant="h6" sx={{ fontSize: { xs: "0.9rem", sm: "1.25rem" } }}>{total.toLocaleString()}</Typography>
                  </Box>
                  <Box sx={{ flex: "1 1 45%" }}>
                    <Typography variant="body2" color="text.secondary" sx={{ fontSize: { xs: "0.75rem", sm: "0.875rem" } }}>配分対象店舗</Typography>
                    <Typography variant="h6" sx={{ fontSize: { xs: "0.9rem", sm: "1.25rem" } }}>{includedStores.length}店</Typography>
                  </Box>
                  <Box sx={{ flex: "1 1 45%" }}>
                    <Typography variant="body2" color="text.secondary" sx={{ fontSize: { xs: "0.75rem", sm: "0.875rem" } }}>配分済み合計</Typography>
                    <Typography variant="h6" sx={{ fontSize: { xs: "0.9rem", sm: "1.25rem" } }}>{includedStores.reduce((sum, s) => sum + s.allocation, 0).toLocaleString()}</Typography>
                  </Box>
                </Box>
                <Typography variant="subtitle2" gutterBottom sx={{ mt: 1.5, fontSize: { xs: "0.85rem", sm: "0.875rem" } }}>店舗別配分詳細</Typography>
                <Box sx={{ overflow: "auto", mt: 1 }}>
                  <table style={{ width: "100%", borderCollapse: "collapse", fontSize: "0.875rem" }}>
                    <thead>
                      <tr style={{ backgroundColor: "#f5f5f5" }}>
                        <th style={{ padding: "8px", textAlign: "left", borderBottom: "2px solid #ddd" }}>No.</th>
                        <th style={{ padding: "8px", textAlign: "left", borderBottom: "2px solid #ddd" }}>店舗名</th>
                        <th style={{ padding: "8px", textAlign: "right", borderBottom: "2px solid #ddd" }}>配分値</th>
                        <th style={{ padding: "8px", textAlign: "right", borderBottom: "2px solid #ddd" }}>係数</th>
                      </tr>
                    </thead>
                    <tbody>
                      {includedStores.map((store, idx) => {
                        const coeff = basis === "sales" ? store.sales :
                                     basis === "area" ? store.area :
                                     basis === "custom" ? store.customCoefficient :
                                     basis === "csv" ? (store.csvCoefficient || 0) : 1;
                        return (
                          <tr key={store.id} style={{ borderBottom: "1px solid #eee" }}>
                            <td style={{ padding: "8px" }}>{idx + 1}</td>
                            <td style={{ padding: "8px" }}>{store.name}</td>
                            <td style={{ padding: "8px", textAlign: "right" }}>{store.allocation.toLocaleString()}</td>
                            <td style={{ padding: "8px", textAlign: "right" }}>{typeof coeff === "number" ? coeff.toLocaleString() : coeff}</td>
                          </tr>
                        );
                      })}
                    </tbody>
                  </table>
                </Box>
              </Box>
          </Box>
        );
      }


      function AllocationTable({
        stores,
        onAllocationChange,
        onToggleInclude,
        onMetricChange,
        total,
        currentSum,
        difference,
        dense,
        basis,
        masterInfo,
        patternInfos,
        onMasterUpload,
        onPatternUpload,
        onDownloadMasterTemplate,
        onDownloadPatternTemplate,
        onDismissMasterInfo,
        onDismissPatternInfo,
        onResetMaster,
        onToggleAll,
        allSelected,
        onBasisChange,
        selectedRow,
        onSelectRow,
        sortConfig,
        onSort,
      }) {
        const sortedStores = React.useMemo(() => {
          if (!sortConfig.key) return stores;
          const sorted = [...stores];
          sorted.sort((a, b) => {
            const aVal = a[sortConfig.key];
            const bVal = b[sortConfig.key];
            if (aVal < bVal) return sortConfig.direction === "asc" ? -1 : 1;
            if (aVal > bVal) return sortConfig.direction === "asc" ? 1 : -1;
            return 0;
          });
          return sorted;
        }, [stores, sortConfig]);
        const tableRef = React.useRef(null);
        const masterFileInputRef = React.useRef(null);
        const salesFileInputRef = React.useRef(null);
        const areaFileInputRef = React.useRef(null);
        const customFileInputRef = React.useRef(null);
        const csvFileInputRef = React.useRef(null);
        const patternColumns = React.useMemo(
          () => [
            { key: "sales", label: PATTERN_LABELS.sales, ref: salesFileInputRef },
            { key: "area", label: PATTERN_LABELS.area, ref: areaFileInputRef },
            {
              key: "customCoefficient",
              label: PATTERN_LABELS.customCoefficient,
              ref: customFileInputRef,
            },
            {
              key: "csvCoefficient",
              label: PATTERN_LABELS.csvCoefficient,
              ref: csvFileInputRef,
            },
          ],
          []
        );
        const editableColumns = React.useMemo(
          () => ["allocation", "sales", "salesAdjust", "area", "areaAdjust", "customCoefficient", "customAdjust", "csvAdjust"],
          []
        );
        const tryFocus = React.useCallback(
          (rowIndex, columnKey) => {
            if (!tableRef.current) return false;
            if (rowIndex < 0 || rowIndex >= stores.length) return false;
            const selector = `input.sheet-input[data-row-index="${rowIndex}"][data-col-key="${columnKey}"]`;
            const next = tableRef.current.querySelector(selector);
            if (next && !next.disabled) {
              next.focus();
              if (typeof next.select === "function") next.select();
              return true;
            }
            return false;
          },
          [stores.length]
        );
        const handleCellKeyDown = React.useCallback(
          (event, rowIndex, columnKey) => {
            const { key } = event;
            if (key === "ArrowRight" || key === "ArrowLeft") {
              const step = key === "ArrowRight" ? 1 : -1;
              const currentIdx = editableColumns.indexOf(columnKey);
              if (currentIdx === -1) return;
              for (
                let nextIdx = currentIdx + step;
                nextIdx >= 0 && nextIdx < editableColumns.length;
                nextIdx += step
              ) {
                if (tryFocus(rowIndex, editableColumns[nextIdx])) {
                  event.preventDefault();
                  return;
                }
              }
            } else if (key === "ArrowDown" || key === "ArrowUp") {
              const step = key === "ArrowDown" ? 1 : -1;
              for (
                let nextRow = rowIndex + step;
                nextRow >= 0 && nextRow < stores.length;
                nextRow += step
              ) {
                if (tryFocus(nextRow, columnKey)) {
                  event.preventDefault();
                  onSelectRow(stores[nextRow].id);
                  return;
                }
              }
            } else if (key === "Enter") {
              for (
                let nextRow = rowIndex + 1;
                nextRow < stores.length;
                nextRow += 1
              ) {
                if (tryFocus(nextRow, columnKey)) {
                  event.preventDefault();
                  return;
                }
              }
              event.preventDefault();
            }
          },
          [editableColumns, stores.length, tryFocus, onSelectRow]
        );
        const diffText =
          difference === 0
            ? "配分値は目標に一致しています"
            : difference > 0
            ? `未配分 ${difference.toLocaleString()}`
            : `超過 ${Math.abs(difference).toLocaleString()}`;
        const diffClass =
          difference === 0
            ? "sheet-status-ok"
            : difference > 0
            ? "sheet-status-warn"
            : "sheet-status-over";
        const highlightMap = {
          even: "allocation",
          sales: "sales",
          area: "area",
          custom: "customCoefficient",
          csv: "csvCoefficient",
        };
        const highlightKey = highlightMap[basis] || null;
        const severityFor = (status) =>
          status === "error"
            ? "error"
            : status === "warning"
            ? "warning"
            : "success";
        const alerts = [];
        if (masterInfo && masterInfo.message) {
          alerts.push({
            key: "master",
            label: masterInfo.fileName || "マスターCSV",
            info: masterInfo,
            severity: severityFor(masterInfo.status),
            onClose: onDismissMasterInfo,
            onReset: masterInfo.status === "success" ? onResetMaster : null,
          });
        }
        Object.entries(patternInfos || {}).forEach(([key, info]) => {
          if (!info || !info.message) return;
          alerts.push({
            key,
            label: info.fileName || PATTERN_LABELS[key] || key,
            info,
            severity: severityFor(info.status),
            onClose: () => onDismissPatternInfo(key),
            onReset: null,
          });
        });
        let runningTotal = 0;
        return (
          <Box
            className="sheet-container"
            role="region"
            aria-label="店舗別配分一覧"
          >
            {alerts.length > 0 && (
              <Stack spacing={0.75} sx={{ mb: 1.25 }}>
                {alerts.map((alert) => (
                  <Alert
                    key={alert.key}
                    severity={alert.severity}
                    action={
                      <Stack direction="row" spacing={0.5} alignItems="center">
                        {alert.onReset && (
                          <Button size="small" onClick={alert.onReset}>
                            リセット
                          </Button>
                        )}
                        <IconButton
                          size="small"
                          onClick={alert.onClose}
                          aria-label="通知を閉じる"
                        >
                          <span className="material-icons" style={{ fontSize: 18 }}>
                            close
                          </span>
                        </IconButton>
                      </Stack>
                    }
                  >
                    <Stack
                      direction={{ xs: "column", sm: "row" }}
                      spacing={1}
                      alignItems={{ xs: "flex-start", sm: "center" }}
                    >
                      <span>{alert.info.message}</span>
                      <Chip
                        label={alert.label}
                        sx={{ ml: { sm: "auto" } }}
                      />
                    </Stack>
                  </Alert>
                ))}
              </Stack>
            )}
            <table className="sheet-table" ref={tableRef}>
              <thead>
                <tr className="header-controls-row">
                  <th className="row-index header-control-empty" />
                  <th className="header-control-cell" colSpan="2">
                    <Stack spacing={0.5}>
                      <Stack
                        direction="row"
                        spacing={0.5}
                        alignItems="center"
                        flexWrap="wrap"
                      >
                        <Button
                          size="small"
                          variant="outlined"
                          startIcon={<span className="material-icons">table_view</span>}
                          onClick={() => masterFileInputRef.current?.click()}
                        >
                          読み込む
                        </Button>
                        <Button
                          size="small"
                          variant="text"
                          onClick={onDownloadMasterTemplate}
                        >
                          テンプレート
                        </Button>
                      </Stack>
                    </Stack>
                    <input
                      type="file"
                      accept=".csv"
                      ref={masterFileInputRef}
                      style={{ display: "none" }}
                      onChange={(event) => {
                        const file = event.target.files?.[0];
                        if (file) onMasterUpload(file);
                        event.target.value = "";
                      }}
                    />
                  </th>
                  <th className="header-control-empty" />
                  <th className="align-right header-control-cell" colSpan="2">
                    <Stack spacing={0.5} alignItems="flex-end">
                      <Stack direction="row" spacing={0.5} alignItems="center" flexWrap="wrap" sx={{ justifyContent: "flex-end" }}>
                        <Button size="small" variant="outlined" startIcon={<span className="material-icons">upload_file</span>} onClick={() => salesFileInputRef.current?.click()}>読み込む</Button>
                        <Button size="small" variant="text" onClick={() => onDownloadPatternTemplate("sales")}>テンプレート</Button>
                      </Stack>
                    </Stack>
                    <input type="file" accept=".csv" ref={salesFileInputRef} style={{ display: "none" }} onChange={(event) => { const file = event.target.files?.[0]; if (file) onPatternUpload("sales", file); event.target.value = ""; }} />
                  </th>
                  <th className="align-right header-control-cell" colSpan="2">
                    <Stack spacing={0.5} alignItems="flex-end">
                      <Stack direction="row" spacing={0.5} alignItems="center" flexWrap="wrap" sx={{ justifyContent: "flex-end" }}>
                        <Button size="small" variant="outlined" startIcon={<span className="material-icons">upload_file</span>} onClick={() => areaFileInputRef.current?.click()}>読み込む</Button>
                        <Button size="small" variant="text" onClick={() => onDownloadPatternTemplate("area")}>テンプレート</Button>
                      </Stack>
                    </Stack>
                    <input type="file" accept=".csv" ref={areaFileInputRef} style={{ display: "none" }} onChange={(event) => { const file = event.target.files?.[0]; if (file) onPatternUpload("area", file); event.target.value = ""; }} />
                  </th>
                  <th className="align-right header-control-cell" colSpan="2">
                    <Stack spacing={0.5} alignItems="flex-end">
                      <Stack direction="row" spacing={0.5} alignItems="center" flexWrap="wrap" sx={{ justifyContent: "flex-end" }}>
                        <Button size="small" variant="outlined" startIcon={<span className="material-icons">upload_file</span>} onClick={() => customFileInputRef.current?.click()}>読み込む</Button>
                        <Button size="small" variant="text" onClick={() => onDownloadPatternTemplate("customCoefficient")}>テンプレート</Button>
                      </Stack>
                    </Stack>
                    <input type="file" accept=".csv" ref={customFileInputRef} style={{ display: "none" }} onChange={(event) => { const file = event.target.files?.[0]; if (file) onPatternUpload("customCoefficient", file); event.target.value = ""; }} />
                  </th>
                  <th className="align-right header-control-cell" colSpan="2">
                    <Stack spacing={0.5} alignItems="flex-end">
                      <Stack direction="row" spacing={0.5} alignItems="center" flexWrap="wrap" sx={{ justifyContent: "flex-end" }}>
                        <Button size="small" variant="outlined" startIcon={<span className="material-icons">upload_file</span>} onClick={() => csvFileInputRef.current?.click()}>読み込む</Button>
                        <Button size="small" variant="text" onClick={() => onDownloadPatternTemplate("csvCoefficient")}>テンプレート</Button>
                      </Stack>
                    </Stack>
                    <input type="file" accept=".csv" ref={csvFileInputRef} style={{ display: "none" }} onChange={(event) => { const file = event.target.files?.[0]; if (file) onPatternUpload("csvCoefficient", file); event.target.value = ""; }} />
                  </th>
                </tr>
                <tr className="header-mode-row">
                  <th className="row-index header-control-empty" />
                  <th className="header-control-empty" />
                  <th className="align-right header-control-cell">
                    <Checkbox checked={basis === "even"} onChange={() => onBasisChange("even")} size="small" />
                  </th>
                  <th className="header-control-empty" />
                  <th className="align-right header-control-cell" colSpan="2">
                    <Checkbox checked={basis === "sales"} onChange={() => onBasisChange("sales")} size="small" />
                  </th>
                  <th className="align-right header-control-cell" colSpan="2">
                    <Checkbox checked={basis === "area"} onChange={() => onBasisChange("area")} size="small" />
                  </th>
                  <th className="align-right header-control-cell" colSpan="2">
                    <Checkbox checked={basis === "custom"} onChange={() => onBasisChange("custom")} size="small" />
                  </th>
                  <th className="align-right header-control-cell" colSpan="2">
                    <Checkbox checked={basis === "csv"} onChange={() => onBasisChange("csv")} size="small" />
                  </th>
                </tr>
                <tr className="header-label-row">
                  <th className="row-index" onClick={() => onSort("id")} style={{ cursor: "pointer" }}>No.</th>
                  <th onClick={() => onSort("name")} style={{ cursor: "pointer" }}>
                    <Stack direction="row" spacing={0.5} alignItems="center">
                      <Checkbox checked={allSelected} onChange={(e) => onToggleAll(e.target.checked)} size="small" sx={{ p: 0 }} />
                      <span>店舗</span>
                    </Stack>
                  </th>
                  <th className="align-right metric-cell" onClick={() => onSort("allocation")} style={{ cursor: "pointer" }}>均等</th>
                  <th className="align-right metric-cell">累計</th>
                  <th className="align-right metric-cell" onClick={() => onSort("sales")} style={{ cursor: "pointer" }}>売上</th>
                  <th className="align-right metric-cell" onClick={() => onSort("salesAdjust")} style={{ cursor: "pointer" }}>売上調整%</th>
                  <th className="align-right metric-cell" onClick={() => onSort("area")} style={{ cursor: "pointer" }}>面積</th>
                  <th className="align-right metric-cell" onClick={() => onSort("areaAdjust")} style={{ cursor: "pointer" }}>面積調整%</th>
                  <th className="align-right metric-cell" onClick={() => onSort("customCoefficient")} style={{ cursor: "pointer" }}>任意係数</th>
                  <th className="align-right metric-cell" onClick={() => onSort("customAdjust")} style={{ cursor: "pointer" }}>任意調整%</th>
                  <th className="align-right metric-cell" onClick={() => onSort("csvCoefficient")} style={{ cursor: "pointer" }}>CSV係数</th>
                  <th className="align-right metric-cell" onClick={() => onSort("csvAdjust")} style={{ cursor: "pointer" }}>CSV調整%</th>
                </tr>
              </thead>
              <tbody>
                {sortedStores.map((store, idx) => {
                  runningTotal += store.allocation;
                  return (
                    <tr
                      key={store.id}
                      className={store.include ? undefined : "inactive"}
                      onClick={() => onSelectRow(store.id)}
                      style={{ cursor: "pointer", backgroundColor: selectedRow === store.id ? "#fef3c7" : undefined }}
                      ref={selectedRow === store.id ? (el) => el?.scrollIntoView({ behavior: "smooth", block: "center" }) : null}
                    >
                      <td className="row-index">
                        {String(idx + 1).padStart(3, "0")}
                      </td>
                      <td className="store-cell">
                        <Checkbox
                          checked={store.include}
                          onChange={() => onToggleInclude(idx)}
                          inputProps={{
                            "aria-label": `${store.name}を配分対象に含める`,
                          }}
                          sx={{ p: 0.25 }}
                        />
                        <span className="store-name">{store.name}</span>
                      </td>
                      <td
                        className={`align-right metric-cell ${
                          highlightKey === "allocation" ? "basis-active" : ""
                        }`}
                      >
                        <input
                          type="number"
                          className={`sheet-input ${store.fixedAllocation !== null ? "fixed-input" : ""}`}
                          value={store.allocation}
                          onChange={(event) => onAllocationChange(idx, event)}
                          onKeyDown={(event) =>
                            handleCellKeyDown(event, idx, "allocation")
                          }
                          min={0}
                          step={1}
                          inputMode="numeric"
                          aria-label={`${store.name} の配分値`}
                          onFocus={(event) => event.target.select()}
                          disabled={!store.include}
                          data-row-index={idx}
                          data-col-key="allocation"
                        />
                      </td>
                      <td className="align-right metric-cell">
                        {runningTotal.toLocaleString()}
                      </td>
                      <td className={`align-right metric-cell ${highlightKey === "sales" ? "basis-active" : ""}`}>
                        <input
                          type="number"
                          className="sheet-input"
                          value={store.sales}
                          onChange={(event) => onMetricChange(idx, "sales", event)}
                          onKeyDown={(event) => handleCellKeyDown(event, idx, "sales")}
                          min={0}
                          step={1}
                          inputMode="numeric"
                          data-row-index={idx}
                          data-col-key="sales"
                        />
                      </td>
                      <td className="align-right metric-cell">
                        <input
                          type="number"
                          className="sheet-input"
                          value={store.salesAdjust}
                          onChange={(event) => onMetricChange(idx, "salesAdjust", event)}
                          onKeyDown={(event) => handleCellKeyDown(event, idx, "salesAdjust")}
                          step={1}
                          inputMode="numeric"
                          data-row-index={idx}
                          data-col-key="salesAdjust"
                        />
                      </td>
                      <td className={`align-right metric-cell ${highlightKey === "area" ? "basis-active" : ""}`}>
                        <input
                          type="number"
                          className="sheet-input"
                          value={store.area}
                          onChange={(event) => onMetricChange(idx, "area", event)}
                          onKeyDown={(event) => handleCellKeyDown(event, idx, "area")}
                          min={0}
                          step={1}
                          inputMode="numeric"
                          data-row-index={idx}
                          data-col-key="area"
                        />
                      </td>
                      <td className="align-right metric-cell">
                        <input
                          type="number"
                          className="sheet-input"
                          value={store.areaAdjust}
                          onChange={(event) => onMetricChange(idx, "areaAdjust", event)}
                          onKeyDown={(event) => handleCellKeyDown(event, idx, "areaAdjust")}
                          step={1}
                          inputMode="numeric"
                          data-row-index={idx}
                          data-col-key="areaAdjust"
                        />
                      </td>
                      <td className={`align-right metric-cell ${highlightKey === "customCoefficient" ? "basis-active" : ""}`}>
                        <input
                          type="number"
                          className="sheet-input"
                          value={store.customCoefficient}
                          onChange={(event) => onMetricChange(idx, "customCoefficient", event)}
                          onKeyDown={(event) => handleCellKeyDown(event, idx, "customCoefficient")}
                          min={0}
                          step={0.1}
                          inputMode="decimal"
                          data-row-index={idx}
                          data-col-key="customCoefficient"
                        />
                      </td>
                      <td className="align-right metric-cell">
                        <input
                          type="number"
                          className="sheet-input"
                          value={store.customAdjust}
                          onChange={(event) => onMetricChange(idx, "customAdjust", event)}
                          onKeyDown={(event) => handleCellKeyDown(event, idx, "customAdjust")}
                          step={1}
                          inputMode="numeric"
                          data-row-index={idx}
                          data-col-key="customAdjust"
                        />
                      </td>
                      <td className={`align-right metric-cell ${highlightKey === "csvCoefficient" ? "basis-active" : ""}`}>
                        {store.csvCoefficient !== null
                          ? Number(store.csvCoefficient).toLocaleString(undefined, { maximumFractionDigits: 3 })
                          : "―"}
                      </td>
                      <td className="align-right metric-cell">
                        <input
                          type="number"
                          className="sheet-input"
                          value={store.csvAdjust}
                          onChange={(event) => onMetricChange(idx, "csvAdjust", event)}
                          onKeyDown={(event) => handleCellKeyDown(event, idx, "csvAdjust")}
                          step={1}
                          inputMode="numeric"
                          data-row-index={idx}
                          data-col-key="csvAdjust"
                        />
                      </td>
                    </tr>
                  );
                })}
              </tbody>
              <tfoot>
                <tr>
                  <td colSpan="4">配分済み合計</td>
                  <td className="align-right" colSpan="3">
                    {currentSum.toLocaleString()}
                  </td>
                  <td className="align-right" colSpan="3">
                    目標 {total.toLocaleString()}
                  </td>
                </tr>
                <tr>
                  <td colSpan="7">差分</td>
                  <td className={`align-right ${diffClass}`} colSpan="3">
                    {diffText}
                  </td>
                </tr>
              </tfoot>
            </table>
          </Box>
        );
      }

      function App() {
        const {
          total,
          storeCount,
          stores,
          currentSum,
          difference,
          includedCount,
          basis,
          masterInfo,
          patternInfos,
          setBasis,
          handleStoreCountChange,
          handleTotalChange,
          handleAllocationChange,
          toggleStoreInclude,
          handleMetricChange,
          handleMasterCsvUpload,
          distribute,
          applyDifference,
          resetAll,
          handlePatternUpload,
          downloadMasterTemplate,
          downloadPatternTemplate,
          clearMasterData,
          dismissMasterInfo,
          dismissPatternInfo,
          toggleAllStores,
          allSelected,
          exportCsv,
          printTable,
          selectedRow,
          setSelectedRow,
          sortConfig,
          setSortConfig,
          activeTab,
          setActiveTab,
          undo,
          redo,
          resetFixedAllocations,
          canUndo,
          canRedo,
          topSelectCount,
          setTopSelectCount,
          bottomSelectCount,
          setBottomSelectCount,
          selectTopStores,
          selectBottomStores,
          exportTableCsv,
          printTable: printTableFunc,
          fixedCount,
          handleBalanceImport,
          downloadBalanceTemplate,
        } = useAllocations();
        const isMobile = useMediaQuery(theme.breakpoints.down("sm"));
        const basisLabel = BASIS_LABEL_LOOKUP[basis] || "未選択";
        
        const handleSort = React.useCallback((key) => {
          setSortConfig((prev) => ({
            key,
            direction: prev.key === key && prev.direction === "asc" ? "desc" : "asc",
          }));
        }, [setSortConfig]);
        return (
          <ThemeProvider theme={theme}>
            <CssBaseline />
            <Box sx={{ display: "flex", flexDirection: "column", height: "100vh", width: "100%" }}>
              <AppBar position="sticky" elevation={8}>
                <Toolbar sx={{ gap: { xs: 0.25, sm: 0.5 }, px: { xs: 1, sm: 2 } }}>
                  <Typography variant="h6" sx={{ fontWeight: 700, fontSize: { xs: "0.85rem", sm: "1rem", md: "1.25rem" }, whiteSpace: "nowrap", overflow: "hidden", textOverflow: "ellipsis" }}>
                    150店舗 配分シミュレーター
                  </Typography>
                  <Tooltip title="ページ再読み込み">
                    <IconButton color="inherit" onClick={() => window.location.reload()} size="small">
                      <span className="material-icons" style={{ fontSize: isMobile ? 18 : 20 }}>refresh</span>
                    </IconButton>
                  </Tooltip>
                  <Box sx={{ flexGrow: 1 }} />
                </Toolbar>
              </AppBar>
              <Box
                sx={{
                  py: { xs: 0.5, sm: 1 },
                  px: { xs: 0.5, sm: 1, md: 2, lg: 3 },
                  flex: 1,
                  display: "flex",
                  flexDirection: "column",
                  gap: { xs: 0.5, sm: 1 },
                  width: "100%",
                  maxWidth: "100%",
                  boxSizing: "border-box",
                }}
              >
                <Paper elevation={4} sx={{ p: { xs: 0.75, sm: 1 } }}>
                  <SummaryPanel
                    total={total}
                    storeCount={storeCount}
                    currentSum={currentSum}
                    difference={difference}
                    includedCount={includedCount}
                    onStoreCountChange={handleStoreCountChange}
                    onTotalChange={handleTotalChange}
                    basisLabel={basisLabel}
                    bases={DISTRIBUTION_BASES}
                    basis={basis}
                    onBasisChange={setBasis}
                    onDistribute={distribute}
                    onApplyDiff={applyDifference}
                    topSelectCount={topSelectCount}
                    setTopSelectCount={setTopSelectCount}
                    bottomSelectCount={bottomSelectCount}
                    setBottomSelectCount={setBottomSelectCount}
                    selectTopStores={selectTopStores}
                    selectBottomStores={selectBottomStores}
                    fixedCount={fixedCount}
                    undo={undo}
                    redo={redo}
                    resetFixedAllocations={resetFixedAllocations}
                    canUndo={canUndo}
                    canRedo={canRedo}
                  />
                </Paper>
                <Paper elevation={4} sx={{ p: { xs: 0.75, sm: 1 } }}>
                  <AllocationChart stores={stores} basis={basis} selectedRow={selectedRow} onImportBalance={handleBalanceImport} onDownloadBalanceTemplate={downloadBalanceTemplate} onSelectRow={setSelectedRow} />
                </Paper>
                <Paper elevation={4} sx={{ p: { xs: 0.75, sm: 1 } }}>
                  <SearchPanel stores={stores} onSelectRow={setSelectedRow} onSwitchToTable={() => setActiveTab(1)} />
                </Paper>
                <Paper elevation={4} sx={{ p: { xs: 0.75, sm: 1 } }}>
                  <Stack direction="row" spacing={0.5} alignItems="center" flexWrap="wrap" sx={{ mb: 1, borderBottom: 1, borderColor: "divider", pb: 0.5, gap: 0.5 }}>
                    <Button onClick={() => setActiveTab(0)} variant={activeTab === 0 ? "contained" : "text"} size="small">配分結果</Button>
                    <Button onClick={() => setActiveTab(1)} variant={activeTab === 1 ? "contained" : "text"} size="small">店舗別配分</Button>
                    {activeTab === 1 && (
                      <>
                        <Box sx={{ flexGrow: 1 }} />
                        <Tooltip title="ダウンロード">
                          <IconButton size="small" onClick={exportTableCsv}>
                            <span className="material-icons">download</span>
                          </IconButton>
                        </Tooltip>
                        <Tooltip title="印刷">
                          <IconButton size="small" onClick={printTableFunc}>
                            <span className="material-icons">print</span>
                          </IconButton>
                        </Tooltip>
                      </>
                    )}
                  </Stack>
                  <Box sx={{ overflow: "auto", height: "68vh" }}>
                    {activeTab === 0 && (
                      <AllocationResult stores={stores} basis={basis} total={total} />
                    )}
                    {activeTab === 1 && (
                      <AllocationTable
                      stores={stores}
                      onAllocationChange={handleAllocationChange}
                      onToggleInclude={toggleStoreInclude}
                      onMetricChange={handleMetricChange}
                      total={total}
                      currentSum={currentSum}
                      difference={difference}
                      dense={isMobile}
                      basis={basis}
                      masterInfo={masterInfo}
                      patternInfos={patternInfos}
                      onMasterUpload={handleMasterCsvUpload}
                      onPatternUpload={handlePatternUpload}
                      onDownloadMasterTemplate={downloadMasterTemplate}
                      onDownloadPatternTemplate={downloadPatternTemplate}
                      onDismissMasterInfo={dismissMasterInfo}
                      onDismissPatternInfo={dismissPatternInfo}
                      onResetMaster={clearMasterData}
                      onToggleAll={toggleAllStores}
                      allSelected={allSelected}
                      onBasisChange={setBasis}
                      selectedRow={selectedRow}
                      onSelectRow={setSelectedRow}
                      sortConfig={sortConfig}
                      onSort={handleSort}
                      />
                    )}
                  </Box>
                </Paper>
              </Box>
            </Box>
          </ThemeProvider>
        );
      }

      ReactDOM.createRoot(document.getElementById("root")).render(<App />);
    </script>
  </body>
</html>
