<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>データ分析システム</title>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    <style>
        #dataTable th, #dataTable td {
            text-align: center;
            font-size: 0.8rem;
            padding: 0.5rem;
        }
        #deleteButtons th {
            text-align: center;
        }
        #dropArea {
            border: 2px dashed #ccc;
            border-radius: 20px;
            padding: 20px;
            text-align: center;
            margin-top: 20px;
        }
        #dropArea.hover {
            border-color: #333;
        }
        th.sortable:hover {
            cursor: pointer;
            background-color: #f1f1f1;
        }
        .pagination {
            margin-top: 20px;
            justify-content: center;
        }
    </style>
</head>
<body>
    <div class="container mt-5">
        <h1 class="text-center">データ分析システム</h1>

        <!-- データ入力セクション -->
        <div id="data-input" class="mt-4">
            <h3>データ入力</h3>
            <textarea id="dataTextarea" class="form-control" rows="10" placeholder="データを入力してください..."></textarea>
            <button id="loadData" class="btn btn-primary mt-3">データを読み込む</button>
            <button id="resetDataInput" class="btn btn-secondary mt-3">リセット</button>
            <div id="dropArea" class="mt-3">
                ここにCSVファイルをドラッグ＆ドロップしてください
            </div>
            <input type="file" id="fileInput" accept=".csv" class="form-control mt-3">
        </div>

        <!-- データ編集セクション -->
        <div id="data-edit" class="mt-4 d-none">
            <h3>データ編集</h3>
            <div class="form-group">
                <label for="rowsPerPage">ページあたりの行数:</label>
                <input type="number" id="rowsPerPage" class="form-control w-25" value="50" min="1">
            </div>
            <div id="dateFilter" class="form-group d-none">
                <label for="startDate">開始日:</label>
                <input type="date" id="startDate" class="form-control w-25">
                <label for="endDate" class="mt-2">終了日:</label>
                <input type="date" id="endDate" class="form-control w-25">
                <label for="aggregationUnit" class="mt-2">集計単位:</label>
                <select id="aggregationUnit" class="form-control w-25">
                    <option value="year">年</option>
                    <option value="fiscalYear">年度</option>
                    <option value="month">月</option>
                    <option value="week">週</option>
                    <option value="sundayWeek">週（日曜日開始）</option>
                    <option value="dayOfWeek">曜日</option>
                    <option value="day">日</option>
                    <option value="hour">時間</option>
                </select>
                <button id="filterByDate" class="btn btn-info mt-2">フィルター適用</button>
                <button id="aggregateByUnit" class="btn btn-info mt-2">集計</button>
                <button id="resetDateFilter" class="btn btn-secondary mt-2">期間リセット</button>
                <button id="resetAggregationUnit" class="btn btn-secondary mt-2">集計リセット</button>
            </div>
            <table id="dataTable" class="table table-bordered table-sm">
                <thead>
                    <tr id="deleteButtons">
                        <th></th>
                    </tr>
                    <tr id="checkboxRow">
                        <th></th>
                    </tr>
                    <tr id="typeRow">
                        <th></th>
                    </tr>
                    <tr id="filterRow">
                        <th></th>
                    </tr>
                    <tr id="tableHeader">
                        <th><input type="checkbox" id="selectAll"></th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
            <nav>
                <ul class="pagination"></ul>
            </nav>
            <button id="addRow" class="btn btn-success">行を追加</button>
            <button id="addColumn" class="btn btn-success">列を追加</button>
            <button id="undoDelete" class="btn btn-warning">列削除を元に戻す</button>
            <button id="deleteSelectedRows" class="btn btn-danger mt-3">選択した行を削除</button>
            <button id="deleteUnselectedRows" class="btn btn-danger mt-3">選択した行以外を削除</button>
            <button id="resetDataEdit" class="btn btn-secondary mt-3">リセット</button>
        </div>

        <!-- 集計セクション -->
        <div id="aggregation-section" class="mt-4 d-none">
            <h3>集計</h3>
            <button id="calculateSum" class="btn btn-info">合計を計算</button>
            <button id="calculateAverage" class="btn btn-info">平均を計算</button>
            <select id="groupByColumn" class="form-control mt-3">
                <option value="">グループ化する列を選択</option>
            </select>
            <button id="groupAndAggregate" class="btn btn-info mt-3">グループ化して集計</button>
            <div id="aggregationResults" class="mt-3"></div>
            <button id="resetAggregation" class="btn btn-secondary mt-3">リセット</button>
        </div>

        <!-- 分析設定セクション -->
        <div id="analysis-settings" class="mt-4">
            <h3>分析設定</h3>
            <button id="saveSettings" class="btn btn-secondary">設定を保存</button>
            <button id="exportSettings" class="btn btn-secondary">設定をエクスポート</button>
            <button id="importSettings" class="btn btn-secondary">設定をインポート</button>
            <button id="resetSettings" class="btn btn-secondary mt-3">リセット</button>
        </div>

        <!-- 分析結果出力セクション -->
        <div id="analysis-output" class="mt-4">
            <h3>分析結果</h3>
            <canvas id="myChart"></canvas>
            <button id="generateChart" class="btn btn-primary mt-3">グラフを生成</button>
            <button id="resetChart" class="btn btn-secondary mt-3">リセット</button>
        </div>
    </div>

    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        let deletedColumns = [];
        let chartInstance = null;
        let sortOrder = {}; // ソートの順序を管理するオブジェクト
        let currentPage = 1;
        let rowsPerPage = 50;
        let currentData = [];
        let originalData = []; // オリジナルのデータを保存
        let filteredData = []; // フィルター後のデータを保存
        let dateColumn = null; // 日付列のインデックス
        let initialStartDate = null;
        let initialEndDate = null;

        const defaultCsvUrl = 'default.csv'; // デフォルトのCSVファイルのURL

        document.addEventListener('DOMContentLoaded', () => {
            const urlParams = new URLSearchParams(window.location.search);
            const csvUrl = urlParams.get('csv') || defaultCsvUrl;

            fetchCsv(csvUrl);

            document.getElementById('rowsPerPage').addEventListener('change', (event) => {
                rowsPerPage = parseInt(event.target.value, 10);
                currentPage = 1;
                renderTable();
            });
        });

        document.getElementById('loadData').addEventListener('click', () => {
            const data = document.getElementById('dataTextarea').value;
            const parsedData = parseData(data);
            populateTable(parsedData);
            document.getElementById('data-edit').classList.remove('d-none');
            document.getElementById('aggregation-section').classList.remove('d-none');
        });

        document.getElementById('resetDataInput').addEventListener('click', () => {
            document.getElementById('dataTextarea').value = '';
        });

        document.getElementById('resetDataEdit').addEventListener('click', () => {
            document.getElementById('deleteButtons').innerHTML = '<th></th>';
            document.getElementById('checkboxRow').innerHTML = '<th></th>';
            document.getElementById('typeRow').innerHTML = '<th></th>';
            document.getElementById('filterRow').innerHTML = '<th></th>';
            document.getElementById('tableHeader').innerHTML = '<th><input type="checkbox" id="selectAll"></th>';
            document.getElementById('dataTable').querySelector('tbody').innerHTML = '';
            currentData = [];
            originalData = [];
            filteredData = [];
            dateColumn = null;
            renderTable();
        });

        document.getElementById('resetAggregation').addEventListener('click', () => {
            currentData = [...filteredData];
            renderTable();
        });

        document.getElementById('resetSettings').addEventListener('click', () => {
            document.cookie = 'settings=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;';
        });

        document.getElementById('resetChart').addEventListener('click', () => {
            if (chartInstance) {
                chartInstance.destroy();
            }
        });

        document.getElementById('saveSettings').addEventListener('click', () => {
            const settings = {
                data: getTableData()
            };
            document.cookie = `settings=${JSON.stringify(settings)}; path=/`;
            alert('設定が保存されました');
        });

        document.getElementById('exportSettings').addEventListener('click', () => {
            const settings = {
                data: getTableData()
            };
            const blob = new Blob([JSON.stringify(settings)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'settings.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            alert('設定がエクスポートされました');
        });

        document.getElementById('importSettings').addEventListener('click', () => {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'application/json';
            input.addEventListener('change', (event) => {
                const file = event.target.files[0];
                const reader = new FileReader();
                reader.onload = (e) => {
                    const settings = JSON.parse(e.target.result);
                    populateTable(settings.data);
                    alert('設定がインポートされました');
                };
                reader.readAsText(file);
            });
            input.click();
        });

        document.getElementById('addRow').addEventListener('click', () => {
            addTableRow(Array(document.querySelectorAll('#tableHeader th').length - 2).fill(''));
        });

        document.getElementById('addColumn').addEventListener('click', () => {
            const columnName = prompt('新しい列の名前を入力してください:');
            if (columnName) {
                addTableColumn(columnName);
            }
        });

        document.getElementById('undoDelete').addEventListener('click', () => {
            if (deletedColumns.length > 0) {
                const column = deletedColumns.pop();
                restoreTableColumn(column);
            } else {
                alert('削除された列はありません。');
            }
        });

        document.getElementById('calculateSum').addEventListener('click', () => {
            const data = getTableData();
            const sum = calculateSum(data);
            displayAggregationResults('合計', sum);
        });

        document.getElementById('calculateAverage').addEventListener('click', () => {
            const data = getTableData();
            const average = calculateAverage(data);
            displayAggregationResults('平均', average);
        });

        document.getElementById('groupAndAggregate').addEventListener('click', () => {
            const groupByColumn = document.getElementById('groupByColumn').value;
            if (groupByColumn) {
                const data = getTableData();
                const aggregatedData = groupAndAggregate(data, groupByColumn);
                displayAggregationResults('グループ化して集計', aggregatedData);
            } else {
                alert('グループ化する列を選択してください。');
            }
        });

        document.getElementById('generateChart').addEventListener('click', () => {
            const data = getTableData();
            generateChart(data);
        });

        document.getElementById('deleteSelectedRows').addEventListener('click', () => {
            deleteSelectedRows();
        });

        document.getElementById('deleteUnselectedRows').addEventListener('click', () => {
            deleteUnselectedRows();
        });

        document.getElementById('selectAll').addEventListener('change', (event) => {
            const checked = event.target.checked;
            document.querySelectorAll('#dataTable tbody input[type="checkbox"]').forEach(cb => {
                cb.checked = checked;
            });
        });

        document.getElementById('fileInput').addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const data = e.target.result;
                    document.getElementById('dataTextarea').value = data;
                };
                reader.readAsText(file);
            }
        });

        document.getElementById('filterByDate').addEventListener('click', () => {
            filterByDate();
        });

        document.getElementById('aggregateByUnit').addEventListener('click', () => {
            aggregateByUnit();
        });

        document.getElementById('resetDateFilter').addEventListener('click', () => {
            resetDateFilter();
        });

        document.getElementById('resetAggregationUnit').addEventListener('click', () => {
            resetAggregationUnit();
        });

        const dropArea = document.getElementById('dropArea');

        dropArea.addEventListener('dragover', (event) => {
            event.preventDefault();
            dropArea.classList.add('hover');
        });

        dropArea.addEventListener('dragleave', () => {
            dropArea.classList.remove('hover');
        });

        dropArea.addEventListener('drop', (event) => {
            event.preventDefault();
            dropArea.classList.remove('hover');

            const file = event.dataTransfer.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const data = e.target.result;
                    document.getElementById('dataTextarea').value = data;
                };
                reader.readAsText(file);
            }
        });

        function fetchCsv(url) {
            fetch(url)
                .then(response => {
                    if (response.ok) {
                        return response.text();
                    } else {
                        throw new Error('CSV file not found');
                    }
                })
                .then(data => {
                    document.getElementById('dataTextarea').value = data;
                })
                .catch(error => {
                    console.error('Error fetching CSV:', error);
                    document.getElementById('dataTextarea').value = '';
                });
        }

        function parseData(data) {
            const rows = data.split('\n');
            const parsedData = [];
            let headers = [];

            rows.forEach((row, index) => {
                const columns = row.split(',');
                if (index === 0) {
                    headers = columns;
                } else {
                    if (columns.length === headers.length) {
                        const rowObject = {};
                        headers.forEach((header, i) => {
                            rowObject[header] = columns[i];
                        });
                        parsedData.push(rowObject);
                    }
                }
            });

            const types = detectColumnTypes(parsedData, headers);
            return { headers, data: parsedData, types };
        }

        function detectColumnTypes(data, headers) {
            const types = headers.map(header => {
                let isNumber = true;
                let isDate = true;

                for (const row of data) {
                    if (isNaN(row[header])) {
                        isNumber = false;
                    }
                    if (isNaN(Date.parse(row[header]))) {
                        isDate = false;
                    }
                }

                if (isNumber) {
                    return 'number';
                } else if (isDate) {
                    return 'date';
                } else {
                    return 'string';
                }
            });

            return types;
        }

        function populateTable(parsedData) {
            const deleteButtons = document.getElementById('deleteButtons');
            const checkboxRow = document.getElementById('checkboxRow');
            const typeRow = document.getElementById('typeRow');
            const filterRow = document.getElementById('filterRow');
            const tableHeader = document.getElementById('tableHeader');
            const tableBody = document.getElementById('dataTable').querySelector('tbody');

            deleteButtons.innerHTML = '<th></th>';
            checkboxRow.innerHTML = '<th></th>';
            typeRow.innerHTML = '<th></th>';
            filterRow.innerHTML = '<th></th>';
            tableHeader.innerHTML = '<th><input type="checkbox" id="selectAll"></th>';
            tableBody.innerHTML = '';

            parsedData.headers.forEach((header, index) => {
                const thHeader = document.createElement('th');
                thHeader.textContent = header;
                thHeader.classList.add('sortable');
                thHeader.addEventListener('click', () => sortTableByColumn(index));
                tableHeader.appendChild(thHeader);

                const thCheckbox = document.createElement('th');
                thCheckbox.innerHTML = `<input type="checkbox" class="columnCheckbox">`;
                checkboxRow.appendChild(thCheckbox);

                const thType = document.createElement('th');
                thType.innerHTML = `
                    <select class="form-control">
                        <option value="string"${parsedData.types[index] === 'string' ? ' selected' : ''}>String</option>
                        <option value="number"${parsedData.types[index] === 'number' ? ' selected' : ''}>Number</option>
                        <option value="date"${parsedData.types[index] === 'date' ? ' selected' : ''}>Date</option>
                    </select>`;
                thType.querySelector('select').addEventListener('change', (e) => updateColumnType(index, e.target.value));
                typeRow.appendChild(thType);

                const thFilter = document.createElement('th');
                thFilter.innerHTML = `<input type="text" class="form-control filterInput" placeholder="フィルター">`;
                filterRow.appendChild(thFilter);

                const thButton = document.createElement('th');
                thButton.innerHTML = `<button class="btn btn-danger btn-sm" onclick="deleteTableColumn(${index})">削除</button>`;
                deleteButtons.appendChild(thButton);

                if (parsedData.types[index] === 'date') {
                    dateColumn = index;
                }
            });

            const thHeader = document.createElement('th');
            thHeader.textContent = '操作';
            tableHeader.appendChild(thHeader);

            const thFilterButton = document.createElement('th');
            thFilterButton.innerHTML = `<button class="btn btn-info btn-sm" onclick="applyFilters()">フィルター適用</button>`;
            filterRow.appendChild(thFilterButton);

            const thButton = document.createElement('th');
            deleteButtons.appendChild(thButton);

            currentData = parsedData.data;
            originalData = JSON.parse(JSON.stringify(parsedData.data)); // データを保存
            filteredData = [...parsedData.data]; // フィルター後のデータを保存
            renderTable();

            updateGroupByColumnOptions(parsedData.headers);

            if (dateColumn !== null) {
                document.getElementById('dateFilter').classList.remove('d-none');
                setDateRange();
            }
        }

        function setDateRange() {
            const dateValues = currentData.map(row => new Date(row[Object.keys(row)[dateColumn]]));
            const minDate = new Date(Math.min(...dateValues));
            const maxDate = new Date(Math.max(...dateValues));

            document.getElementById('startDate').valueAsDate = minDate;
            document.getElementById('endDate').valueAsDate = maxDate;

            initialStartDate = minDate;
            initialEndDate = maxDate;
        }

        function resetDateFilter() {
            document.getElementById('startDate').valueAsDate = initialStartDate;
            document.getElementById('endDate').valueAsDate = initialEndDate;
        }

        function resetAggregationUnit() {
            document.getElementById('aggregationUnit').selectedIndex = 0;
            currentData = filteredData.filter(row => {
                const date = new Date(row[Object.keys(row)[dateColumn]]);
                return date >= new Date(document.getElementById('startDate').value) && date <= new Date(document.getElementById('endDate').value);
            });
            renderTable();
        }

        function updateColumnType(index, type) {
            const header = document.getElementById('tableHeader').children[index + 1].textContent;
            currentData.forEach(row => {
                if (type === 'number') {
                    row[header] = parseFloat(row[header]);
                } else if (type === 'date') {
                    row[header] = new Date(row[header]).toISOString();
                }
            });

            if (type === 'date') {
                dateColumn = index;
                document.getElementById('dateFilter').classList.remove('d-none');
                setDateRange();
            } else {
                dateColumn = null;
                document.getElementById('dateFilter').classList.add('d-none');
            }

            renderTable();
        }

        function filterByDate() {
            const startDate = new Date(document.getElementById('startDate').value);
            const endDate = new Date(document.getElementById('endDate').value);
            const header = document.getElementById('tableHeader').children[dateColumn + 1].textContent;

            filteredData = originalData.filter(row => {
                const date = new Date(row[header]);
                return date >= startDate && date <= endDate;
            });

            currentData = [...filteredData];
            renderTable();
        }

        function aggregateByUnit() {
            const unit = document.getElementById('aggregationUnit').value;
            const header = document.getElementById('tableHeader').children[dateColumn + 1].textContent;

            const aggregatedData = {};
            currentData.forEach(row => {
                const date = new Date(row[header]);
                let key;
                switch (unit) {
                    case 'year':
                        key = date.getFullYear();
                        break;
                    case 'fiscalYear':
                        key = date.getMonth() < 3 ? date.getFullYear() - 1 : date.getFullYear();
                        break;
                    case 'month':
                        key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                        break;
                    case 'week':
                        key = getWeekNumber(date, false);
                        break;
                    case 'sundayWeek':
                        key = getWeekNumber(date, true);
                        break;
                    case 'dayOfWeek':
                        key = date.getDay();
                        break;
                    case 'day':
                        key = date.toISOString().split('T')[0];
                        break;
                    case 'hour':
                        key = `${date.toISOString().split('T')[0]}T${String(date.getHours()).padStart(2, '0')}:00`;
                        break;
                }
                if (!aggregatedData[key]) {
                    aggregatedData[key] = {};
                    for (const col of Object.keys(row)) {
                        if (col !== header) {
                            aggregatedData[key][col] = 0;
                        }
                    }
                }
                for (const col of Object.keys(row)) {
                    if (col !== header && !isNaN(row[col])) {
                        aggregatedData[key][col] += parseFloat(row[col]);
                    }
                }
            });

            const aggregatedArray = Object.keys(aggregatedData).map(key => {
                const obj = { [header]: key };
                for (const col of Object.keys(aggregatedData[key])) {
                    obj[col] = aggregatedData[key][col];
                }
                return obj;
            });

            currentData = aggregatedArray;
            renderTable();
        }

        function getWeekNumber(date, isSundayStart) {
            const day = date.getDay();
            const diff = isSundayStart ? day : (day + 6) % 7;
            const firstDayOfYear = new Date(date.getFullYear(), 0, 1);
            const daysSinceFirstDay = Math.floor((date - firstDayOfYear) / (24 * 60 * 60 * 1000));
            return Math.ceil((daysSinceFirstDay + 1 + diff) / 7);
        }

        function addTableRow(values) {
            currentData.push(values.reduce((obj, value, index) => {
                const header = document.getElementById('tableHeader').children[index + 1].textContent;
                obj[header] = value;
                return obj;
            }, {}));
            renderTable();
        }

        function addTableColumn(columnName) {
            const deleteButtons = document.getElementById('deleteButtons');
            const checkboxRow = document.getElementById('checkboxRow');
            const typeRow = document.getElementById('typeRow');
            const filterRow = document.getElementById('filterRow');
            const tableHeader = document.getElementById('tableHeader');

            const thHeader = document.createElement('th');
            thHeader.textContent = columnName;
            thHeader.classList.add('sortable');
            thHeader.addEventListener('click', () => sortTableByColumn(tableHeader.children.length - 1));
            tableHeader.insertBefore(thHeader, tableHeader.lastChild);

            const thCheckbox = document.createElement('th');
            thCheckbox.innerHTML = `<input type="checkbox" class="columnCheckbox">`;
            checkboxRow.insertBefore(thCheckbox, checkboxRow.lastChild);

            const thType = document.createElement('th');
            thType.innerHTML = `
                <select class="form-control">
                    <option value="string">String</option>
                    <option value="number">Number</option>
                    <option value="date">Date</option>
                </select>`;
            typeRow.insertBefore(thType, typeRow.lastChild);

            const thFilter = document.createElement('th');
            thFilter.innerHTML = `<input type="text" class="form-control filterInput" placeholder="フィルター">`;
            filterRow.insertBefore(thFilter, filterRow.lastChild);

            const thButton = document.createElement('th');
            thButton.innerHTML = `<button class="btn btn-danger btn-sm" onclick="deleteTableColumn(${tableHeader.children.length - 2})">削除</button>`;
            deleteButtons.insertBefore(thButton, deleteButtons.lastChild);

            currentData.forEach(row => {
                row[columnName] = '';
            });

            renderTable();
            updateGroupByColumnOptions(Array.from(tableHeader.querySelectorAll('th')).slice(1, -1).map(th => th.textContent));
        }

        function deleteTableColumn(columnIndex) {
            const tableHeader = document.getElementById('tableHeader');
            const checkboxRow = document.getElementById('checkboxRow');
            const typeRow = document.getElementById('typeRow');
            const filterRow = document.getElementById('filterRow');
            const deleteButtons = document.getElementById('deleteButtons');

            deletedColumns.push({
                index: columnIndex,
                header: tableHeader.children[columnIndex + 1].textContent,
                cells: currentData.map(row => row[tableHeader.children[columnIndex + 1].textContent])
            });

            tableHeader.children[columnIndex + 1].remove();
            checkboxRow.children[columnIndex + 1].remove();
            typeRow.children[columnIndex + 1].remove();
            filterRow.children[columnIndex + 1].remove();
            deleteButtons.children[columnIndex + 1].remove();

            currentData.forEach(row => {
                delete row[tableHeader.children[columnIndex + 1].textContent];
            });

            renderTable();
            updateGroupByColumnOptions(Array.from(document.querySelectorAll('#tableHeader th')).slice(1, -1).map(th => th.textContent));
        }

        function restoreTableColumn(column) {
            const tableHeader = document.getElementById('tableHeader');
            const checkboxRow = document.getElementById('checkboxRow');
            const typeRow = document.getElementById('typeRow');
            const filterRow = document.getElementById('filterRow');
            const deleteButtons = document.getElementById('deleteButtons');

            const thHeader = document.createElement('th');
            thHeader.textContent = column.header;
            thHeader.classList.add('sortable');
            thHeader.addEventListener('click', () => sortTableByColumn(column.index));
            tableHeader.insertBefore(thHeader, tableHeader.children[column.index + 1]);

            const thCheckbox = document.createElement('th');
            thCheckbox.innerHTML = `<input type="checkbox" class="columnCheckbox">`;
            checkboxRow.insertBefore(thCheckbox, checkboxRow.children[column.index + 1]);

            const thType = document.createElement('th');
            thType.innerHTML = `
                <select class="form-control">
                    <option value="string">String</option>
                    <option value="number">Number</option>
                    <option value="date">Date</option>
                </select>`;
            typeRow.insertBefore(thType, typeRow.children[column.index + 1]);

            const thFilter = document.createElement('th');
            thFilter.innerHTML = `<input type="text" class="form-control filterInput" placeholder="フィルター">`;
            filterRow.insertBefore(thFilter, filterRow.children[column.index + 1]);

            const thButton = document.createElement('th');
            thButton.innerHTML = `<button class="btn btn-danger btn-sm" onclick="deleteTableColumn(${column.index})">削除</button>`;
            deleteButtons.insertBefore(thButton, deleteButtons.children[column.index + 1]);

            currentData.forEach((row, index) => {
                row[column.header] = column.cells[index];
            });

            renderTable();
            updateGroupByColumnOptions(Array.from(document.querySelectorAll('#tableHeader th')).slice(1, -1).map(th => th.textContent));
        }

        function removeTableRow(button) {
            const rowIndex = Array.from(button.closest('tr').parentNode.children).indexOf(button.closest('tr'));
            currentData.splice((currentPage - 1) * rowsPerPage + rowIndex, 1);
            renderTable();
        }

        function deleteSelectedRows() {
            const selectedRows = document.querySelectorAll('#dataTable tbody input.rowCheckbox:checked');
            const rowIndexes = Array.from(selectedRows).map(cb => Array.from(cb.closest('tr').parentNode.children).indexOf(cb.closest('tr')));
            rowIndexes.sort((a, b) => b - a);
            rowIndexes.forEach(rowIndex => currentData.splice((currentPage - 1) * rowsPerPage + rowIndex, 1));
            renderTable();
        }

        function deleteUnselectedRows() {
            const unselectedRows = document.querySelectorAll('#dataTable tbody input.rowCheckbox:not(:checked)');
            const rowIndexes = Array.from(unselectedRows).map(cb => Array.from(cb.closest('tr').parentNode.children).indexOf(cb.closest('tr')));
            rowIndexes.sort((a, b) => b - a);
            rowIndexes.forEach(rowIndex => currentData.splice((currentPage - 1) * rowsPerPage + rowIndex, 1));
            renderTable();
        }

        function getTableData() {
            return currentData;
        }

        function applyFilters() {
            const filters = Array.from(document.querySelectorAll('.filterInput')).map(input => input.value);
            const filteredData = currentData.filter(row => {
                return filters.every((filter, index) => {
                    if (!filter) return true;
                    const header = document.getElementById('tableHeader').children[index + 1].textContent;
                    return row[header].includes(filter);
                });
            });
            renderTable(filteredData);
        }

        function sortTableByColumn(columnIndex) {
            const header = document.getElementById('tableHeader').children[columnIndex + 1].textContent;
            const currentOrder = sortOrder[header] || 'asc';
            const newOrder = currentOrder === 'asc' ? 'desc' : 'asc';
            sortOrder[header] = newOrder;

            currentData.sort((a, b) => {
                const cellA = a[header];
                const cellB = b[header];

                if (newOrder === 'asc') {
                    return cellA.localeCompare(cellB, undefined, { numeric: true });
                } else {
                    return cellB.localeCompare(cellA, undefined, { numeric: true });
                }
            });

            renderTable();
        }

        function renderTable(data = currentData) {
            const tableBody = document.getElementById('dataTable').querySelector('tbody');
            tableBody.innerHTML = '';

            const start = (currentPage - 1) * rowsPerPage;
            const end = start + rowsPerPage;
            const rowsToDisplay = data.slice(start, end);

            rowsToDisplay.forEach(row => {
                const tr = document.createElement('tr');

                const tdCheckbox = document.createElement('td');
                tdCheckbox.classList.add('align-middle');
                tdCheckbox.innerHTML = `<input type="checkbox" class="rowCheckbox">`;
                tr.appendChild(tdCheckbox);

                Object.values(row).forEach(value => {
                    const td = document.createElement('td');
                    td.innerHTML = `<input type="text" class="form-control" value="${value}">`;
                    tr.appendChild(td);
                });

                const tdAction = document.createElement('td');
                tdAction.innerHTML = `<button class="btn btn-danger btn-sm" onclick="removeTableRow(this)">削除</button>`;
                tr.appendChild(tdAction);

                tableBody.appendChild(tr);
            });

            renderPagination(data.length);
        }

        function renderPagination(totalRows) {
            const pagination = document.querySelector('.pagination');
            pagination.innerHTML = '';

            const totalPages = Math.ceil(totalRows / rowsPerPage);

            for (let i = 1; i <= totalPages; i++) {
                const li = document.createElement('li');
                li.classList.add('page-item');
                if (i === currentPage) {
                    li.classList.add('active');
                }

                const a = document.createElement('a');
                a.classList.add('page-link');
                a.href = '#';
                a.textContent = i;
                a.addEventListener('click', (event) => {
                    event.preventDefault();
                    currentPage = i;
                    renderTable();
                });

                li.appendChild(a);
                pagination.appendChild(li);
            }
        }

        function calculateSum(data) {
            const sums = {};
            data.forEach(row => {
                for (const key in row) {
                    if (!isNaN(row[key])) {
                        if (!sums[key]) sums[key] = 0;
                        sums[key] += parseFloat(row[key]);
                    }
                }
            });
            return sums;
        }

        function calculateAverage(data) {
            const sums = calculateSum(data);
            const averages = {};
            const count = data.length;

            for (const key in sums) {
                averages[key] = sums[key] / count;
            }

            return averages;
        }

        function groupAndAggregate(data, groupByColumn) {
            const groupedData = {};
            data.forEach(row => {
                const groupValue = row[groupByColumn];
                if (!groupedData[groupValue]) groupedData[groupValue] = [];
                groupedData[groupValue].push(row);
            });

            const aggregatedData = {};
            for (const group in groupedData) {
                aggregatedData[group] = calculateSum(groupedData[group]);
            }

            return aggregatedData;
        }

        function displayAggregationResults(type, results) {
            const aggregationResults = document.getElementById('aggregationResults');
            aggregationResults.innerHTML = `<h4>${type}:</h4><pre>${JSON.stringify(results, null, 2)}</pre>`;
        }

        function updateGroupByColumnOptions(headers) {
            const groupByColumn = document.getElementById('groupByColumn');
            if (!groupByColumn) return;
            groupByColumn.innerHTML = '<option value="">グループ化する列を選択</option>';
            headers.forEach(header => {
                const option = document.createElement('option');
                option.value = header;
                option.textContent = header;
                groupByColumn.appendChild(option);
            });
        }

        function generateChart(data) {
            if (chartInstance) {
                chartInstance.destroy();
            }

            const labels = data.map(row => row.date);
            const datasets = [{
                label: 'sales',
                data: data.map(row => parseFloat(row.sales)),
                backgroundColor: 'rgba(75, 192, 192, 0.2)',
                borderColor: 'rgba(75, 192, 192, 1)',
                borderWidth: 1
            }];

            const ctx = document.getElementById('myChart').getContext('2d');
            chartInstance = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels,
                    datasets
                },
                options: {
                    scales: {
                        y: {
                            beginAtZero: true
                        }
                    }
                }
            });
        }
    </script>
</body>
</html>
