<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>予測結果テーブル：合計列を4列目に表示＋傾向・手動予測入力</title>

  <!-- React, ReactDOM, Babel -->
  <script src="https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.production.min.js" crossorigin></script>
  <script src="https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://cdn.jsdelivr.net/npm/@babel/standalone@7.23.8/babel.min.js"></script>

  <!-- Emotion (MUI依存) -->
  <script src="https://cdn.jsdelivr.net/npm/@emotion/react@11.11.3/dist/emotion-react.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@emotion/styled@11.11.0/dist/emotion-styled.umd.min.js"></script>

  <!-- MUI Core & Roboto -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" />
  <script src="https://cdn.jsdelivr.net/npm/@mui/material@5.15.3/umd/material-ui.production.min.js" crossorigin></script>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <style>
    body { margin: 0; padding: 0; }
    .group-header {
      background-color: #ddd;
      font-weight: bold;
    }
  </style>
</head>
<body>
<div id="root"></div>
<script type="text/babel">

const {
  Container, Box, Typography, Paper, Chip, Button,
  TextField, MenuItem, Tabs, Tab, Table, TableBody,
  TableCell, TableContainer, TableHead, TableRow, Breadcrumbs,
  ToggleButton, ToggleButtonGroup
} = window['MaterialUI'];

/** ====== 期間ラベル生成関数 ====== **/
function getLabels(unit) {
  if (unit === "年") {
    return ["2024年", "2025年", "2026年"];
  } else if (unit === "月") {
    let arr = [];
    for (let i = 1; i <= 14; i++){
      arr.push(`${i}月`);
    }
    return arr;
  } else if (unit === "週") {
    let arr = [];
    for (let i = 1; i <= 56; i++){
      arr.push(`${i}週`);
    }
    return arr;
  } else if (unit === "日") {
    let arr = [];
    let start = new Date("2025-04-16");
    let end = new Date("2025-06-15");
    for (let d = new Date(start); d <= end; d.setDate(d.getDate()+1)) {
      let m = d.getMonth() + 1;
      let day = d.getDate();
      arr.push(`${m}/${day}`);
    }
    return arr;
  } else if (unit === "時間") {
    let arr = [];
    for (let i = 0; i < 24; i++){
      arr.push(`${i}時`);
    }
    return arr;
  }
  return [];
}

/** ====== 階層構造の定義 ====== **/
const hierarchy = {
  "全社": {
    "営業部": {
      "コーナー1": {
        "ライン1": ["カテゴリ1", "カテゴリ2", "カテゴリ3"],
        "ライン2": ["カテゴリ1", "カテゴリ2", "カテゴリ3"]
      },
      "コーナー2": {
        "ライン1": ["カテゴリ1", "カテゴリ2", "カテゴリ3"],
        "ライン2": ["カテゴリ1", "カテゴリ2", "カテゴリ3"]
      },
      "コーナー3": {
        "ライン1": ["カテゴリ1", "カテゴリ2", "カテゴリ3"],
        "ライン2": ["カテゴリ1", "カテゴリ2", "カテゴリ3"]
      }
    },
    "開発部": {
      "コーナー1": {
        "ライン1": ["カテゴリ1", "カテゴリ2", "カテゴリ3"],
        "ライン2": ["カテゴリ1", "カテゴリ2", "カテゴリ3"]
      },
      "コーナー2": {
        "ライン1": ["カテゴリ1", "カテゴリ2", "カテゴリ3"],
        "ライン2": ["カテゴリ1", "カテゴリ2", "カテゴリ3"]
      },
      "コーナー3": {
        "ライン1": ["カテゴリ1", "カテゴリ2", "カテゴリ3"],
        "ライン2": ["カテゴリ1", "カテゴリ2", "カテゴリ3"]
      }
    },
    "管理部": {
      "コーナー1": {
        "ライン1": ["カテゴリ1", "カテゴリ2", "カテゴリ3"],
        "ライン2": ["カテゴリ1", "カテゴリ2", "カテゴリ3"]
      },
      "コーナー2": {
        "ライン1": ["カテゴリ1", "カテゴリ2", "カテゴリ3"],
        "ライン2": ["カテゴリ1", "カテゴリ2", "カテゴリ3"]
      },
      "コーナー3": {
        "ライン1": ["カテゴリ1", "カテゴリ2", "カテゴリ3"],
        "ライン2": ["カテゴリ1", "カテゴリ2", "カテゴリ3"]
      }
    }
  }
};

/** ====== ダミーデータ生成 ====== **/
function generateDummyRowsForHierarchyFull(labels, hierarchy) {
  let rows = [];
  const company = hierarchy["全社"];
  Object.entries(company).forEach(([department, corners]) => {
    Object.entries(corners).forEach(([corner, lines]) => {
      Object.entries(lines).forEach(([line, categories]) => {
        categories.forEach(category => {
          // 昨年実績
          rows.push({
            department,
            corner,
            line,
            category,
            series: "昨年実績",
            data: labels.map((_, i) => 100 + i * 10 + Math.floor(Math.random() * 10))
          });
          // 今期実績
          rows.push({
            department,
            corner,
            line,
            category,
            series: "今期実績",
            data: labels.map((_, i) => i < Math.floor(labels.length/2)
              ? 105 + i * 8 + Math.floor(Math.random() * 5)
              : null
            )
          });
          // 今期予測
          rows.push({
            department,
            corner,
            line,
            category,
            series: "今期予測",
            data: labels.map((_, i) => 110 + i * 9 + Math.floor(Math.random() * 5))
          });
        });
      });
    });
  });
  return rows;
}

/**
 * ====== 予測単位ごとの集約関数 ======
 * 通常の「昨年実績」「今期実績」「今期予測」はダミーデータ rows から集計。
 * + 追加で「傾向」「今期予測(手動)」「最終予測」の3シリーズ分をユーザー入力(state)から合成。
 */
function aggregateRowsByForecastTarget(
  rows,
  groupField,
  forecastTargets,
  trendCoefficients,
  manualForecasts
) {
  // 係数の設定（必要に応じて各シリーズの素の値に何らかの factor を掛ける想定）
  const factorMapping = {
    "売上": 1,
    "値下": 0.9,
    "値上": 1.1,
    "ロス": 0.05,
    "売上総利益": 1,
    "期末在庫": 1,
    "回転日数": 1
  };

  // 中間集計用
  let groups = {}; // groups[groupKey][series-forecastTarget] => { data: [...], series, forecastTarget }

  // ★★★ rows の「昨年実績」「今期実績」「今期予測」を集約
  rows.forEach(row => {
    const groupKey = groupField === "全社" ? "全社" : row[groupField];
    if (!groups[groupKey]) groups[groupKey] = {};

    forecastTargets.forEach(ft => {
      if (row.series === "昨年実績" || row.series === "今期実績" || row.series === "今期予測") {
        const key = row.series + "_" + ft;
        if (!groups[groupKey][key]) {
          groups[groupKey][key] = {
            series: row.series,
            forecastTarget: ft,
            data: Array(row.data.length).fill(0)
          };
        }
        const factor = factorMapping[ft] ?? 1;
        row.data.forEach((val, idx) => {
          const addVal = val == null ? 0 : (val * factor);
          groups[groupKey][key].data[idx] += addVal;
        });
      }
    });
  });

  // ★★★ 「傾向」シリーズをユーザー入力から追加
  Object.keys(groups).forEach(groupKey => {
    forecastTargets.forEach(ft => {
      const lastYearKey = "昨年実績_" + ft;
      if (!groups[groupKey][lastYearKey]) return;
      const lastYearData = groups[groupKey][lastYearKey].data;
      const newKey = "傾向_" + ft;
      groups[groupKey][newKey] = {
        series: "傾向",
        forecastTarget: ft,
        data: lastYearData.map((_, i) => {
          const userVal = trendCoefficients[groupKey]?.[ft]?.[i];
          return userVal != null ? userVal : 1; // デフォルトは1 (100%)
        })
      };
    });
  });

  // ★★★ 「今期予測(手動)」シリーズをユーザー入力から追加
  Object.keys(groups).forEach(groupKey => {
    forecastTargets.forEach(ft => {
      const manualKey = "今期予測(手動)_" + ft;
      const lastYearKey = "昨年実績_" + ft;
      const lengthRef = groups[groupKey][lastYearKey]?.data?.length ?? 0;
      // 実際の入力データ
      const arr = manualForecasts[groupKey]?.[ft] ?? [];
      // 長さを lastYearData と整合させる
      // => 入力していない箇所は null にして空欄に
      const filledArr = arr.length >= lengthRef
        ? arr.slice(0, lengthRef)
        : [...arr, ...Array(lengthRef - arr.length).fill(null)];

      groups[groupKey][manualKey] = {
        series: "今期予測(手動)",
        forecastTarget: ft,
        data: lengthRef > 0 ? filledArr : []
      };
    });
  });

  // ★★★ 「最終予測」シリーズを追加
  Object.keys(groups).forEach(groupKey => {
    forecastTargets.forEach(ft => {
      const currentForecastKey = "今期予測_" + ft;
      const trendKey = "傾向_" + ft;
      const manualKey = "今期予測(手動)_" + ft;

      // 必要なデータがあるかチェック
      if (groups[groupKey][currentForecastKey] && groups[groupKey][trendKey]) {
        const currentForecastData = groups[groupKey][currentForecastKey].data;
        const trendData = groups[groupKey][trendKey].data;
        const manualForecastData = groups[groupKey][manualKey]?.data || [];
        const finalKey = "最終予測_" + ft;

        groups[groupKey][finalKey] = {
          series: "最終予測",
          forecastTarget: ft,
          data: currentForecastData.map((val, i) => {
            const trendVal = trendData[i] ?? 1;
            const manualVal = manualForecastData[i];

            // 今期予測(手動)が 0以上で入力されていればそれを使用、null なら (今期予測 × 傾向)
            if (manualVal != null && !isNaN(manualVal) && manualVal >= 0) {
              return manualVal;
            } else {
              return (val ?? 0) * trendVal;
            }
          })
        };
      }
    });
  });

  // オブジェクト -> 配列へ
  let result = [];
  for (let groupKey in groups) {
    for (let seriesKey in groups[groupKey]) {
      const item = groups[groupKey][seriesKey];
      result.push({
        group: groupKey,
        series: item.series,
        forecastTarget: item.forecastTarget,
        data: item.data
      });
    }
  }
  return result;
}

/** 
 * MemoizedTextField
 * - localState を持ち、親からの value 変更時のみ再設定
 * - フォーカス時にテキスト全選択
 * - 矢印キー上下左右 + Enter で対応セルへ移動
 */
const MemoizedTextField = React.memo(({
  value,
  onBlur,
  onChange,
  isPercentage = false,
  position = { row: 0, col: 0 }
}) => {
  const [localValue, setLocalValue] = React.useState(value);

  // 外部からの value が変化した場合のみ localState に反映
  React.useEffect(() => {
    setLocalValue(value);
  }, [value]);

  const handleKeyDown = React.useCallback((e) => {
    const { row, col } = position;
    switch (e.key) {
      case 'ArrowUp':
        e.preventDefault();
        {
          const upInput = document.querySelector(`input[data-row="${row - 1}"][data-col="${col}"]`);
          if (upInput) upInput.focus();
        }
        break;
      case 'ArrowDown':
        e.preventDefault();
        {
          const downInput = document.querySelector(`input[data-row="${row + 1}"][data-col="${col}"]`);
          if (downInput) downInput.focus();
        }
        break;
      case 'ArrowLeft':
        e.preventDefault();
        {
          const leftInput = document.querySelector(`input[data-row="${row}"][data-col="${col - 1}"]`);
          if (leftInput) leftInput.focus();
        }
        break;
      case 'ArrowRight':
        e.preventDefault();
        {
          const rightInput = document.querySelector(`input[data-row="${row}"][data-col="${col + 1}"]`);
          if (rightInput) rightInput.focus();
        }
        break;
      case 'Enter':
        e.preventDefault();
        {
          const rightInput = document.querySelector(`input[data-row="${row}"][data-col="${col + 1}"]`);
          if (rightInput) rightInput.focus();
        }
        break;
      default:
        break;
    }
  }, [position]);

  const handleChange = React.useCallback((e) => {
    setLocalValue(e.target.value);
    onChange?.(e.target.value);
  }, [onChange]);

  const handleBlur = React.useCallback((e) => {
    onBlur?.(e.target.value);
  }, [onBlur]);

  // フォーカス時にテキストを全選択
  const handleFocus = React.useCallback((e) => {
    e.target.select();
  }, []);

  return (
    <TextField
      size="small"
      value={localValue}
      onChange={handleChange}
      onBlur={handleBlur}
      onFocus={handleFocus}
      onKeyDown={handleKeyDown}
      sx={{ width: 80 }}
      inputProps={{
        "data-row": position.row,
        "data-col": position.col,
        inputMode: "numeric",
        pattern: "[0-9]*"
      }}
      InputProps={{
        endAdornment: isPercentage ? <Typography variant="body2">%</Typography> : null
      }}
    />
  );
}, (prevProps, nextProps) => {
  // 値/位置/パーセント表示設定が同じなら再描画しない
  return (
    prevProps.value === nextProps.value &&
    prevProps.isPercentage === nextProps.isPercentage &&
    prevProps.position.row === nextProps.position.row &&
    prevProps.position.col === nextProps.position.col
  );
});

/** 
 * TableCellWithInput 
 * - シリーズ "傾向" と "今期予測(手動)" のときのみ入力可能
 * - 今期予測(手動) が null の場合は表示を空欄にする
 * - 傾向(%) が null の場合は "100.0" 表示
 */
const TableCellWithInput = React.memo(({
  rowIndex,
  colIndex,
  value,
  series,
  group,
  forecastTarget,
  onInputChange
}) => {
  const handleLocalChange = React.useCallback((newValue) => {
    // 入力途中の変更時には特に何もしない（ローカルStateを更新のみ）
  }, []);

  const handleLocalBlur = React.useCallback((finalValue) => {
    // blur時に親へ確定値を通知
    onInputChange?.(group, forecastTarget, series, colIndex, finalValue);
    // グラフ更新イベント
    window.dispatchEvent(new CustomEvent('updateChart'));
  }, [group, forecastTarget, series, colIndex, onInputChange]);

  // 表示用
  let displayValue = "";
  if (series === "傾向") {
    // 傾向がnull or undefined ならデフォルト 100%
    displayValue = (value != null)
      ? (value * 100).toFixed(1)
      : "100.0";
  } else if (series === "今期予測(手動)") {
    // null の場合は空欄
    displayValue = (value != null)
      ? String(value)
      : "";
  }

  return (
    <TableCell align="right">
      <MemoizedTextField
        value={displayValue}
        onChange={handleLocalChange}
        onBlur={handleLocalBlur}
        isPercentage={series === "傾向"}
        position={{ row: rowIndex, col: colIndex }}
      />
    </TableCell>
  );
}, (prevProps, nextProps) => {
  return (
    prevProps.value === nextProps.value &&
    prevProps.series === nextProps.series &&
    prevProps.rowIndex === nextProps.rowIndex &&
    prevProps.colIndex === nextProps.colIndex
  );
});

/** 
 * グラフ描画コンポーネント
 */
const ForecastChart = React.memo(({ periodLabels, chartData }) => {
  const chartRef = React.useRef(null);
  const canvasRef = React.useRef(null);
  const dataRef = React.useRef({ periodLabels, chartData });

  React.useEffect(() => {
    if (!canvasRef.current) return;

    // グラフの初期化は初回のみ
    if (!chartRef.current) {
      chartRef.current = new Chart(canvasRef.current.getContext('2d'), {
        type: 'line',
        data: {
          labels: periodLabels,
          datasets: chartData
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: { y: { beginAtZero: false } }
        }
      });
    }

    // データの参照だけ更新
    dataRef.current = { periodLabels, chartData };

    // unmount時
    return () => {
      if (chartRef.current) {
        chartRef.current.destroy();
        chartRef.current = null;
      }
    };
  }, [periodLabels, chartData]);

  // TextFieldのblur時にグラフを更新
  React.useEffect(() => {
    const handleUpdateChart = () => {
      if (chartRef.current) {
        const { periodLabels, chartData } = dataRef.current;
        chartRef.current.data.labels = periodLabels;
        chartRef.current.data.datasets = chartData;
        chartRef.current.update('none');
      }
    };
    window.addEventListener('updateChart', handleUpdateChart);
    return () => window.removeEventListener('updateChart', handleUpdateChart);
  }, []);

  return (
    <Box sx={{ position: 'relative', minHeight: '300px', width: '100%' }}>
      <canvas ref={canvasRef} style={{ width: '100%', height: '40vh' }} />
    </Box>
  );
}, (prevProps, nextProps) => {
  // データやラベルが変更されていない場合は再描画回避
  return (
    JSON.stringify(prevProps.chartData) === JSON.stringify(nextProps.chartData) &&
    JSON.stringify(prevProps.periodLabels) === JSON.stringify(nextProps.periodLabels)
  );
});

/** 
 * 文字列内の全角数字を半角に変換
 */
function toHalfWidth(str) {
  if (typeof str !== 'string') str = String(str);
  return str.replace(/[０-９]/g, (s) => {
    return String.fromCharCode(s.charCodeAt(0) - 0xFEE0);
  });
}

/** 
 * メインコンポーネント
 */
function App() {
  // 期間設定
  const [selectedPeriodUnit, setSelectedPeriodUnit] = React.useState("月");
  const [periodLabels, setPeriodLabels] = React.useState(getLabels(selectedPeriodUnit));

  React.useEffect(() => {
    setPeriodLabels(getLabels(selectedPeriodUnit));
  }, [selectedPeriodUnit]);

  const [recentPeriod, setRecentPeriod] = React.useState(60);
  const [forecastStart, setForecastStart] = React.useState("2025-06-01");
  const [forecastEnd, setForecastEnd] = React.useState("2025-08-31");

  // ダミーデータ生成
  const generatedDummyData = React.useMemo(() => {
    return generateDummyRowsForHierarchyFull(periodLabels, hierarchy);
  }, [periodLabels]);

  // 全予測対象
  const predictionTargets = ["売上", "値下", "値上", "ロス", "売上総利益", "期末在庫", "回転日数"];
  // グラフ表示時に選択中の予測対象
  const [selectedPredictionTargets, setSelectedPredictionTargets] = React.useState(new Set(["売上"]));

  // 表示モード（実数/構成比）
  const [displayMode, setDisplayMode] = React.useState("absolute");

  // 集約レベル
  const [selectedTab, setSelectedTab] = React.useState("全社");

  // 部門
  const allDepartments = Object.keys(hierarchy["全社"]);
  const [selectedDepartments, setSelectedDepartments] = React.useState(new Set(allDepartments));

  // コーナー
  const [selectedDepartmentCorner, setSelectedDepartmentCorner] = React.useState(allDepartments[0]);
  const cornersForDept = Object.keys(hierarchy["全社"][selectedDepartmentCorner] || {});
  const [selectedCorners, setSelectedCorners] = React.useState(new Set(cornersForDept));

  // ライン
  const [selectedDepartmentLine, setSelectedDepartmentLine] = React.useState(allDepartments[0]);
  const cornersForDeptLine = Object.keys(hierarchy["全社"][selectedDepartmentLine] || {});
  const [selectedCornerLine, setSelectedCornerLine] = React.useState(cornersForDeptLine[0]);
  const linesForCorner = Object.keys(hierarchy["全社"][selectedDepartmentLine]?.[selectedCornerLine] || {});
  const [selectedLines, setSelectedLines] = React.useState(new Set(linesForCorner));

  // カテゴリ
  const [selectedDepartmentCategory, setSelectedDepartmentCategory] = React.useState(allDepartments[0]);
  const cornersForDeptCat = Object.keys(hierarchy["全社"][selectedDepartmentCategory] || {});
  const [selectedCornerCategory, setSelectedCornerCategory] = React.useState(cornersForDeptCat[0]);
  const linesForCornerCat = Object.keys(hierarchy["全社"][selectedDepartmentCategory]?.[selectedCornerCategory] || {});
  const [selectedLineCategory, setSelectedLineCategory] = React.useState(linesForCornerCat[0]);
  const catsForLine = hierarchy["全社"][selectedDepartmentCategory]?.[selectedCornerCategory]?.[selectedLineCategory] || [];
  const [selectedCategories, setSelectedCategories] = React.useState(new Set(catsForLine));

  // ★★★ ユーザー入力を保持する state ★★★
  // 傾向用: trendCoefficients[group][forecastTarget][i] => number
  const [trendCoefficients, setTrendCoefficients] = React.useState(() => {
    const init = {};
    Object.keys(hierarchy["全社"]).forEach(dept => {
      init[dept] = {};
      predictionTargets.forEach(pt => {
        init[dept][pt] = Array(periodLabels.length).fill(1);
      });
    });
    return init;
  });

  // 今期予測(手動): manualForecasts[group][forecastTarget][i] => number or null
  const [manualForecasts, setManualForecasts] = React.useState({});

  // 入力値確定（blur）時のハンドラ
  const handleInputChange = React.useCallback((group, forecastTarget, series, index, rawValue) => {
    const value = toHalfWidth(rawValue);
    const numVal = parseFloat(value);

    // 今期予測(手動) か 傾向(%)
    if (series === "傾向") {
      if (!isNaN(numVal)) {
        setTrendCoefficients(prev => {
          const newObj = { ...prev };
          if (!newObj[group]) newObj[group] = {};
          if (!newObj[group][forecastTarget]) {
            newObj[group][forecastTarget] = Array(periodLabels.length).fill(1);
          }
          newObj[group][forecastTarget][index] = numVal / 100; // 100 -> 1
          return newObj;
        });
      }
    } else if (series === "今期予測(手動)") {
      // 手動予測が空文字 or 数値以外なら null とする
      const finalVal = (isNaN(numVal)) ? null : numVal;
      setManualForecasts(prev => {
        const newObj = { ...prev };
        if (!newObj[group]) newObj[group] = {};
        if (!newObj[group][forecastTarget]) {
          // まだ配列がなければ periodLabels 長さで全部 null
          newObj[group][forecastTarget] = Array(periodLabels.length).fill(null);
        }
        newObj[group][forecastTarget][index] = finalVal;
        return newObj;
      });
    }
  }, [periodLabels]);

  // 階層選択連動処理
  React.useEffect(() => {
    const newCorners = Object.keys(hierarchy["全社"][selectedDepartmentCorner] || {});
    setSelectedCorners(new Set(newCorners));
  }, [selectedDepartmentCorner]);

  React.useEffect(() => {
    const newCorners = Object.keys(hierarchy["全社"][selectedDepartmentLine] || {});
    setSelectedCornerLine(newCorners[0]);
  }, [selectedDepartmentLine]);

  React.useEffect(() => {
    const newLines = Object.keys(hierarchy["全社"][selectedDepartmentLine]?.[selectedCornerLine] || {});
    setSelectedLines(new Set(newLines));
  }, [selectedCornerLine, selectedDepartmentLine]);

  React.useEffect(() => {
    const newCorners = Object.keys(hierarchy["全社"][selectedDepartmentCategory] || {});
    setSelectedCornerCategory(newCorners[0]);
  }, [selectedDepartmentCategory]);

  React.useEffect(() => {
    const newLines = Object.keys(hierarchy["全社"][selectedDepartmentCategory]?.[selectedCornerCategory] || {});
    setSelectedLineCategory(newLines[0]);
  }, [selectedCornerCategory, selectedDepartmentCategory]);

  React.useEffect(() => {
    const newCats = hierarchy["全社"][selectedDepartmentCategory]?.[selectedCornerCategory]?.[selectedLineCategory] || [];
    setSelectedCategories(new Set(newCats));
  }, [selectedLineCategory, selectedCornerCategory, selectedDepartmentCategory]);

  // フィルタリング
  let filteredRows = generatedDummyData;
  if (selectedTab === "部門") {
    filteredRows = filteredRows.filter(r => selectedDepartments.has(r.department));
  } else if (selectedTab === "コーナー") {
    filteredRows = filteredRows.filter(r =>
      r.department === selectedDepartmentCorner &&
      selectedCorners.has(r.corner)
    );
  } else if (selectedTab === "ライン") {
    filteredRows = filteredRows.filter(r =>
      r.department === selectedDepartmentLine &&
      r.corner === selectedCornerLine &&
      selectedLines.has(r.line)
    );
  } else if (selectedTab === "カテゴリー") {
    filteredRows = filteredRows.filter(r =>
      r.department === selectedDepartmentCategory &&
      r.corner === selectedCornerCategory &&
      r.line === selectedLineCategory &&
      selectedCategories.has(r.category)
    );
  }

  // 集約処理
  const groupKeyField =
    selectedTab === "全社" ? "全社" :
    (selectedTab === "部門" ? "department"
      : (selectedTab === "コーナー" ? "corner"
        : (selectedTab === "ライン" ? "line" : "category")));

  // グラフ用：選択された予測対象のみ
  const aggregatedRowsGraph = React.useMemo(() => {
    return aggregateRowsByForecastTarget(
      filteredRows,
      groupKeyField,
      Array.from(selectedPredictionTargets),
      trendCoefficients,
      manualForecasts
    );
  }, [
    filteredRows,
    groupKeyField,
    selectedPredictionTargets,
    trendCoefficients,
    manualForecasts
  ]);

  // テーブル用：全予測対象
  const aggregatedRowsTable = React.useMemo(() => {
    return aggregateRowsByForecastTarget(
      filteredRows,
      groupKeyField,
      predictionTargets,
      trendCoefficients,
      manualForecasts
    );
  }, [
    filteredRows,
    groupKeyField,
    predictionTargets,
    trendCoefficients,
    manualForecasts
  ]);

  // グラフ用 dataset
  const aggregatedChartData = React.useMemo(() => {
    let colorIndex = 0;
    const colors = [
      "rgba(255,99,132,1)",
      "rgba(54,162,235,1)",
      "rgba(255,206,86,1)",
      "rgba(75,192,192,1)",
      "rgba(153,102,255,1)",
      "rgba(255,159,64,1)",
      "rgba(100,100,100,1)",
    ];
    return aggregatedRowsGraph.map(row => {
      const c = colors[colorIndex % colors.length];
      colorIndex++;
      return {
        label: `${row.group} (${row.series}-${row.forecastTarget})`,
        data: row.data,
        borderColor: c,
        backgroundColor: c.replace("1)", "0.2)"),
        tension: 0.2
      };
    });
  }, [aggregatedRowsGraph]);

  // テーブル表示用にソート
  const sortedTableRows = React.useMemo(() => {
    const order = {
      "売上": 0,
      "値下": 1,
      "値上": 2,
      "ロス": 3,
      "売上総利益": 4,
      "期末在庫": 5,
      "回転日数": 6
    };
    const seriesOrder = {
      "今期予測": 0,
      "今期実績": 1,
      "昨年実績": 2,
      "今期予測(手動)": 3,
      "傾向": 4,
      "最終予測": 5
    };
    return aggregatedRowsTable.slice().sort((a, b) => {
      if (a.forecastTarget !== b.forecastTarget) {
        return (order[a.forecastTarget] ?? 999) - (order[b.forecastTarget] ?? 999);
      }
      if (a.group !== b.group) {
        return a.group.localeCompare(b.group);
      }
      return (seriesOrder[a.series] ?? 999) - (seriesOrder[b.series] ?? 999);
    });
  }, [aggregatedRowsTable]);

  // テーブル本体
  let previousForecast = "";
  let previousGroup = "";
  const tableRows = [];

  sortedTableRows.forEach((row, i) => {
    // 予測対象ヘッダー
    if (row.forecastTarget !== previousForecast) {
      tableRows.push(
        <TableRow key={`header-forecast-${row.forecastTarget}`} className="group-header">
          <TableCell colSpan={4 + periodLabels.length}>
            予測対象：{row.forecastTarget}
          </TableCell>
        </TableRow>
      );
      previousForecast = row.forecastTarget;
      previousGroup = "";
    }

    // グループヘッダー (breadcrumb風)
    if (row.group !== previousGroup) {
      const getBreadcrumb = (grp) => {
        if (selectedTab === "全社") {
          return ["全社"];
        } else if (selectedTab === "部門") {
          return ["全社", grp];
        } else if (selectedTab === "コーナー") {
          return ["全社", selectedDepartmentCorner, grp];
        } else if (selectedTab === "ライン") {
          return ["全社", selectedDepartmentLine, selectedCornerLine, grp];
        } else {
          // "カテゴリー"
          return ["全社", selectedDepartmentCategory, selectedCornerCategory, selectedLineCategory, grp];
        }
      };
      const breadcrumbItems = getBreadcrumb(row.group);
      tableRows.push(
        <TableRow key={`header-group-${row.forecastTarget}-${row.group}`} className="group-header">
          <TableCell colSpan={4 + periodLabels.length} style={{ paddingLeft: '20px' }}>
            <Breadcrumbs aria-label="breadcrumb">
              {breadcrumbItems.map((item, idx) => (
                <Typography key={idx} color="text.primary" variant="body2">
                  {item}
                </Typography>
              ))}
            </Breadcrumbs>
          </TableCell>
        </TableRow>
      );
      previousGroup = row.group;
    }

    // 合計
    const rowTotal = row.data.reduce((sum, v) => sum + (v || 0), 0);

    // 通常の行
    tableRows.push(
      <TableRow key={`data-${i}`}>
        {/* 予測対象 */}
        <TableCell style={{ paddingLeft: '40px' }}>
          {row.forecastTarget}
        </TableCell>
        {/* グループ */}
        <TableCell>
          {row.group}
        </TableCell>
        {/* シリーズ */}
        <TableCell>
          {row.series}
        </TableCell>
        {/* 合計 */}
        <TableCell align="right">
          {displayMode === "absolute"
            ? (rowTotal ? rowTotal.toFixed(1) : "-")
            : (rowTotal ? "100.0%" : "0.0%")}
        </TableCell>

        {/* 各期間 */}
        {row.data.map((val, colIndex) => {
          if (displayMode === "absolute") {
            // 傾向 or 今期予測(手動) の場合は入力セル
            if (row.series === "傾向" || row.series === "今期予測(手動)") {
              return (
                <TableCellWithInput
                  key={`${i}-${colIndex}`}
                  rowIndex={i}       // テーブル上の行インデックス
                  colIndex={colIndex}
                  value={val}
                  series={row.series}
                  group={row.group}
                  forecastTarget={row.forecastTarget}
                  onInputChange={handleInputChange}
                />
              );
            } else {
              return (
                <TableCell key={`${i}-${colIndex}`} align="right">
                  {val != null ? val.toFixed(1) : "-"}
                </TableCell>
              );
            }
          } else {
            // 構成比表示
            const ratio = rowTotal ? (val / rowTotal * 100) : 0;
            return (
              <TableCell key={`${i}-${colIndex}`} align="right">
                {ratio.toFixed(1)}%
              </TableCell>
            );
          }
        })}
      </TableRow>
    );
  });

  return (
    <Container maxWidth={false} disableGutters sx={{ backgroundColor: '#f5f5f5', paddingBottom: 2 }}>
      {/* 上部エリア */}
      <Box sx={{ mb: 2 }}>
        <Box sx={{ p: 1, backgroundColor: '#fff', borderBottom: '1px solid #ccc' }}>
          <Typography variant="subtitle1" sx={{ fontWeight: 'bold' }}>
            予測対象Chipでグラフ切替、テーブルは全予測対象表示（傾向・今期予測(手動) は編集可）
          </Typography>
          <TextField
            label="直近期間（日）"
            type="number"
            value={recentPeriod}
            onChange={(e) => setRecentPeriod(e.target.value)}
            sx={{ width: '130px' }}
            size="small"
          />
          <TextField
            label="予測開始"
            type="date"
            value={forecastStart}
            onChange={(e) => setForecastStart(e.target.value)}
            InputLabelProps={{ shrink: true }}
            size="small"
          />
          <TextField
            label="予測終了"
            type="date"
            value={forecastEnd}
            onChange={(e) => setForecastEnd(e.target.value)}
            InputLabelProps={{ shrink: true }}
            size="small"
          />
          <TextField
            select
            label="期間単位"
            value={selectedPeriodUnit}
            onChange={(e) => setSelectedPeriodUnit(e.target.value)}
            sx={{ width: '100px' }}
            size="small"
          >
            {["年", "月", "週", "日", "時間"].map(unit => (
              <MenuItem key={unit} value={unit}>{unit}</MenuItem>
            ))}
          </TextField>
          <Button variant="contained" size="small" onClick={() => alert("傾向値計算(ダミー)")}>
            傾向値計算
          </Button>
        </Box>

        {/* 階層選択パネル */}
        <Box sx={{ p: 1, backgroundColor: '#fff', borderBottom: '1px solid #ccc' }}>
          <Typography variant="body1" gutterBottom>階層選択（集約レベル）</Typography>
          <Tabs
            value={selectedTab}
            onChange={(e, newVal) => setSelectedTab(newVal)}
            indicatorColor="primary"
            textColor="primary"
            variant="fullWidth"
            sx={{ minHeight: '36px' }}
          >
            {["全社", "部門", "コーナー", "ライン", "カテゴリー"].map(level => (
              <Tab key={level} label={level} value={level} sx={{ minHeight: '36px' }} />
            ))}
          </Tabs>
          <Box sx={{ mt: 1, display: 'flex', gap: 1, flexWrap: 'wrap' }}>
            {selectedTab === "全社" && (
              <Chip label="全社" color="primary" />
            )}
            {selectedTab === "部門" && (
              allDepartments.map(dep => (
                <Chip
                  key={dep}
                  label={dep}
                  variant={selectedDepartments.has(dep) ? "filled" : "outlined"}
                  color={selectedDepartments.has(dep) ? "primary" : "default"}
                  size="small"
                  onClick={() => {
                    const newSet = new Set(selectedDepartments);
                    if (newSet.has(dep)) newSet.delete(dep); else newSet.add(dep);
                    setSelectedDepartments(newSet);
                  }}
                />
              ))
            )}
            {selectedTab === "コーナー" && (
              <>
                <Box>
                  <Typography variant="subtitle2">部門</Typography>
                  {allDepartments.map(dep => (
                    <Chip
                      key={dep}
                      onClick={() => setSelectedDepartmentCorner(dep)}
                      label={dep}
                      variant={dep === selectedDepartmentCorner ? "filled" : "outlined"}
                      color={dep === selectedDepartmentCorner ? "primary" : "default"}
                      size="small"
                    />
                  ))}
                </Box>
                <Box>
                  <Typography variant="subtitle2">コーナー</Typography>
                  {Object.keys(hierarchy["全社"][selectedDepartmentCorner]).map(crn => (
                    <Chip
                      key={crn}
                      label={crn}
                      variant={selectedCorners.has(crn) ? "filled" : "outlined"}
                      color={selectedCorners.has(crn) ? "primary" : "default"}
                      size="small"
                      onClick={() => {
                        const newSet = new Set(selectedCorners);
                        if (newSet.has(crn)) newSet.delete(crn); else newSet.add(crn);
                        setSelectedCorners(newSet);
                      }}
                    />
                  ))}
                </Box>
              </>
            )}
            {selectedTab === "ライン" && (
              <>
                <Box>
                  <Typography variant="subtitle2">部門</Typography>
                  {allDepartments.map(dep => (
                    <Chip
                      key={dep}
                      onClick={() => setSelectedDepartmentLine(dep)}
                      label={dep}
                      variant={dep === selectedDepartmentLine ? "filled" : "outlined"}
                      color={dep === selectedDepartmentLine ? "primary" : "default"}
                      size="small"
                    />
                  ))}
                </Box>
                <Box>
                  <Typography variant="subtitle2">コーナー</Typography>
                  {Object.keys(hierarchy["全社"][selectedDepartmentLine]).map(crn => (
                    <Chip
                      key={crn}
                      onClick={() => setSelectedCornerLine(crn)}
                      label={crn}
                      variant={crn === selectedCornerLine ? "filled" : "outlined"}
                      color={crn === selectedCornerLine ? "primary" : "default"}
                      size="small"
                    />
                  ))}
                </Box>
                <Box>
                  <Typography variant="subtitle2">ライン</Typography>
                  {Object.keys(hierarchy["全社"][selectedDepartmentLine][selectedCornerLine]).map(ln => (
                    <Chip
                      key={ln}
                      label={ln}
                      variant={selectedLines.has(ln) ? "filled" : "outlined"}
                      color={selectedLines.has(ln) ? "primary" : "default"}
                      size="small"
                      onClick={() => {
                        const newSet = new Set(selectedLines);
                        if (newSet.has(ln)) newSet.delete(ln); else newSet.add(ln);
                        setSelectedLines(newSet);
                      }}
                    />
                  ))}
                </Box>
              </>
            )}
            {selectedTab === "カテゴリー" && (
              <>
                <Box>
                  <Typography variant="subtitle2">部門</Typography>
                  {allDepartments.map(dep => (
                    <Chip
                      key={dep}
                      label={dep}
                      variant={dep === selectedDepartmentCategory ? "filled" : "outlined"}
                      color={dep === selectedDepartmentCategory ? "primary" : "default"}
                      size="small"
                      onClick={() => setSelectedDepartmentCategory(dep)}
                    />
                  ))}
                </Box>
                <Box>
                  <Typography variant="subtitle2">コーナー</Typography>
                  {Object.keys(hierarchy["全社"][selectedDepartmentCategory]).map(crn => (
                    <Chip
                      key={crn}
                      label={crn}
                      variant={crn === selectedCornerCategory ? "filled" : "outlined"}
                      color={crn === selectedCornerCategory ? "primary" : "default"}
                      size="small"
                      onClick={() => setSelectedCornerCategory(crn)}
                    />
                  ))}
                </Box>
                <Box>
                  <Typography variant="subtitle2">ライン</Typography>
                  {Object.keys(hierarchy["全社"][selectedDepartmentCategory][selectedCornerCategory]).map(ln => (
                    <Chip
                      key={ln}
                      label={ln}
                      variant={ln === selectedLineCategory ? "filled" : "outlined"}
                      color={ln === selectedLineCategory ? "primary" : "default"}
                      size="small"
                      onClick={() => setSelectedLineCategory(ln)}
                    />
                  ))}
                </Box>
                <Box>
                  <Typography variant="subtitle2">カテゴリー</Typography>
                  {(hierarchy["全社"][selectedDepartmentCategory][selectedCornerCategory][selectedLineCategory] || []).map(ct => (
                    <Chip
                      key={ct}
                      label={ct}
                      variant={selectedCategories.has(ct) ? "filled" : "outlined"}
                      color={selectedCategories.has(ct) ? "primary" : "default"}
                      size="small"
                      onClick={() => {
                        const newSet = new Set(selectedCategories);
                        if (newSet.has(ct)) newSet.delete(ct); else newSet.add(ct);
                        setSelectedCategories(newSet);
                      }}
                    />
                  ))}
                </Box>
              </>
            )}
          </Box>
        </Box>

        {/* 予測対象Chip（グラフ表示切替） */}
        <Box sx={{ p: 1, backgroundColor: '#fff', borderBottom: '1px solid #ccc' }}>
          <Typography variant="body1" gutterBottom>予測対象（グラフ表示切替）</Typography>
          <Box sx={{ display: 'flex', gap: 1, flexWrap: 'wrap' }}>
            {predictionTargets.map(pt => {
              const selected = selectedPredictionTargets.has(pt);
              return (
                <Chip
                  key={pt}
                  label={pt}
                  variant={selected ? "filled" : "outlined"}
                  color={selected ? "primary" : "default"}
                  size="small"
                  onClick={() => {
                    const newSet = new Set(selectedPredictionTargets);
                    if (selected) newSet.delete(pt); else newSet.add(pt);
                    setSelectedPredictionTargets(newSet);
                  }}
                />
              );
            })}
          </Box>
        </Box>

        {/* 表示切替トグルボタン（実数/構成比） */}
        <Box sx={{ p: 1, backgroundColor: '#fff', borderBottom: '1px solid #ccc', textAlign: 'right' }}>
          <ToggleButtonGroup
            value={displayMode}
            exclusive
            onChange={(e, newMode) => { if(newMode) setDisplayMode(newMode); }}
            size="small"
          >
            <ToggleButton value="absolute">実数表示</ToggleButton>
            <ToggleButton value="ratio">構成比表示</ToggleButton>
          </ToggleButtonGroup>
        </Box>
      </Box>

      {/* 下部エリア：グラフとテーブル */}
      <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
        {/* グラフエリア */}
        <Box sx={{ p: 1 }}>
          <Paper sx={{ p: 1, minHeight: '200px' }}>
            <Typography variant="body1" gutterBottom>
              グラフ（Chipで選択された予測対象のみ表示）<br/>
              傾向・今期予測(手動) などを含めたい場合はChipをクリックしてください。
            </Typography>
            <ForecastChart
              periodLabels={periodLabels}
              chartData={aggregatedChartData}
            />
          </Paper>
        </Box>

        {/* テーブル */}
        <Box sx={{ p: 1 }}>
          <Paper sx={{ p: 1, display: 'flex', flexDirection: 'column' }}>
            <Typography variant="body1" gutterBottom>
              予測結果テーブル（全予測対象でグループ化）<br />
              （グループ表示順：予測対象 → 集約キー → シリーズ）<br />
              合計列を4列目に表示し、<br/>
              「傾向」「今期予測(手動)」「最終予測」は入力欄で数値を更新できます。<br/>
              ※ 今期予測(手動) が空欄の場合は「(今期予測 × 傾向)」を最終予測に反映、<br/>
              &emsp;0以上が入力されていれば手動値を最優先します。
            </Typography>
            <TableContainer sx={{ '& td, & th': { whiteSpace: 'nowrap' } }}>
              <Table size="small" sx={{ '& .MuiTableCell-root': { py: 0.25, px: 1 } }}>
                <TableHead>
                  <TableRow>
                    <TableCell sx={{ backgroundColor: 'silver', borderRight: '1px solid #ccc', minWidth: 80 }}>
                      予測対象
                    </TableCell>
                    <TableCell sx={{ backgroundColor: 'silver', borderRight: '1px solid #ccc', minWidth: 60 }}>
                      集約キー
                    </TableCell>
                    <TableCell sx={{ backgroundColor: 'silver', borderRight: '1px solid #ccc', minWidth: 80 }}>
                      シリーズ
                    </TableCell>
                    <TableCell sx={{ backgroundColor: 'silver', borderRight: '1px solid #ccc', minWidth: 60 }} align="right">
                      合計
                    </TableCell>
                    {periodLabels.map(label => (
                      <TableCell
                        key={label}
                        align="right"
                        sx={{ backgroundColor: 'silver', borderRight: '1px solid #ccc', minWidth: 60 }}
                      >
                        {label}
                      </TableCell>
                    ))}
                  </TableRow>
                </TableHead>
                <TableBody>
                  {tableRows}
                </TableBody>
              </Table>
            </TableContainer>
          </Paper>
        </Box>
      </Box>
    </Container>
  );
}

ReactDOM.render(<App />, document.getElementById("root"));
</script>
</body>
</html>
