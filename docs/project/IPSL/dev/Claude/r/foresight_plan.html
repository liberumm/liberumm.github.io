<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>全要件網羅サンプル UI (期間単位・タブ・Chip)</title>

  <!-- React, ReactDOM, Babel -->
  <script src="https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.production.min.js" crossorigin></script>
  <script src="https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://cdn.jsdelivr.net/npm/@babel/standalone@7.23.8/babel.min.js"></script>

  <!-- Emotion (MUI依存) -->
  <script src="https://cdn.jsdelivr.net/npm/@emotion/react@11.11.3/dist/emotion-react.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@emotion/styled@11.11.0/dist/emotion-styled.umd.min.js"></script>

  <!-- MUI Core & Roboto -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" />
  <script src="https://cdn.jsdelivr.net/npm/@mui/material@5.15.3/umd/material-ui.production.min.js" crossorigin></script>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <!-- D3.js -->
  <script src="https://d3js.org/d3.v6.min.js"></script>

  <!-- xlsx (Excelライブラリ) -->
  <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js" defer></script>

  <!-- Material Icons -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons"/>
  
  <style>
    body { margin: 0; padding: 0; }
  </style>
</head>
<body>
<div id="root"></div>
<script type="text/babel">

const {
  Container, Box, Typography, Paper, Chip, Button,
  TextField, MenuItem, Tabs, Tab, Table, TableBody,
  TableCell, TableContainer, TableHead, TableRow
} = window['MaterialUI'];

/** ====== 期間ラベル生成関数 ====== **/
function getLabels(unit) {
  if(unit === "年") {
    return ["2024年", "2025年", "2026年"];
  } else if(unit === "月") {
    let arr = [];
    for(let i = 1; i <= 14; i++){
      arr.push(`${i}月`);
    }
    return arr;
  } else if(unit === "週") {
    let arr = [];
    for(let i = 1; i <= 56; i++){
      arr.push(`${i}週`);
    }
    return arr;
  } else if(unit === "日") {
    let arr = [];
    let start = new Date("2025-04-16");
    let end = new Date("2025-06-15");
    for(let d = new Date(start); d <= end; d.setDate(d.getDate()+1)) {
      let m = d.getMonth() + 1;
      let day = d.getDate();
      arr.push(`${m}/${day}`);
    }
    return arr;
  } else if(unit === "時間") {
    let arr = [];
    for(let i = 0; i < 24; i++){
      arr.push(`${i}時`);
    }
    return arr;
  }
  return [];
}

/** ====== ダミーデータ生成 ====== **/
function generateDummyRows(labels, classification, targets) {
  let rows = [];
  const n = labels.length;
  targets.forEach(target => {
    // 昨年実績：全期間データ
    rows.push({
      classification,
      target,
      series: "昨年実績",
      data: labels.map((_, i) => 100 + i * 10 + Math.floor(Math.random()*10))
    });
    // 今期実績：実績期間（前半）のみ、残りは null
    rows.push({
      classification,
      target,
      series: "今期実績",
      data: labels.map((_, i) => i < Math.floor(n/2) ? 105 + i * 8 + Math.floor(Math.random()*5) : null)
    });
    // 今期予測：全期間の予測値（実績期間も含む）
    rows.push({
      classification,
      target,
      series: "今期予測",
      data: labels.map((_, i) => 110 + i * 9 + Math.floor(Math.random()*5))
    });
  });
  return rows;
}

/** ====== 分類タイプ・表示対象 ====== **/
// 分類タイプ（タブ用）と、その対象リスト
const classificationOptions = {
  "全社": ["全社"],
  "部門": ["営業部", "開発部", "管理部"],
  "コーナー": ["Aコーナー", "Bコーナー", "Cコーナー"],
  "ライン": ["ライン1", "ライン2", "ライン3"],
  "カテゴリー": ["カテゴリX", "カテゴリY", "カテゴリZ"]
};

/** ====== 2. メインコンポーネント ====== **/
function App() {
  // 期間単位選択
  const [selectedPeriodUnit, setSelectedPeriodUnit] = React.useState("月");
  const [periodLabels, setPeriodLabels] = React.useState(getLabels(selectedPeriodUnit));
  
  React.useEffect(() => {
    setPeriodLabels(getLabels(selectedPeriodUnit));
  }, [selectedPeriodUnit]);

  // 過去データ・予測条件
  const [recentPeriod, setRecentPeriod] = React.useState(60);
  const [forecastStart, setForecastStart] = React.useState("2025-06-01");
  const [forecastEnd, setForecastEnd] = React.useState("2025-08-31");
  
  // 分類タイプ（タブで排他的選択）
  const classificationTypes = Object.keys(classificationOptions);
  const [selectedClassificationType, setSelectedClassificationType] = React.useState("全社");
  
  // 選択された分類タイプに基づく表示対象（Chip用）【初期は全て選択】
  const [selectedTargets, setSelectedTargets] = React.useState(new Set(classificationOptions["全社"]));
  React.useEffect(() => {
    setSelectedTargets(new Set(classificationOptions[selectedClassificationType]));
  }, [selectedClassificationType]);

  // dummyData生成（全分類、全期間のデータ）
  const generatedDummyData = React.useMemo(() => {
    let data = [];
    classificationTypes.forEach(type => {
      data = data.concat(generateDummyRows(periodLabels, type, classificationOptions[type]));
    });
    return data;
  }, [periodLabels]);

  // Chart.js用データ：フィルタリング（選択された分類タイプ＆Chip対象）
  const filteredChartData = React.useMemo(() => {
    const filtered = generatedDummyData.filter(row =>
      row.classification === selectedClassificationType &&
      selectedTargets.has(row.target)
    );
    let colorIndex = 0;
    const colors = [
      "rgba(255,99,132,1)",
      "rgba(54,162,235,1)",
      "rgba(255,206,86,1)",
      "rgba(75,192,192,1)",
      "rgba(153,102,255,1)",
      "rgba(255,159,64,1)"
    ];
    return filtered.map(row => {
      const color = colors[colorIndex++ % colors.length];
      return {
        label: `${row.target}(${row.series})`,
        data: row.data.map(v => (v === null ? NaN : v)),
        borderColor: color,
        backgroundColor: color.replace("1)", "0.2)"),
        tension: 0.2,
        hidden: false,
      };
    });
  }, [generatedDummyData, selectedClassificationType, selectedTargets]);

  // Chart.jsの初期化/更新用
  const [chartInstance, setChartInstance] = React.useState(null);
  const chartRef = React.useRef(null);
  React.useEffect(() => {
    if (!chartInstance) {
      const ctx = document.getElementById("myChart").getContext("2d");
      const newChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: periodLabels,
          datasets: filteredChartData
        },
        options: { responsive: true, scales: { y: { beginAtZero: false } } }
      });
      setChartInstance(newChart);
    } else {
      chartInstance.data.labels = periodLabels;
      chartInstance.data.datasets = filteredChartData;
      chartInstance.update();
    }
  }, [filteredChartData, periodLabels, chartInstance]);

  // テーブル用データ：フィルタリング
  const filteredTableRows = generatedDummyData.filter(row =>
    row.classification === selectedClassificationType &&
    selectedTargets.has(row.target)
  );

  // 手動調整ダミー処理
  const handleManualAdjust = () => {
    alert("手動調整(再計算)の処理はダミーです。");
  };

  // アクションボタンのダミー処理
  const handleAction = (actionName) => {
    alert(`${actionName}ボタンが押されました。(ダミー)`);
  };

  return (
    <Container maxWidth={false} disableGutters sx={{ backgroundColor:'#f5f5f5' }}>
      
      {/* ヘッダー */}
      <Box sx={{ p:2, backgroundColor:'#fff', borderBottom:'1px solid #ccc' }}>
        <Typography variant="h5" sx={{ fontWeight:'bold' }}>
          全要件網羅サンプル UI
        </Typography>
      </Box>
      
      {/* [1] 過去データ & 予測条件パネル */}
      <Box sx={{ p:2, backgroundColor:'#fff', borderBottom:'1px solid #ccc' }}>
        <Typography variant="h6" gutterBottom>過去データ & 予測条件 設定</Typography>
        <Box sx={{ display:'flex', gap:2, flexWrap:'wrap', mb:2 }}>
          <TextField
            label="直近期間（日）"
            type="number"
            value={recentPeriod}
            onChange={(e) => setRecentPeriod(e.target.value)}
            sx={{ width:'150px' }}
          />
          <TextField
            label="予測開始"
            type="date"
            value={forecastStart}
            onChange={(e) => setForecastStart(e.target.value)}
            InputLabelProps={{ shrink:true }}
          />
          <TextField
            label="予測終了"
            type="date"
            value={forecastEnd}
            onChange={(e) => setForecastEnd(e.target.value)}
            InputLabelProps={{ shrink:true }}
          />
          <TextField
            select
            label="期間単位"
            value={selectedPeriodUnit}
            onChange={(e) => setSelectedPeriodUnit(e.target.value)}
            sx={{ width:'150px' }}
          >
            {["年","月","週","日","時間"].map(unit => (
              <MenuItem key={unit} value={unit}>{unit}</MenuItem>
            ))}
          </TextField>
          <Button variant="contained" onClick={() => alert("傾向値計算(ダミー)")}>
            傾向値計算
          </Button>
        </Box>
      </Box>
      
      {/* [2] 分類タイプタブ */}
      <Box sx={{ backgroundColor:'#fff', borderBottom:'1px solid #ccc' }}>
        <Tabs
          value={selectedClassificationType}
          onChange={(e, newValue) => setSelectedClassificationType(newValue)}
          indicatorColor="primary"
          textColor="primary"
          variant="fullWidth"
        >
          {classificationTypes.map(type => (
            <Tab key={type} label={type} value={type} />
          ))}
        </Tabs>
      </Box>
      
      {/* [3] 表示対象選択（Chip） */}
      <Box sx={{ p:2, backgroundColor:'#fff', borderBottom:'1px solid #ccc' }}>
        <Typography variant="h6" gutterBottom>
          表示対象選択（{selectedClassificationType}）
        </Typography>
        <Box sx={{ display:'flex', gap:1, flexWrap:'wrap' }}>
          {classificationOptions[selectedClassificationType].map(target => {
            const selected = selectedTargets.has(target);
            return (
              <Chip
                key={target}
                label={target}
                variant={selected ? "filled" : "outlined"}
                color={selected ? "primary" : "default"}
                onClick={() => {
                  const newSet = new Set(selectedTargets);
                  if(newSet.has(target)) newSet.delete(target);
                  else newSet.add(target);
                  setSelectedTargets(newSet);
                }}
              />
            );
          })}
        </Box>
      </Box>
      
      {/* [4] グラフエリア */}
      <Box sx={{ p:2 }}>
        <Paper sx={{ p:2 }}>
          <Typography variant="h6" gutterBottom>
            グラフ (昨年実績・今期実績・今期予測)
          </Typography>
          <canvas id="myChart" style={{ width:'100%', height:'300px' }}></canvas>
        </Paper>
      </Box>
      
      {/* [5] 予測結果テーブル（X軸＝期間） */}
      <Box sx={{ p:2 }}>
        <Paper sx={{ p:2 }}>
          <Typography variant="h6" gutterBottom>
            予測結果テーブル (期間を列見出し)
          </Typography>
          <TableContainer>
            <Table size="small">
              <TableHead>
                <TableRow>
                  <TableCell>分類</TableCell>
                  <TableCell>対象</TableCell>
                  <TableCell>シリーズ</TableCell>
                  {periodLabels.map(label => (
                    <TableCell key={label} align="right">{label}</TableCell>
                  ))}
                </TableRow>
              </TableHead>
              <TableBody>
                {filteredTableRows.map((row, idx) => (
                  <TableRow key={idx}>
                    <TableCell>{row.classification}</TableCell>
                    <TableCell>{row.target}</TableCell>
                    <TableCell>{row.series}</TableCell>
                    {row.data.map((val, i) => (
                      <TableCell key={i} align="right">{val ?? "-"}</TableCell>
                    ))}
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </TableContainer>
        </Paper>
      </Box>
      
      {/* [6] 手動調整パネル */}
      <Box sx={{ p:2 }}>
        <Paper sx={{ p:2 }}>
          <Typography variant="h6" gutterBottom>
            手動調整パネル
          </Typography>
          <Box sx={{ display:'flex', gap:2, flexWrap:'wrap', mb:2 }}>
            {/* 選択された対象ごとに例として6番目の予測値を入力 */}
            {Array.from(selectedTargets).map(target => (
              <TextField
                key={target}
                label={`${target}(${selectedPeriodUnit}予測例)`}
                type="number"
                defaultValue={100}  // ダミー値
                sx={{ width:'150px' }}
              />
            ))}
          </Box>
          <Box>
            <Button variant="outlined" sx={{ mr:1 }}>合計固定</Button>
            <Button variant="outlined" sx={{ mr:1 }}>合計可変</Button>
            <Button variant="contained" color="secondary" onClick={handleManualAdjust}>
              再計算
            </Button>
          </Box>
        </Paper>
      </Box>
      
      {/* [7] アクションボタンバー */}
      <Box sx={{ p:2, textAlign:'right' }}>
        <Button variant="outlined" sx={{ mr:1 }} onClick={()=>handleAction("リセット")}>リセット</Button>
        <Button variant="contained" color="primary" sx={{ mr:1 }} onClick={()=>handleAction("適用")}>適用</Button>
        <Button variant="outlined" sx={{ mr:1 }} onClick={()=>handleAction("エクスポート")}>エクスポート</Button>
        <Button variant="outlined" color="secondary" onClick={()=>handleAction("自動調整")}>自動調整</Button>
      </Box>
      
    </Container>
  );
}

ReactDOM.render(<App />, document.getElementById("root"));
</script>
</body>
</html>
