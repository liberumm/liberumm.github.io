<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>全要件網羅サンプル UI (ページ全体スクロール)</title>

  <!-- React, ReactDOM, Babel -->
  <script src="https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.production.min.js" crossorigin></script>
  <script src="https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://cdn.jsdelivr.net/npm/@babel/standalone@7.23.8/babel.min.js"></script>

  <!-- Emotion (MUI依存) -->
  <script src="https://cdn.jsdelivr.net/npm/@emotion/react@11.11.3/dist/emotion-react.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@emotion/styled@11.11.0/dist/emotion-styled.umd.min.js"></script>

  <!-- MUI Core & Roboto -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" />
  <script src="https://cdn.jsdelivr.net/npm/@mui/material@5.15.3/umd/material-ui.production.min.js" crossorigin></script>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <!-- D3.js (未使用) -->
  <script src="https://d3js.org/d3.v6.min.js"></script>

  <!-- xlsx (未使用) -->
  <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js" defer></script>

  <!-- Material Icons (未使用) -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons"/>
  
  <style>
    body { margin: 0; padding: 0; }
  </style>
</head>
<body>
<div id="root"></div>
<script type="text/babel">

const {
  Container, Box, Typography, Paper, Chip, Button,
  TextField, MenuItem, Tabs, Tab, Table, TableBody,
  TableCell, TableContainer, TableHead, TableRow
} = window['MaterialUI'];

/** ====== 期間ラベル生成関数 ====== **/
function getLabels(unit) {
  if (unit === "年") {
    return ["2024年", "2025年", "2026年"];
  } else if (unit === "月") {
    let arr = [];
    for(let i = 1; i <= 14; i++){
      arr.push(`${i}月`);
    }
    return arr;
  } else if (unit === "週") {
    let arr = [];
    for(let i = 1; i <= 56; i++){
      arr.push(`${i}週`);
    }
    return arr;
  } else if (unit === "日") {
    let arr = [];
    let start = new Date("2025-04-16");
    let end = new Date("2025-06-15");
    for(let d = new Date(start); d <= end; d.setDate(d.getDate()+1)) {
      let m = d.getMonth() + 1;
      let day = d.getDate();
      arr.push(`${m}/${day}`);
    }
    return arr;
  } else if (unit === "時間") {
    let arr = [];
    for(let i = 0; i < 24; i++){
      arr.push(`${i}時`);
    }
    return arr;
  }
  return [];
}

/** ====== ダミーデータ生成 ====== **/
function generateDummyRows(labels, classification, targets) {
  let rows = [];
  targets.forEach(target => {
    // 昨年実績：全期間の実績データ
    rows.push({
      classification,
      target,
      series: "昨年実績",
      data: labels.map((_, i) => 100 + i * 10 + Math.floor(Math.random()*10))
    });
    // 今期実績：期間の前半のみ、後半は null
    rows.push({
      classification,
      target,
      series: "今期実績",
      data: labels.map((_, i) => i < Math.floor(labels.length/2) ? 105 + i * 8 + Math.floor(Math.random()*5) : null)
    });
    // 今期予測：全期間に対して予測値
    rows.push({
      classification,
      target,
      series: "今期予測",
      data: labels.map((_, i) => 110 + i * 9 + Math.floor(Math.random()*5))
    });
  });
  return rows;
}

/** ====== 分類タイプ・表示対象 ====== **/
const classificationOptions = {
  "全社": ["全社"],
  "部門": ["営業部", "開発部", "管理部"],
  "コーナー": ["Aコーナー", "Bコーナー", "Cコーナー"],
  "ライン": ["ライン1", "ライン2", "ライン3"],
  "カテゴリー": ["カテゴリX", "カテゴリY", "カテゴリZ"]
};

function App() {
  // 期間単位選択
  const [selectedPeriodUnit, setSelectedPeriodUnit] = React.useState("月");
  const [periodLabels, setPeriodLabels] = React.useState(getLabels(selectedPeriodUnit));
  React.useEffect(() => {
    setPeriodLabels(getLabels(selectedPeriodUnit));
  }, [selectedPeriodUnit]);

  // 過去データ・予測条件
  const [recentPeriod, setRecentPeriod] = React.useState(60);
  const [forecastStart, setForecastStart] = React.useState("2025-06-01");
  const [forecastEnd, setForecastEnd] = React.useState("2025-08-31");
  
  // 分類タイプ（タブ）
  const classificationTypes = Object.keys(classificationOptions);
  const [selectedClassificationType, setSelectedClassificationType] = React.useState("全社");
  
  // 表示対象（Chip用）
  const [selectedTargets, setSelectedTargets] = React.useState(new Set(classificationOptions["全社"]));
  React.useEffect(() => {
    setSelectedTargets(new Set(classificationOptions[selectedClassificationType]));
  }, [selectedClassificationType]);

  // ダミーデータ生成
  const generatedDummyData = React.useMemo(() => {
    let data = [];
    classificationTypes.forEach(type => {
      data = data.concat(generateDummyRows(periodLabels, type, classificationOptions[type]));
    });
    return data;
  }, [periodLabels]);

  // グラフ用データ
  const filteredChartData = React.useMemo(() => {
    const filtered = generatedDummyData.filter(row =>
      row.classification === selectedClassificationType &&
      selectedTargets.has(row.target)
    );
    let colorIndex = 0;
    const colors = [
      "rgba(255,99,132,1)",
      "rgba(54,162,235,1)",
      "rgba(255,206,86,1)",
      "rgba(75,192,192,1)",
      "rgba(153,102,255,1)",
      "rgba(255,159,64,1)"
    ];
    return filtered.map(row => {
      const color = colors[colorIndex++ % colors.length];
      return {
        label: `${row.target}(${row.series})`,
        data: row.data.map(v => (v === null ? NaN : v)),
        borderColor: color,
        backgroundColor: color.replace("1)", "0.2)"),
        tension: 0.2,
        hidden: false,
      };
    });
  }, [generatedDummyData, selectedClassificationType, selectedTargets]);

  // Chart.js 初期化/更新
  const [chartInstance, setChartInstance] = React.useState(null);
  React.useEffect(() => {
    const ctx = document.getElementById("myChart").getContext("2d");
    if (!chartInstance) {
      const newChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: periodLabels,
          datasets: filteredChartData
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: { y: { beginAtZero: false } }
        }
      });
      setChartInstance(newChart);
    } else {
      chartInstance.data.labels = periodLabels;
      chartInstance.data.datasets = filteredChartData;
      chartInstance.update();
    }
  }, [filteredChartData, periodLabels]);

  // テーブル用
  const filteredTableRows = generatedDummyData.filter(row =>
    row.classification === selectedClassificationType &&
    selectedTargets.has(row.target)
  );

  return (
    <Container 
      maxWidth={false} 
      disableGutters 
      sx={{ 
        backgroundColor:'#f5f5f5',
        paddingBottom: 2
      }}
    >
      {/* 上部エリア */}
      <Box sx={{ mb: 2 }}>
        {/* ヘッダー */}
        <Box sx={{ 
          p:1, 
          backgroundColor:'#fff', 
          borderBottom:'1px solid #ccc'
        }}>
          <Typography variant="subtitle1" sx={{ fontWeight:'bold' }}>
            全要件網羅サンプル UI
          </Typography>
        </Box>

        {/* [1] 過去データ & 予測条件パネル */}
        <Box sx={{ 
          p:1, 
          backgroundColor:'#fff', 
          borderBottom:'1px solid #ccc'
        }}>
          <Typography variant="body1" gutterBottom>過去データ & 予測条件</Typography>
          <Box sx={{ display:'flex', gap:1, flexWrap:'wrap', mb:1 }}>
            <TextField
              label="直近期間（日）"
              type="number"
              value={recentPeriod}
              onChange={(e) => setRecentPeriod(e.target.value)}
              sx={{ width:'130px' }}
              size="small"
            />
            <TextField
              label="予測開始"
              type="date"
              value={forecastStart}
              onChange={(e) => setForecastStart(e.target.value)}
              InputLabelProps={{ shrink:true }}
              size="small"
            />
            <TextField
              label="予測終了"
              type="date"
              value={forecastEnd}
              onChange={(e) => setForecastEnd(e.target.value)}
              InputLabelProps={{ shrink:true }}
              size="small"
            />
            <TextField
              select
              label="期間単位"
              value={selectedPeriodUnit}
              onChange={(e) => setSelectedPeriodUnit(e.target.value)}
              sx={{ width:'100px' }}
              size="small"
            >
              {["年","月","週","日","時間"].map(unit => (
                <MenuItem key={unit} value={unit}>{unit}</MenuItem>
              ))}
            </TextField>
            <Button variant="contained" size="small" onClick={() => alert("傾向値計算(ダミー)")}>
              傾向値計算
            </Button>
          </Box>
        </Box>

        {/* [2] 分類タイプタブ */}
        <Box sx={{ backgroundColor:'#fff', borderBottom:'1px solid #ccc' }}>
          <Tabs
            value={selectedClassificationType}
            onChange={(e, newValue) => setSelectedClassificationType(newValue)}
            indicatorColor="primary"
            textColor="primary"
            variant="fullWidth"
            sx={{ minHeight:'36px' }} 
          >
            {Object.keys(classificationOptions).map(type => (
              <Tab 
                key={type} 
                label={type} 
                value={type} 
                sx={{ minHeight:'36px' }} 
              />
            ))}
          </Tabs>
        </Box>

        {/* [3] 表示対象選択（Chip） */}
        <Box sx={{ p:1, backgroundColor:'#fff', borderBottom:'1px solid #ccc' }}>
          <Typography variant="body1" gutterBottom>
            表示対象（{selectedClassificationType}）
          </Typography>
          <Box sx={{ display:'flex', gap:1, flexWrap:'wrap' }}>
            {classificationOptions[selectedClassificationType].map(target => {
              const selected = selectedTargets.has(target);
              return (
                <Chip
                  key={target}
                  label={target}
                  variant={selected ? "filled" : "outlined"}
                  color={selected ? "primary" : "default"}
                  size="small"
                  onClick={() => {
                    const newSet = new Set(selectedTargets);
                    if(newSet.has(target)) newSet.delete(target);
                    else newSet.add(target);
                    setSelectedTargets(newSet);
                  }}
                />
              );
            })}
          </Box>
        </Box>
      </Box>

      {/* 下部エリア：グラフとテーブル */}
      <Box sx={{ display:'flex', flexDirection:'column', gap: 2 }}>
        
        {/* グラフエリア */}
        <Box sx={{ p:1, minHeight:'200px' }}>
          <Paper sx={{ p:1, height: '100%' }}>
            <Typography variant="body1" gutterBottom>
              グラフ (昨年実績・今期実績・今期予測)
            </Typography>
            <Box sx={{ height: 'calc(100% - 30px)' }}>
              <canvas id="myChart" style={{ width:'100%', height:'100%' }}></canvas>
            </Box>
          </Paper>
        </Box>

        {/* 予測結果テーブル */}
        <Box sx={{ p:1 }}>
          <Paper sx={{ p:1, display:'flex', flexDirection:'column' }}>
            <Typography variant="body1" gutterBottom>
              予測結果テーブル
            </Typography>
            <TableContainer>
              <Table size="small">
                <TableHead>
                  <TableRow>
                    <TableCell sx={{ backgroundColor: 'silver', borderRight: '1px solid #ccc' }}>
                      分類
                    </TableCell>
                    <TableCell sx={{ backgroundColor: 'silver', borderRight: '1px solid #ccc' }}>
                      対象
                    </TableCell>
                    <TableCell sx={{ backgroundColor: 'silver', borderRight: '1px solid #ccc' }}>
                      シリーズ
                    </TableCell>
                    {periodLabels.map(label => (
                      <TableCell
                        key={label}
                        align="right"
                        sx={{ backgroundColor: 'silver', borderRight: '1px solid #ccc' }}
                      >
                        {label}
                      </TableCell>
                    ))}
                  </TableRow>
                </TableHead>
                <TableBody>
                  {filteredTableRows.map((row, idx, arr) => {
                    const isLastRow = idx === arr.length - 1;
                    const nextRowDiffers = !isLastRow && (row.target !== arr[idx+1].target);
                    const borderBottom = (isLastRow || nextRowDiffers) ? "2px solid black" : "1px solid #ccc";
                    return (
                      <TableRow key={idx} sx={{ borderBottom: borderBottom }}>
                        <TableCell>{row.classification}</TableCell>
                        <TableCell>{row.target}</TableCell>
                        <TableCell>{row.series}</TableCell>
                        {row.data.map((val, i) => (
                          <TableCell key={i} align="right">{val ?? "-"}</TableCell>
                        ))}
                      </TableRow>
                    );
                  })}
                </TableBody>
              </Table>
            </TableContainer>
          </Paper>
        </Box>

      </Box>
    </Container>
  );
}

ReactDOM.render(<App />, document.getElementById("root"));
</script>
</body>
</html>
