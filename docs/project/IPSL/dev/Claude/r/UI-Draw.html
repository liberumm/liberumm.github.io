<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Multi-Board Painter with Undo/Redo & Context Menu</title>

  <!-- React / ReactDOM / MUI / Babel / Fabric.js -->
  <script src="https://cdn.jsdelivr.net/npm/react@18/umd/react.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mui/material@5.15.14/umd/material-ui.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.2/babel.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.2.4/fabric.min.js"></script>
  <script src="https://unpkg.com/xlsx/dist/xlsx.full.min.js"></script>
  <script src="https://unpkg.com/exceljs/dist/exceljs.min.js"></script>

  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap">
  <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">

  <style>
    html, body, #root { height:100%; margin:0; overflow:hidden; }
    .canvas-container {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      background: #f5f5f5;
      padding: 24px;
      overflow: hidden;
    }
    .canvas-wrapper {
      position: relative;
      transform-origin: center;
      transition: transform 0.2s;
    }
    .zoom-controls {
      position: absolute;
      bottom: 16px;
      right: 16px;
      display: flex;
      gap: 8px;
      padding: 8px;
      background: rgba(255,255,255,0.9);
      border-radius: 4px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .current-status {
      position: absolute;
      bottom: 16px;
      left: 16px;
      display: flex;
      gap: 16px;
      padding: 8px;
      background: rgba(255,255,255,0.9);
      border-radius: 4px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      align-items: center;
    }
    .current-color {
      width: 24px;
      height: 24px;
      border-radius: 4px;
      border: 2px solid #fff;
      box-shadow: 0 0 0 1px rgba(0,0,0,0.1);
    }
    .current-colors {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .color-preview {
      display: flex;
      flex-direction: column;
      gap: 4px;
      cursor: pointer;
    }
    .color-label {
      font-size: 10px;
      text-align: center;
      color: #666;
    }
    canvas {
      display: block;
      margin: 0 auto;
      border: 1px solid #ccc;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .tool-scroll {
      display: flex;
      overflow-x: auto;
      gap: 1rem;
      padding: .75rem;
      background: #fff;
      border-bottom: 1px solid #eee;
    }
    .tool-group {
      display: flex;
      gap: .5rem;
      padding: 0 .5rem;
      border-right: 1px solid #eee;
    }
    .tool-group:last-child {
      border-right: none;
    }
    .layer-color {
      width: 28px;
      height: 28px;
      border: 2px solid #fff;
      border-radius: 4px;
      padding: 0;
      margin-right: 8px;
      cursor: pointer;
      box-shadow: 0 0 0 1px rgba(0,0,0,0.1);
    }
    .color-palette {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: .5rem;
      padding: .5rem;
      background: #fff;
      border-radius: 4px;
    }
    .color-swatch {
      width: 32px;
      height: 32px;
      border-radius: 4px;
      cursor: pointer;
      border: 2px solid #fff;
      box-shadow: 0 0 0 1px rgba(0,0,0,0.1);
    }
    .thumb-container {
      position: relative;
      padding-top: 75%;
      background: #fff;
      border-radius: 4px;
      overflow: hidden;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    .thumb {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
    }
    .panel {
      position: absolute;
      background: white;
      border-radius: 4px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      min-width: 240px;
      max-width: 320px;
      display: flex;
      flex-direction: column;
      max-height: 80vh;
      resize: both;
      overflow: auto;
    }
    .panel-header {
      padding: 8px 16px;
      background: #f5f5f5;
      border-bottom: 1px solid #ddd;
      cursor: move;
      user-select: none;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .color-controls {
      display: flex;
      flex-direction: column;
      gap: 16px;
      padding: 16px;
    }
    .color-preview-large {
      width: 100%;
      height: 60px;
      border-radius: 4px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }
    .layer-colors {
      display: flex;
      gap: 8px;
    }
    .layer-color-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
    }
    /* オブジェクトブラウザーの新しいスタイル */
    .object-list-item {
      display: flex;
      align-items: center;
      padding: 8px;
      border-bottom: 1px solid #eee;
      position: relative;
      transition: background-color 0.2s;
    }
    .object-list-item:hover {
      background-color: rgba(0,0,0,0.02);
    }
    .object-controls {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-left: auto;
    }
    .color-controls-compact {
      display: flex;
      gap: 8px;
      padding: 4px 8px;
      background: #f5f5f5;
      border-radius: 4px;
    }
    .layer-handle {
      cursor: move;
      padding: 0 4px;
      color: #666;
    }

    /* ワークスペース関連のスタイル */
    .workspace {
      position: relative;
      width: 100%;
      height: 100%;
      overflow: auto;
      background: #e0e0e0;
      padding: 32px;
    }
    .workspace-content {
      position: relative;
      min-width: 100%;
      min-height: 100%;
    }
    .artboard-wrapper {
      position: absolute;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      transition: transform 0.2s, box-shadow 0.2s;
    }
    .artboard-wrapper.focused {
      box-shadow: 0 4px 16px rgba(33,150,243,0.3);
      border: 2px solid #2196f3;
    }
    .artboard-wrapper.dragging {
      opacity: 0.8;
      transform: scale(1.02);
      z-index: 1000;
    }
    .artboard-header {
      padding: 8px;
      background: #f5f5f5;
      border-radius: 8px 8px 0 0;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .workspace-mode {
      position: fixed;
      top: 110px;
      left: 16px;
      display: flex;
      gap: 8px;
      padding: 8px;
      background: white;
      border-radius: 4px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      z-index: 1000;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { Box, AppBar, Toolbar, IconButton, Typography, Button, CssBaseline,
      Drawer, List, ListItem, ListItemText, Divider, Tooltip,
      Dialog, DialogTitle, DialogContent, DialogContentText, DialogActions, TextField,
      Menu, MenuItem, Grid, ListItemIcon, FormControl, FormLabel, RadioGroup, CardContent, CardActionArea, Card, FormControlLabel, Radio, Slider } = MaterialUI;

    // 色関連のユーティリティ関数を最初に定義
    function colorToString(color) {
      if (!color) return '#000000';
      if (typeof color === 'string') {
        if (color.startsWith('rgba')) return color;
        return color;
      }
      if (!color.color) return '#000000';
      const alpha = color.alpha ?? 1;
      if (alpha === 1) return color.color;
      const r = parseInt(color.color.slice(1,3), 16);
      const g = parseInt(color.color.slice(3,5), 16);
      const b = parseInt(color.color.slice(5,7), 16);
      return `rgba(${r},${g},${b},${alpha})`;
    }

    // 1. StatusBarコンポーネント修正：右クリックでコンテキストメニューが出ないようにする
    function StatusBar({ fillColor, strokeColor, boardSize, onColorClick, onSizeClick }) {
      return (
        <div className="current-status" onContextMenu={e => e.preventDefault()}>
          <div className="current-colors">
            <Tooltip title="塗りの色">
              <div className="color-preview" onClick={e => {
                e.preventDefault();
                e.stopPropagation();
                onColorClick('fill', fillColor.color);
              }}>
                <div className="current-color" style={{ background: colorToString(fillColor) }} />
                <span className="color-label">
                  塗り ({Math.round(fillColor.alpha * 100)}%)
                </span>
              </div>
            </Tooltip>
            <Tooltip title="線の色">
              <div className="color-preview" onClick={e => {
                e.preventDefault();
                e.stopPropagation();
                onColorClick('stroke', strokeColor.color);
              }}>
                <div className="current-color" style={{ background: colorToString(strokeColor) }} />
                <span className="color-label">
                  線 ({Math.round(strokeColor.alpha * 100)}%)
                </span>
              </div>
            </Tooltip>
          </div>
          <Tooltip title="サイズを変更">
            <Button
              size="small"
              onClick={onSizeClick}
              sx={{ textTransform: 'none' }}
            >
              {boardSize.w} × {boardSize.h}px
            </Button>
          </Tooltip>
        </div>
      );
    }

    function ZoomControls({ zoom, onZoomChange }) {
      return (
        <div className="zoom-controls">
          <IconButton size="small" onClick={() => onZoomChange(-0.1)}>
            <span className="material-icons">remove</span>
          </IconButton>
          <Typography variant="body2" sx={{ minWidth: 40, textAlign: 'center' }}>
            {Math.round(zoom * 100)}%
          </Typography>
          <IconButton size="small" onClick={() => onZoomChange(0.1)}>
            <span className="material-icons">add</span>
          </IconButton>
        </div>
      );
    }

    // 1. ツールバーのカラー設定UI
    function ColorControl({ label, color, alpha, onColor, onAlpha }) {
      return (
        <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
          <Tooltip title={label}>
            <input
              type="color"
              value={color}
              style={{ width: 28, height: 28, border: 'none', background: 'none', padding: 0 }}
              onChange={e => onColor(e.target.value)}
            />
          </Tooltip>
          <Slider
            value={alpha}
            min={0}
            max={1}
            step={0.01}
            sx={{ width: 60 }}
            onChange={(e, val) => onAlpha(val)}
          />
        </Box>
      );
    }

    function App() {
      const drawerWidth = 260;

      const [boards, setBoards] = React.useState([
        { id: 1, name: 'ボード1', w: 500, h: 500, json: null, history: [], historyIndex: -1 }
      ]);
      const [cur, setCur] = React.useState(0);
      const [view, setView] = React.useState('single');
      const [drawerOpen, setDrawerOpen] = React.useState(false);

      const [tool, setTool] = React.useState('select');
      const [textDlg, setTextDlg] = React.useState(false);
      const [textVal, setTextVal] = React.useState('');
      const [sizeDlg, setSizeDlg] = React.useState(false);
      const [sizeVal, setSizeVal] = React.useState({ w: 500, h: 500 });

      const [layers, setLayers] = React.useState([]);
      const [contextMenu, setContextMenu] = React.useState(null);
      const [colorDlg, setColorDlg] = React.useState(false);
      const [colorVal, setColorVal] = React.useState('#000000');

      const fabricRef = React.useRef(null);
      const [zoom, setZoom] = React.useState(1);
      const [camera, setCamera] = React.useState(null);

      const [panels, setPanels] = React.useState({
        artboards: { open: true, x: 16, y: 170 },
        objects: { open: true, x: window.innerWidth - 266, y: 170 }
      });

      const [galleryDlg, setGalleryDlg] = React.useState(false);
      const [exportDlg, setExportDlg] = React.useState(false);
      const [exportOpts, setExportOpts] = React.useState({
        orientation: 'landscape',
        paperSize: 'A4',
        preview: null,
        selectedBoards: []  // 出力対象のボード
      });

      const [fillColor, setFillColor] = React.useState({ color: '#000000', alpha: 1 });
      const [strokeColor, setStrokeColor] = React.useState({ color: '#000000', alpha: 1 });
      const [confirmDlg, setConfirmDlg] = React.useState({
        open: false,
        title: '',
        message: '',
        onConfirm: null
      });
      const [editingLayer, setEditingLayer] = React.useState({ id: null, value: "" });

      // ヘルパー関数の追加
      function startEditingLayer(layer) {
        setEditingLayer({ id: layer.id, value: layer.name });
      }
      function finishEditingLayer(layerId) {
        setLayers(layers => layers.map(layer => {
          if (layer.id === layerId) {
            // オブジェクトのnameも更新
            layer.obj.name = editingLayer.value;
            return { ...layer, name: editingLayer.value };
          }
          return layer;
        }));
        setEditingLayer({ id: null, value: "" });
        saveCurrent();
      }

      // フリードロー設定の更新
      React.useEffect(() => {
        if (fabricRef.current) {
          const color = colorToString(strokeColor);
          fabricRef.current.freeDrawingBrush.color = color || '#000000';
        }
      }, [strokeColor]);

      // 初回マウントで Fabric Canvas を生成する部分の修正
      React.useEffect(() => {
        const cv = new fabric.Canvas('fabricCanvas', { preserveObjectStacking: true });
        cv.freeDrawingBrush.color = '#000';
        cv.freeDrawingBrush.width = 2;
        fabricRef.current = cv;

        setupCanvasHandlers(cv);

        loadBoard(0);
        return () => cv.dispose();
      }, []);

      // ボード切替時
      React.useEffect(() => {
        if (fabricRef.current) loadBoard(cur);
      }, [cur]);

      // JSON→Canvas描画
      function loadJSON(json, w, h) {
        const cv = fabricRef.current;
        cv.clear();
        cv.setWidth(w).setHeight(h);
        cv.setBackgroundColor('#fff', cv.renderAll.bind(cv));
        if (json) {
          cv.loadFromJSON(json, () => {
            cv.renderAll();
            updateLayers();
          });
        } else {
          cv.renderAll();
          updateLayers();
        }
      }

      // ボードロード処理を修正
      function loadBoard(idx) {
        const b = boards[idx];
        const cv = fabricRef.current;
        
        // キャンバスサイズを設定
        cv.setWidth(b.w);
        cv.setHeight(b.h);
        
        loadJSON(b.json, b.w, b.h);
        setBoards(bs => bs.map((bd, i) => {
          if (i === idx && bd.history.length === 0) {
            const snap = cv.toJSON();
            return { ...bd, history: [snap], historyIndex: 0 };
          }
          return bd;
        }));
        selectTool('select', false);
      }

      // 保存＋履歴追加
      function saveCurrent() {
        let cv;
        if (workspaceMode === 'workspace') {
          const canvasElem = document.getElementById(`fabricCanvas-${cur}`);
          if (!canvasElem?._dynamicCanvas) return;
          cv = canvasElem._dynamicCanvas;
        } else {
          cv = fabricRef.current;
        }
      
        const newJson = cv.toJSON();
        setBoards(bs => bs.map((b, i) => {
          if (i === cur) {
            const hist = b.history.slice(0, b.historyIndex + 1);
            hist.push(newJson);
            return { ...b, json: newJson, history: hist, historyIndex: hist.length - 1 };
          }
          return b;
        }));
        updateLayers();
      }

      // Undo/Redo
      function undo() {
        const b = boards[cur];
        if (b.historyIndex > 0) {
          const idx = b.historyIndex - 1;
          loadJSON(b.history[idx], b.w, b.h);
          setBoards(bs => bs.map((bd, i) => i === cur ? { ...bd, historyIndex: idx, json: bd.history[idx] } : bd));
        }
      }
      function redo() {
        const b = boards[cur];
        if (b.historyIndex < b.history.length - 1) {
          const idx = b.historyIndex + 1;
          loadJSON(b.history[idx], b.w, b.h);
          setBoards(bs => bs.map((bd, i) => i === cur ? { ...bd, historyIndex: idx, json: bd.history[idx] } : bd));
        }
      }
      const bcur = boards[cur];
      const canUndo = bcur.historyIndex > 0;
      const canRedo = bcur.historyIndex < bcur.history.length - 1;

      const [workspaceMode, setWorkspaceMode] = React.useState('workspace');
      const [artboardPositions, setArtboardPositions] = React.useState([]);
      const [isDragging, setIsDragging] = React.useState(false);
      const [dragOffset, setDragOffset] = React.useState({ x: 0, y: 0 });

      // ワークスペースモード用のキャンバス生成処理
      React.useEffect(() => {
        if (workspaceMode !== 'workspace') return;

        boards.forEach((b, i) => {
          const canvasElem = document.getElementById(`fabricCanvas-${i}`);
          if (!canvasElem) return;

          // 初回だけ生成する
          if (!canvasElem._dynamicCanvas) {
            const dynamicCanvas = new fabric.Canvas(canvasElem, {
              selection: true,
              preserveObjectStacking: true,
              enableRetinaScaling: true,
              skipTargetFind: false,
              perPixelTargetFind: true
            });
            dynamicCanvas.setWidth(b.w);
            dynamicCanvas.setHeight(b.h);
            dynamicCanvas.setBackgroundColor('#fff', dynamicCanvas.renderAll.bind(dynamicCanvas));
            if (b.json) {
              dynamicCanvas.loadFromJSON(b.json, () => dynamicCanvas.requestRenderAll());
            }
            canvasElem._dynamicCanvas = dynamicCanvas;
            setupCanvasHandlers(dynamicCanvas);

            // キャンバス内クリックを親にバブリングさせない
            ['upperCanvasEl','lowerCanvasEl'].forEach(elName => {
              dynamicCanvas[elName].addEventListener('mousedown', e => e.stopPropagation());
            });
          }
        });
        // ここでは dispose はしない
      }, [workspaceMode /*, boards.length */]);

      // モード切替時の処理を修正
      React.useEffect(() => {
        if (workspaceMode === 'artboard') {
          // dynamicCanvas上のオブジェクトがあれば現在のボードのjsonへ統合
          const canvasId = `fabricCanvas-${cur}`;
          const wsCanvasElem = document.getElementById(canvasId);
          if (wsCanvasElem && wsCanvasElem._dynamicCanvas) {
            const dynamicCV = wsCanvasElem._dynamicCanvas;
            // 既存のjsonオブジェクト配列（なければ空配列）とdynamicCanvas上のオブジェクトをマージ
            let baseJson = {};
            try {
              baseJson = boards[cur].json ? JSON.parse(JSON.stringify(boards[cur].json)) : { objects: [] };
            } catch (err) {
              baseJson = { objects: [] };
            }
            const newObjs = dynamicCV.getObjects().map(obj => obj.toObject());
            const combined = {
              ...baseJson,
              objects: [...baseJson.objects, ...newObjs]
            };
            setBoards(bs =>
              bs.map((b, i) => i === cur ? { ...b, json: combined } : b)
            );
          }
          // アートボード編集モード用のcanvasを再生成
          const canvasElem = document.getElementById('fabricCanvas');
          if (canvasElem) {
            if (fabricRef.current) {
              fabricRef.current.dispose();
            }
            const cv = new fabric.Canvas('fabricCanvas', { preserveObjectStacking: true });
            cv.freeDrawingBrush.color = '#000';
            cv.freeDrawingBrush.width = 2;
            // 必要なイベントハンドラを再登録
            setupCanvasHandlers(cv);
            fabricRef.current = cv;

            const b = boards[cur];
            cv.setWidth(b.w);
            cv.setHeight(b.h);
            loadJSON(b.json, b.w, b.h);
            selectTool('select', false);
          }
        } else {
          // ワークスペースモードに切り替え
          if (fabricRef.current) {
            saveCurrent(); // 現在の状態を保存
            fabricRef.current.dispose(); // メインキャンバスを破棄
            fabricRef.current = null;
            fitWorkspaceToScreen(); // 全体表示
          }
        }
      }, [workspaceMode, cur]);

      // selectTool関数を修正
      function selectTool(name, save = true) {
        let cv;
        if (workspaceMode === 'workspace') {
          const canvasElem = document.getElementById(`fabricCanvas-${cur}`);
          if (!canvasElem?._dynamicCanvas) return;
          cv = canvasElem._dynamicCanvas;
        } else {
          cv = fabricRef.current;
        }
      
        if (save) saveCurrent();
        setTool(name);
        
        // 描画モードとオブジェクト選択の設定
        cv.isDrawingMode = (name === 'draw');
        cv.selection = true; // 常に選択可能に変更
        
        // すべてのオブジェクトを操作可能に
        cv.forEachObject(o => {
          o.selectable = true;
          o.evented = true;
        });
        
        // 選択状態を維持
        const activeObj = cv.getActiveObject();
        if (activeObj) {
          activeObj.setCoords();
          cv.setActiveObject(activeObj);
        }
        
        cv.requestRenderAll();
      }

      // 2. オブジェクトブラウザーの順序修正：表示順をCanvas上の順番と一致させる
      // 更新処理はupdateLayers()内でCanvas.getObjects()の配列順をそのままセット
      // updateLayers関数を修正
      function updateLayers() {
        let objs;
        if (workspaceMode === 'workspace') {
          // workspace モードの場合は現在選択中のアートボードのdynamicCanvasから取得
          const canvasElem = document.getElementById(`fabricCanvas-${cur}`);
          if (canvasElem?._dynamicCanvas) {
            objs = canvasElem._dynamicCanvas.getObjects();
          } else {
            objs = [];
          }
        } else {
          // artboard モードの場合は従来通り
          objs = fabricRef.current.getObjects();
        }
      
      // 名前が未設定（あるいはデフォルト形式）のものだけ連番デフォルト名を付与
        objs.forEach((o, i) => {
          const defaultName = `${o.type} ${i + 1}`;
          if (!o.name || o.name === defaultName) {
            o.name = defaultName;
          }
        });
      
        // 配列を反転させて、上のレイヤーが前面に表示されるようにする
        setLayers(objs.slice().reverse().map((o, i) => ({
          id: i,
          obj: o,
          name: o.name
        })));
      }
      
      // handleLayerReorder関数も修正
      function handleLayerReorder(fromReversedIndex, toReversedIndex) {
        let cv;
        if (workspaceMode === 'workspace') {
          const canvasElem = document.getElementById(`fabricCanvas-${cur}`);
          if (!canvasElem?._dynamicCanvas) return;
          cv = canvasElem._dynamicCanvas;
        } else {
          cv = fabricRef.current;
        }
      
        if (!cv) return;
        const objects = cv.getObjects();
        const fromIndex = objects.length - 1 - fromReversedIndex;
        const toIndex = objects.length - 1 - toReversedIndex;
        const obj = objects[fromIndex];
        if (!obj) return;
      
        obj.moveTo(toIndex);
        cv.requestRenderAll();
        updateLayers();
        saveCurrent();
      }
      
      // workspace モードでキャンバス更新時にレイヤー表示も更新するように修正
      React.useEffect(() => {
        if (workspaceMode !== 'workspace') return;

boards.forEach((b, i) => {
  const canvasElem = document.getElementById(`fabricCanvas-${i}`);
  if (!canvasElem) return;

  // 初回だけ生成する
  if (!canvasElem._dynamicCanvas) {
    const dynamicCanvas = new fabric.Canvas(canvasElem, {
      selection: true,
      preserveObjectStacking: true,
      enableRetinaScaling: true,
      skipTargetFind: false,
      perPixelTargetFind: true
    });
    dynamicCanvas.setWidth(b.w);
    dynamicCanvas.setHeight(b.h);
    dynamicCanvas.setBackgroundColor('#fff', dynamicCanvas.renderAll.bind(dynamicCanvas));
    if (b.json) {
      dynamicCanvas.loadFromJSON(b.json, () => dynamicCanvas.requestRenderAll());
    }
    canvasElem._dynamicCanvas = dynamicCanvas;
    setupCanvasHandlers(dynamicCanvas);

    // キャンバス内クリックを止めて親の workspace mousedown を防ぐ
    ['upperCanvasEl','lowerCanvasEl'].forEach(elName => {
      dynamicCanvas[elName].addEventListener('mousedown', e => e.stopPropagation());
    });
  }
});

}, [workspaceMode /* ← ここを */ , boards.length /* ← こう変える */]);
      
      // オブジェクトブラウザーでのオブジェクト選択処理も修正
      function selectObject(obj) {
        if (workspaceMode === 'workspace') {
          const canvasElem = document.getElementById(`fabricCanvas-${cur}`);
          if (canvasElem?._dynamicCanvas) {
            canvasElem._dynamicCanvas.setActiveObject(obj);
            canvasElem._dynamicCanvas.requestRenderAll();
          }
        } else {
          fabricRef.current.setActiveObject(obj);
          fabricRef.current.requestRenderAll();
        }
      }
      
      // 画像追加
      function addImage(file) {
        if (!file?.type.startsWith('image/')) return;
        const url = URL.createObjectURL(file);
        fabric.Image.fromURL(url, img => {
          img.set({ left: 40, top: 40, objectCaching: false });
          fabricRef.current.add(img).setActiveObject(img);
          saveCurrent();
        });
      }

      // コンテキストメニュー操作
      function handleCopy(obj) {
        obj.clone(cloned => {
          cloned.set({ left: cloned.left + 10, top: cloned.top + 10 });
          fabricRef.current.add(cloned).setActiveObject(cloned);
          saveCurrent();
        });
        closeContextMenu();
      }
      function handleDelete(obj) {
        if (!obj) return;
        const cv = fabricRef.current;

        // 選択状態をクリア
        cv.discardActiveObject();
        cv.renderAll();

        // オブジェクトを削除
        cv.remove(obj);

        // キャンバスを完全に更新
        cv.renderAll();
        cv.calcOffset(); // 座標系を再計算
        updateLayers();
        saveCurrent();
        closeContextMenu();
      }
      function openColorDlg(obj) {
        setColorVal(obj.fill || obj.stroke || '#000000');
        setContextMenu(cm => ({ ...cm, forObject: obj }));
        setColorDlg(true);
      }
      function applyColor() {
        if (!contextMenu?.colorType) return;
        
        const type = contextMenu.colorType;
        const canvas = contextMenu.canvas || fabricRef.current;
        const obj = contextMenu.target;
        
        if (type === 'text') {
          setTextStyle(s => ({ ...s, fill: colorVal }));
        } else if (obj?.set) {
          const alpha = type === 'fill' ? fillColor.alpha : strokeColor.alpha;
          const colorStr = colorToString({ color: colorVal, alpha });
          obj.set(type, colorStr);
          canvas.requestRenderAll();
          saveCurrent();
        } else {
          handleColorChange(type, colorVal);
        }
      
        setColorDlg(false);
        setContextMenu(null);
      }
      function closeContextMenu() {
        setContextMenu(null);
      }

      // ズーム処理
      const handleZoom = (delta) => {
        setZoom(z => {
          const newZoom = Math.max(0.1, Math.min(5, z + delta));
          fabricRef.current?.setZoom(newZoom);
          return newZoom;
        });
      };

      // カメラ起動
      const startCamera = async () => {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ video: true });
          setCamera(stream);
        } catch (err) {
          console.error('カメラの起動に失敗:', err);
        }
      };

      // 写真撮影
      const takePhoto = () => {
        const video = document.querySelector('video');
        const canvas = document.createElement('canvas');
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        canvas.getContext('2d').drawImage(video, 0, 0);
        canvas.toBlob(blob => {
          const file = new File([blob], "photo.jpg", { type: "image/jpeg" });
          addImage(file);
          setCamera(null);
        }, 'image/jpeg');
      };

      // パネルドラッグ処理
      const dragRef = React.useRef(null);

      const startDrag = (e, panelId) => {
        const panel = document.getElementById(panelId);
        const rect = panel.getBoundingClientRect();
        dragRef.current = {
          panelId,
          offsetX: e.clientX - rect.left,
          offsetY: e.clientY - rect.top
        };
        e.preventDefault();
      };

      React.useEffect(() => {
        const handleDrag = (e) => {
          if (!dragRef.current) return;

          setPanels(p => ({
            ...p,
            [dragRef.current.panelId]: {
              ...p[dragRef.current.panelId],
              x: e.clientX - dragRef.current.offsetX,
              y: e.clientY - dragRef.current.offsetY
            }
          }));
        };

        const endDrag = () => {
          dragRef.current = null;
        };

        window.addEventListener('mousemove', handleDrag);
        window.addEventListener('mouseup', endDrag);
        return () => {
          window.removeEventListener('mousemove', handleDrag);
          window.removeEventListener('mouseup', endDrag);
        };
      }, []);

      // 拡張コンテキストメニュー
      const handleCanvasContext = (e) => {
        e.preventDefault();
        const cv = fabricRef.current;
        const pointer = cv.getPointer(e);
        const target = cv.findTarget(e);

        setContextMenu({
          mouseX: e.clientX,
          mouseY: e.clientY,
          canvasPoint: pointer,
          target: target
        });
      };

      // 2. キャンバスクリアの修正
      function clearCanvas() {
        const cv = fabricRef.current;
        if (!cv) return;
        cv.getObjects().slice().forEach(obj => cv.remove(obj));
        cv.setBackgroundColor('#fff', () => {
          cv.renderAll();
          saveCurrent();
        });
      }

      // コンテキストメニューアイテムの更新
      const contextMenuItems = React.useMemo(() => {
        if (!contextMenu) return [];
      
        const cv = workspaceMode === 'workspace' 
          ? document.getElementById(`fabricCanvas-${cur}`)._dynamicCanvas 
          : fabricRef.current;
      
        if (contextMenu.target) {
          return [
            { label: 'コピー', icon: 'content_copy', action: () => handleCopy(contextMenu.target) },
            { type: 'divider' },
            { label: '最前面へ', icon: 'vertical_align_top', action: () => { contextMenu.target.bringToFront(); saveCurrent(); } },
            { label: '最背面へ', icon: 'vertical_align_bottom', action: () => { contextMenu.target.sendToBack(); saveCurrent(); } },
            { label: '1つ前面へ', icon: 'arrow_upward', action: () => { contextMenu.target.bringForward(); saveCurrent(); } },
            { label: '1つ背面へ', icon: 'arrow_downward', action: () => { contextMenu.target.sendBackwards(); saveCurrent(); } },
            { type: 'divider' },
            { label: 'アスペクト比をリセット', icon: 'aspect_ratio', action: () => resetAspectRatio(contextMenu.target) },
            { label: '1:1にする', icon: 'crop_square', action: () => setSquareAspectRatio(contextMenu.target) },
            { type: 'divider' },
            { label: '塗りの色', icon: 'format_color_fill', action: () => {
              setColorVal(contextMenu.target.fill || fillColor);
              setContextMenu(cm => ({ ...cm, forObject: contextMenu.target, colorType: 'fill' }));
              setColorDlg(true);
            }},
            { label: '線の色', icon: 'border_color', action: () => {
              setColorVal(contextMenu.target.stroke || strokeColor);
              setContextMenu(cm => ({ ...cm, forObject: contextMenu.target, colorType: 'stroke' }));
              setColorDlg(true);
            }},
            { type: 'divider' },
            { label: '削除', icon: 'delete', action: () => handleDelete(contextMenu.target) },
          ];
        } else {
          return [
            { label: '画像を挿入', icon: 'image', action: () => document.getElementById('fileUp').click() },
            { label: 'カメラで撮影', icon: 'camera_alt', action: startCamera },
            { type: 'divider' },
            { label: 'キャンバスをクリア', icon: 'clear', action: () => {
              if (confirm('キャンバスをクリアしますか？')) clearCanvas();
            }}
          ];
        }
      }, [contextMenu, fillColor, strokeColor, workspaceMode, cur]);

      // Drawer 内容
      const drawerContent = (
        <Box sx={{ width: drawerWidth }}>
          <Toolbar />
          <Typography sx={{ px: 2, py: 1 }} variant="subtitle1">Artboards</Typography>
          <List>
            {boards.map((b, i) => (

              <ListItem button key={b.id} selected={i === cur}
                onClick={() => { saveCurrent(); setCur(i); setView('single'); setDrawerOpen(false); }}
              >
                <ListItemText primary={b.name} secondary={`${b.w}×${b.h}`} />
              </ListItem>
            ))}
          </List>
          <Divider />
          <Button fullWidth onClick={() => {

            const nid = boards[boards.length - 1].id + 1;
            setBoards([...boards, { id: nid, name: `ボード${nid}`, w: 500, h: 500, json: null, history: [], historyIndex: -1 }]);
            saveCurrent(); setCur(boards.length); setView('single'); setDrawerOpen(false);
          }}>＋ 新規ボード</Button>
          <Divider sx={{ my: 2 }} />
          <Typography sx={{ px: 2, py: 1 }} variant="subtitle1">Layers</Typography>
          <List>
            {layers.map((layer, index) => (

              <ListItem
                key={layer.id}
                className="object-list-item"
                selected={fabricRef.current?.getActiveObject() === layer.obj}
                onClick={e => {
                  e.stopPropagation();
                  selectObject(layer.obj);
                }}
                draggable
                onDragStart={e => {
                  e.dataTransfer.setData('application/json', JSON.stringify({ index }));
                  e.currentTarget.style.opacity = '0.5';
                }}
                onDragEnd={e => { e.currentTarget.style.opacity = ''; }}
                onDragOver={e => {
                  e.preventDefault();
                  e.currentTarget.style.borderTop = '2px solid #2196f3';
                }}
                onDragLeave={e => { e.currentTarget.style.borderTop = ''; }}
                onDrop={e => {
                  e.preventDefault();
                  e.currentTarget.style.borderTop = '';
                  try {
                    const data = JSON.parse(e.dataTransfer.getData('application/json'));
                    if (typeof data.index === 'number') {
                      handleLayerReorder(data.index, index);
                    }
                  } catch (err) { }
                }}
                secondaryAction={
                  <Box sx={{ display: 'flex', alignItems: 'center' }}>
                    <input type="color" className="layer-color"
                      value={typeof layer.obj.fill === 'string' && layer.obj.fill.startsWith('rgba')
                        ? rgbaToHex(layer.obj.fill)
                        : (layer.obj.fill || '#000000')}
                      onClick={e => e.stopPropagation()}
                      onChange={e => {
                        e.preventDefault();
                        // 新しく選択された色を直接渡す
                        handleLayerColorChange(layer, 'fill', e.target.value);
                      }}
                    />
                    <IconButton size="small" onClick={() => handleDelete(layer.obj)}>
                      <span className="material-icons">delete</span>
                    </IconButton>
                  </Box>
                }
              >
                {/* 編集用テキストフィールドまたは通常のテキスト表示 */}
                {editingLayer.id === layer.id ? (
                  <TextField
                    value={editingLayer.value}
                    variant="standard"
                    onChange={e => setEditingLayer({ ...editingLayer, value: e.target.value })}
                    onBlur={() => finishEditingLayer(layer.id)}
                    onKeyDown={e => {
                      if (e.key === 'Enter') finishEditingLayer(layer.id);
                    }}
                    autoFocus
                    onClick={e => e.stopPropagation()}
                  />
                ) : (
                  <Typography
                    variant="body2"
                    sx={{ flexGrow: 1 }}
                    onClick={e => {
                      e.stopPropagation();
                      startEditingLayer(layer);
                    }}
                  >
                    {layer.name}
                  </Typography>
                )}
                <div className="object-controls" style={{ display: 'flex', gap: '8px', alignItems: 'center' }}>
                  <IconButton
                    size="small"
                    onClick={e => {
                      e.stopPropagation();
                      layer.obj.visible = !layer.obj.visible;
                      fabricRef.current.requestRenderAll();
                      saveCurrent();
                    }}
                  >
                    <span className="material-icons">
                      {layer.obj.visible ? 'visibility' : 'visibility_off'}
                    </span>
                  </IconButton>
                  {/* オブジェクトブラウザー内のカラ―コントロール */}
                  <div className="color-controls-compact" style={{ display: 'flex', flexDirection: 'column', gap: '4px' }}>
                    <div style={{ display: 'flex', alignItems: 'center', gap: '4px' }}>
                      <label style={{ fontSize: '10px' }}>塗:</label>
                      <input
                        type="color"
                        value={layer.obj.fill 
                          ? (layer.obj.fill.startsWith('rgba') ? rgbaToHex(layer.obj.fill) : layer.obj.fill)
                          : '#000000'}
                        onClick={e => e.stopPropagation()}
                        onChange={e => {
                          e.preventDefault();
                          // 塗り色の場合はnewAlphaは変更なし(null)
                          handleLayerColorChange(layer, 'fill', e.target.value, null);
                        }}
                      />
                      <Slider
                        size="small"
                        value={getAlpha(layer.obj.fill)}
                        min={0}
                        max={1}
                        step={0.01}
                        sx={{ width: 60 }}
                        onClick={e => e.stopPropagation()}
                        onChange={(e, val) => {
                           const baseColor = layer.obj.fill 
                              ? (layer.obj.fill.startsWith('rgba') ? rgbaToHex(layer.obj.fill) : layer.obj.fill)
                              : '#000000';
                           handleLayerColorChange(layer, 'fill', baseColor, val);
                        }}
                      />
                    </div>
                    <div style={{ display: 'flex', alignItems: 'center', gap: '4px' }}>
                      <label style={{ fontSize: '10px' }}>線:</label>
                      <input
                        type="color"
                        value={layer.obj.stroke 
                          ? (layer.obj.stroke.startsWith('rgba') ? rgbaToHex(layer.obj.stroke) : layer.obj.stroke)
                          : '#000000'}
                        onClick={e => e.stopPropagation()}
                        onChange={e => {
                          e.preventDefault();
                          handleLayerColorChange(layer, 'stroke', e.target.value, null);
                        }}
                      />
                      <Slider
                        size="small"
                        value={getAlpha(layer.obj.stroke)}
                        min={0}
                        max={1}
                        step={0.01}
                        sx={{ width: 60 }}
                        onClick={e => e.stopPropagation()}
                        onChange={(e, val) => {
                           const baseColor = layer.obj.stroke 
                              ? (layer.obj.stroke.startsWith('rgba') ? rgbaToHex(layer.obj.stroke) : layer.obj.stroke)
                              : '#000000';
                           handleLayerColorChange(layer, 'stroke', baseColor, val);
                        }}
                      />
                    </div>
                  </div>
                  <IconButton
                    size="small"
                    onClick={e => {
                      e.stopPropagation();
                      handleDelete(layer.obj);
                    }}
                  >
                    <span className="material-icons">delete</span>
                  </IconButton>
                </div>
              </ListItem>
            ))}

          </List>
        </Box>
      );

      // Toolbar ボタン
      const ToolBtn = ({ icon, label, active, onClick, disabled }) => (

        <Tooltip title={label}>
          <IconButton size="small" color={active ? 'primary' : 'default'} onClick={onClick} disabled={disabled}>
            <span className="material-icons">{icon}</span>
          </IconButton>
        </Tooltip>
      );

      // パネル表示トグル
      const togglePanel = (panelId) => {
        setPanels(p => ({
          ...p,
          [panelId]: { ...p[panelId], open: !p[panelId].open }
        }));
      };

      // 形状追加
      function handleShape(type) {
        let cv;
        if (workspaceMode === 'workspace') {
          const canvasElem = document.getElementById(`fabricCanvas-${cur}`);
          if (!canvasElem?._dynamicCanvas) return;
          cv = canvasElem._dynamicCanvas;
        } else {
          cv = fabricRef.current;
        }
        
        if (!cv) return;

        const commonProps = {
          left: 60,
          top: 60,
          fill: colorToString(fillColor),
          stroke: colorToString(strokeColor),
          strokeWidth: 2
        };

        let obj;
        switch (type) {
          case 'rect':
            obj = new fabric.Rect({
              ...commonProps,
              width: 100,
              height: 60
            });
            break;
          case 'ellipse':
            obj = new fabric.Ellipse({
              ...commonProps,
              rx: 50,
              ry: 30
            });
            break;
          case 'arrow': {
            const line = new fabric.Line([0, 0, 100, 0], {
              stroke: strokeColor,
              strokeWidth: 2
            });
            const arrow = new fabric.Triangle({
              fill: strokeColor,
              width: 14,
              height: 20,
              left: 100,
              top: 0,
              angle: 90,
              originX: 'center',
              originY: 'center'
            });
            obj = new fabric.Group([line, arrow], {
              ...commonProps
            });
            break;
          }
        }

        if (obj) {
          obj.setControlsVisibility({
            mtr: true
          });
          cv.add(obj);
          
          // 選択処理を安全に行う
          try {
            cv.setActiveObject(obj);
            obj.setCoords();
          } catch (err) {
            console.warn('Shape selection failed:', err);
          }
          
          cv.requestRenderAll();
          saveCurrent();
        }
      }

      // サイズ変更
      function handleSize() {
        const b = boards[cur];
        setSizeVal({ w: b.w, h: b.h });
        setSizeDlg(true);
      }

      // ----- Excel出力機能 修正 -----
      const handleExport = async () => {
        try {
          const cv = fabricRef.current;
          const b = boards[cur];

          // タイムスタンプ付きのデフォルトファイル名を作成
          const now = new Date();
          const timestamp = now.getFullYear() +
            ('0' + (now.getMonth() + 1)).slice(-2) +
            ('0' + now.getDate()).slice(-2) + '_' +
            ('0' + now.getHours()).slice(-2) +
            ('0' + now.getMinutes()).slice(-2);
          const defaultFilename = `${b.name}_${timestamp}.xlsx`;

          // プレビュー用Canvasから画像データを生成
          const previewCanvas = document.createElement('canvas');
          const ctx = previewCanvas.getContext('2d');
          previewCanvas.width = b.w;
          previewCanvas.height = b.h;
          ctx.fillStyle = '#fff';
          ctx.fillRect(0, 0, b.w, b.h);
          ctx.drawImage(cv.lowerCanvasEl, 0, 0);
          ctx.drawImage(cv.upperCanvasEl, 0, 0);
          const base64Data = previewCanvas.toDataURL('image/png').split(',')[1];

          // ExcelJSワークブック作成
          const workbook = new ExcelJS.Workbook();
          const worksheet = workbook.addWorksheet(b.name);
          worksheet.pageSetup.paperSize = exportOpts.paperSize === 'A4' ? 9 : 10;
          worksheet.pageSetup.orientation = exportOpts.orientation;

          const imageId = workbook.addImage({
            base64: base64Data,
            extension: 'png',
          });

          const pageWidth = exportOpts.paperSize === 'A4' ?
            (exportOpts.orientation === 'portrait' ? 595 : 842) :
            (exportOpts.orientation === 'portrait' ? 842 : 1191);
          const scale = Math.min(pageWidth / b.w, pageWidth / b.h);
          worksheet.addImage(imageId, {
            tl: { col: 0, row: 0 },
            ext: { width: b.w * scale, height: b.h * scale }
          });

          // 保存ダイアログで保存先を選択する
          const fileHandle = await window.showSaveFilePicker({
            suggestedName: defaultFilename,
            types: [{
              description: 'Excel ファイル',
              accept: {
                'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': ['.xlsx']
              }
            }]
          });
          const buffer = await workbook.xlsx.writeBuffer();
          const writable = await fileHandle.createWritable();
          await writable.write(buffer);
          await writable.close();

          setExportDlg(false);
        } catch (err) {
          console.error('Export error:', err);
          alert('エクスポートに失敗しました:\n' + err.message);
        }
      };

      // キーボードイベント処理
      React.useEffect(() => {
        const handleKeyDown = (e) => {
          if (e.key === 'Delete') {
            const cv = fabricRef.current;
            const activeObj = cv.getActiveObject();
            if (activeObj) {
              handleDelete(activeObj);
            }
          }
        };
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, []);

      // アスペクト比リセット
      function resetAspectRatio(obj) {
        if (!obj) return;

        let w = 100, h = 60;
        if (obj._originalWidth && obj._originalHeight) {
          w = obj._originalWidth;
          h = obj._originalHeight;
        }

        if (obj.type === 'rect') {
          obj.set({
            width: w,
            height: h,
            scaleX: 1,
            scaleY: 1
          });
        } else if (obj.type === 'ellipse') {
          obj.set({
            rx: w / 2,
            ry: h / 2,
            scaleX: 1,
            scaleY: 1
          });
        }
        fabricRef.current.requestRenderAll();
        saveCurrent();
      }

      // 1:1アスペクト比
      function setSquareAspectRatio(obj) {
        if (!obj) return;

        const width = obj.width * obj.scaleX;
        const height = obj.height * obj.scaleY;
        const size = Math.max(width, height);

        if (obj.type === 'rect') {
          obj.set({
            width: size,
            height: size,
            scaleX: 1,
            scaleY: 1
          });
        } else if (obj.type === 'ellipse') {
          obj.set({
            rx: size / 2,
            ry: size / 2,
            scaleX: 1,
            scaleY: 1
          });
        }
        fabricRef.current.requestRenderAll();
        saveCurrent();
      }

      // アートボード追加
      function addNewBoard() {
        // 1) 新しいボード情報を作成
        const idx = boards.length;
        const newBoard = {
          id: Math.max(...boards.map(b => b.id)) + 1,
          name: `ボード${idx + 1}`,
          w: 500,
          h: 500,
          json: null,
          history: [],
          historyIndex: -1
        };

        // 2) アクティブボードの位置・サイズ取得（なければ原点0,0）
        const activeBoard   = boards[cur]              || { w: 500, h: 500 };
        const activePos     = artboardPositions[cur]   || { x: 0,   y: 0   };
        const GAP           = 20;  // ボード間の余白

        // 3) 新規ボードの配置座標は「右隣」
        const newPos = {
          x: activePos.x + activeBoard.w + GAP,
          y: activePos.y
        };

        // 4) State をまとめて更新
        setBoards(prev => [...prev, newBoard]);
        setArtboardPositions(prev => [...prev, newPos]);
        setCur(idx);

        // 5) 履歴スナップショット保存
        saveCurrent();
      }


      // 色設定関連の修正
      function handleColorChange(type, newColor, newAlpha = null) {
        const colorObj = {
          color: newColor,
          alpha: newAlpha ?? (type === 'fill' ? fillColor.alpha : strokeColor.alpha)
        };
      
        if (type === 'fill') {
          setFillColor(colorObj);
        } else {
          setStrokeColor(colorObj);
        }
      
        // 適切なキャンバスを取得
        let cv;
        if (workspaceMode === 'workspace') {
          const canvasElem = document.getElementById(`fabricCanvas-${cur}`);
          if (!canvasElem?._dynamicCanvas) return;
          cv = canvasElem._dynamicCanvas;
        } else {
          cv = fabricRef.current;
        }
      
        // アクティブオブジェクトがある場合は適用
        const activeObj = cv.getActiveObject();
        if (activeObj) {
          const colorStr = colorToString(colorObj);
          activeObj.set(type, colorStr);
          if (type === 'stroke' && cv.isDrawingMode) {
            cv.freeDrawingBrush.color = colorStr;
          }
          cv.requestRenderAll();
          saveCurrent();
        }
      }

      // コンテキストメニュー関連の修正
      function openColorDialog(type, currentColor) {
        setColorVal(currentColor);
        setContextMenu({ colorType: type });
        setColorDlg(true);
      }

      // 色変更ダイアログの適用処理修正
      function applyColor() {
        if (!contextMenu?.colorType) return;
        
        const type = contextMenu.colorType;
        const canvas = contextMenu.canvas || fabricRef.current;
        const obj = contextMenu.target;
        
        if (type === 'text') {
          setTextStyle(s => ({ ...s, fill: colorVal }));
        } else if (obj?.set) {
          const alpha = type === 'fill' ? fillColor.alpha : strokeColor.alpha;
          const colorStr = colorToString({ color: colorVal, alpha });
          obj.set(type, colorStr);
          canvas.requestRenderAll();
          saveCurrent();
        } else {
          handleColorChange(type, colorVal);
        }
      
        setColorDlg(false);
        setContextMenu(null);
      }

      // 3. アートボード削除の修正
      function deleteBoard(id) {
        if (boards.length <= 1) {
          showConfirm('エラー', '最後のアートボードは削除できません', () => { });
          return;
        }
        showConfirm(
          '確認',
          'このアートボードを削除しますか？',
          () => {
            const idx = boards.findIndex(b => b.id === id);
            const newBoards = boards.filter(b => b.id !== id);
            setBoards(newBoards);
            if (cur === idx) {
              setCur(Math.max(0, cur - 1));
              setTimeout(() => loadBoard(Math.max(0, cur - 1)), 0);
            }
          }
        );
      }

      // オブジェクトブラウザーの色変更処理
      function handleLayerColorChange(layer, type, newColor, newAlpha = null) {
        const obj = layer.obj;
        if (!obj) return;
      
        // 現在のキャンバスを取得
        let cv;
        if (workspaceMode === 'workspace') {
          const canvasElem = document.getElementById(`fabricCanvas-${cur}`);
          if (!canvasElem?._dynamicCanvas) return;
          cv = canvasElem._dynamicCanvas;
        } else {
          cv = fabricRef.current;
        }
      
        const colorStr = colorToString({
          color: newColor,
          alpha: newAlpha ?? (type === 'fill' ? fillColor.alpha : strokeColor.alpha)
        });
      
        obj.set(type, colorStr);
        cv.requestRenderAll();
        
        // 状態を保存
        saveCurrent();
        updateLayers();
      }
      
      // 補助関数 hexToRgb の追加
      function hexToRgb(hex) {
        if (!hex) return null;
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
          r: parseInt(result[1], 16),
          g: parseInt(result[2], 16),
          b: parseInt(result[3], 16)
        } : null;
      }
      
      // テキストスタイル関連の状態を追加
      const [textStyle, setTextStyle] = React.useState({
        fontSize: 20,
        fill: '#000000',
        fontFamily: 'sans-serif'
      });

      // テキスト追加処理の修正
      function handleAddText() {
        if (textVal.trim()) {
          const t = new fabric.Textbox(textVal, {
            left: 70,
            top: 70,
            ...textStyle,
            width: 200
          });
          fabricRef.current.add(t).setActiveObject(t);
          saveCurrent();
        }
        setTextVal('');
        setTextDlg(false);
      }

      // テキストダイアログのカラーピッカー処理
      function handleTextColor() {
        setColorVal(textStyle.fill);
        setContextMenu({ colorType: 'text' });
        setColorDlg(true);
      }

      const handleConfirmClose = () => {
        setConfirmDlg(prev => ({ ...prev, open: false }));
      };

      const handleConfirm = () => {
        if (confirmDlg.onConfirm) {
          confirmDlg.onConfirm();
        }
        setConfirmDlg(prev => ({ ...prev, open: false }));
      };

      const showConfirm = (title, message, onConfirm) => {
        setConfirmDlg({
          open: true,
          title,
          message,
          onConfirm
        });
      };

      // 追加: ワークスペースズーム・パン
      const [wsZoom, setWsZoom] = React.useState(1);
      const [wsOffset, setWsOffset] = React.useState({ x: 0, y: 0 });
      const [wsDragging, setWsDragging] = React.useState(false);
      const [wsLastPos, setWsLastPos] = React.useState(null);

      // アートボード初期配置
      React.useEffect(() => {
        if (artboardPositions.length === 0 && boards.length > 0) {
          setArtboardPositions(boards.map((_, i) => ({
            x: i * 50 + 100,
            y: i * 50 + 100
          })));
        }
      }, [boards]);

      // 衝突しない位置を計算
      function getNonOverlappingPosition(idx, x, y) {
        const SPACING = 10;
        const w = boards[idx].w + 10, h = boards[idx].h + 40;
        let nx = x, ny = y;
        for (let i = 0; i < boards.length; ++i) {
          if (i === idx) continue;
          const pos = artboardPositions[i];
          if (!pos) continue;
          const ow = boards[i].w + 10, oh = boards[i].h + 40;
          // 衝突判定
          if (
            nx < pos.x + ow + SPACING &&
            nx + w + SPACING > pos.x &&
            ny < pos.y + oh + SPACING &&
            ny + h + SPACING > pos.y
          ) {
            // 右にずらす
            nx = pos.x + ow + SPACING;
            // 再チェック
            i = -1;
          }
        }
        return { x: nx, y: ny };
      }

      // ドラッグ開始
      const handleDragStart = (e, index) => {
        if (workspaceMode !== 'workspace') return;
        setIsDragging(true);
        const rect = e.currentTarget.getBoundingClientRect();
        setDragOffset({
          x: e.clientX - rect.left,
          y: e.clientY - rect.top
        });
      };

      // ドラッグ中
      const handleDrag = (e) => {
        if (!isDragging) return;
        const workspace = document.querySelector('.workspace-content');
        const rect = workspace.getBoundingClientRect();
        const x = (e.clientX - rect.left - dragOffset.x) / wsZoom;
        const y = (e.clientY - rect.top - dragOffset.y) / wsZoom;
        const newPos = getNonOverlappingPosition(cur, x, y);
        setArtboardPositions(prev => prev.map((pos, i) =>
          i === cur ? newPos : pos
        ));
      };

      // ドラッグ終了
      const handleDragEnd = () => {
        setIsDragging(false);
        // 追加: ワークスペースモードの場合、動的キャンバスの状態を保存
        if (workspaceMode === 'workspace') {
          const canvasElem = document.getElementById(`fabricCanvas-${cur}`);
          if (canvasElem && canvasElem._dynamicCanvas) {
            const dynamicCV = canvasElem._dynamicCanvas;
            const newJson = dynamicCV.toJSON();
            setBoards(bs => bs.map((b, i) =>
              i === cur ? { ...b, json: newJson } : b
            ));
          }
        }
      };

      // ワークスペースズーム
      const handleWsZoom = (delta) => {
        setWsZoom(z => {
          const newZoom = Math.max(0.1, Math.min(2, z + delta));
          // 中心を維持
          const workspace = document.querySelector('.workspace');
          const centerX = workspace ? workspace.clientWidth / 2 : 0;
          const centerY = workspace ? workspace.clientHeight / 2 : 0;
          const scale = newZoom / z;
          setWsOffset(off => ({
            x: centerX - (centerX - off.x) * scale,
            y: centerY - (centerY - off.y) * scale
          }));
          return newZoom;
        });
      };

      // 全体表示
      const fitWorkspaceToScreen = () => {
        if (boards.length === 0) return;
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        boards.forEach((b, i) => {
          const pos = artboardPositions[i] || { x: 0, y: 0 };
          minX = Math.min(minX, pos.x);
          minY = Math.min(minY, pos.y);
          maxX = Math.max(maxX, pos.x + b.w + 32);
          maxY = Math.max(maxY, pos.y + b.h + 64);
        });
        const workspace = document.querySelector('.workspace');
        const wsWidth = workspace ? workspace.clientWidth : 500;
        const wsHeight = workspace ? workspace.clientHeight : 600;
        const scaleX = (wsWidth - 100) / (maxX - minX);
        const scaleY = (wsHeight - 100) / (maxY - minY);
        const newZoom = Math.min(1, Math.min(scaleX, scaleY));
        const centerX = (wsWidth - (maxX - minX) * newZoom) / 2 - minX * newZoom;
        const centerY = (wsHeight - (maxY - minY) * newZoom) / 2 - minY * newZoom;
        setWsZoom(newZoom);
        setWsOffset({ x: centerX, y: centerY });
      };

      // ワークスペースパン
      const handleWsMouseDown = (e) => {
        const workspace = document.querySelector('.workspace');
        // アートボード本体やキャンバス上ならパン開始も選択解除もせず抜ける
        if (
          e.target.closest('.artboard-wrapper') ||
          e.target.tagName === 'CANVAS'
        ) {
          return;
        }
        // 背景（workspace）をクリックしたときだけパン開始＆選択解除
        if (e.target === workspace) {
          setWsDragging(true);
          setWsLastPos({ x: e.clientX, y: e.clientY });
          const canvasElem = document.getElementById(`fabricCanvas-${cur}`);
          if (canvasElem && canvasElem._dynamicCanvas) {
            // 背景ドラッグ時のみアクティブ選択をクリア
            canvasElem._dynamicCanvas.discardActiveObject();
            canvasElem._dynamicCanvas.requestRenderAll();
          }
        }
      };
      const handleWsMouseMove = (e) => {
        if (wsDragging && wsLastPos) {
          setWsOffset(off => ({
            x: off.x + (e.clientX - wsLastPos.x),
            y: off.y + (e.clientY - wsLastPos.y)
          }));
          setWsLastPos({ x: e.clientX, y: e.clientY });
        }
        if (isDragging) handleDrag(e);
      };
      const handleWsMouseUp = () => {
        setWsDragging(false);
        setWsLastPos(null);
        handleDragEnd();
      };

      
      // ワークスペースモード切替時に全体表示
      React.useEffect(() => {
        if (workspaceMode === 'workspace') fitWorkspaceToScreen();
      }, [workspaceMode]);

      // mainContentの修正部分
      const mainContent = () => {
        if (workspaceMode === 'workspace') {
          return (
            <>
              <div
                className="workspace"
                onMouseDown={handleWsMouseDown}
                onMouseMove={handleWsMouseMove}
                onMouseUp={handleWsMouseUp}
                onWheel={e => {
                  if (e.ctrlKey) {
                    e.preventDefault();
                    handleWsZoom(-e.deltaY * 0.01);
                  }
                }}
                tabIndex={0}
                style={{ outline: 'none' }}
              >
                <div
                  className="workspace-content"
                  style={{
                    transform: `scale(${wsZoom})`,
                    transformOrigin: '0 0',
                    marginLeft: wsOffset.x,
                    marginTop: wsOffset.y
                  }}
                >
                  {boards.map((b, i) => (
                    <div
                      key={b.id}
                      className={`artboard-wrapper${i === cur ? ' focused' : ''}${isDragging && i === cur ? ' dragging' : ''}`}
                      style={{
                        left: artboardPositions[i]?.x || 0,
                        top: artboardPositions[i]?.y || 0,
                        width: b.w + 4,
                        height: b.h + 42
                      }}
                      // ヘッダー以外の領域ではドラッグ開始しないようにしています
                    >
                      <div 
                        className="artboard-header"
                        onMouseDown={e => {
                          e.stopPropagation(); // ← 追加
                          setCur(i);
                          handleDragStart(e, i);
                        }}
                      >
                        <Typography variant="body2">{b.name}</Typography>
                        <Typography variant="caption">{b.w} × {b.h}px</Typography>
                      </div>
                      <canvas
                        id={`fabricCanvas-${i}`}
                        width={b.w}
                        height={b.h}
                        style={{ margin: 0, display: 'block' }}
                      />
                    </div>
                  ))}
                </div>
              </div>
              <div className="workspace-tools" style={{
                position: 'fixed', bottom: 16, right: 16, display: 'flex', gap: 8, zIndex: 1000, background: '#fff', borderRadius: 4, boxShadow: '0 2px 8px rgba(0,0,0,0.1)', padding: 8
              }}>
                <IconButton size="small" onClick={() => handleWsZoom(-0.1)}>
                  <span className="material-icons">remove</span>
                </IconButton>
                <Typography variant="body2" sx={{ minWidth: 60, textAlign: 'center' }}>
                  {Math.round(wsZoom * 100)}%
                </Typography>
                <IconButton size="small" onClick={() => handleWsZoom(0.1)}>
                  <span className="material-icons">add</span>
                </IconButton>
                <IconButton size="small" onClick={fitWorkspaceToScreen}>
                  <span className="material-icons">fit_screen</span>
                </IconButton>
              </div>
            </>
          );
        } else {
          return (
            <Box className="canvas-container">
              <div className="canvas-wrapper" style={{ transform: `scale(${zoom})` }}>
                <canvas
                  id="fabricCanvas"
                  width={boards[cur].w}
                  height={boards[cur].h}
                />
              </div>

              <StatusBar
                fillColor={fillColor}
                strokeColor={strokeColor}
                boardSize={{ w: boards[cur].w, h: boards[cur].h }}
                onColorClick={(type, color) => {
                  setColorVal(color);
                  setContextMenu(cm => ({ ...cm, colorType: type }));
                  setColorDlg(true);
                }}
                onSizeClick={handleSize}
              />

              <ZoomControls
                zoom={zoom}
                onZoomChange={handleZoom}
              />
            </Box>
          );
        }
      };

      // モード切替コントロールを追加
      const modeControls = (
        <div className="workspace-mode">
          <ToolBtn 
            icon="dashboard"
            label="ワークスペースモード"
            active={workspaceMode === 'workspace'}
            onClick={() => setWorkspaceMode('workspace')}
          />
          <ToolBtn
            icon="edit"
            label="アートボード編集モード" 
            active={workspaceMode === 'artboard'}
            onClick={() => setWorkspaceMode('artboard')}
          />
        </div>
      );

      return (
        <Box sx={{ height: '100%', display: 'flex' }}
          onDragOver={e => e.preventDefault()}
          onDrop={e => addImage(e.dataTransfer.files[0])}
          onWheel={e => {
            if (e.ctrlKey) {
              e.preventDefault();
              handleZoom(e.deltaY > 0 ? -0.1 : 0.1);
            }
          }}
          onContextMenu={handleCanvasContext}
        >
          <CssBaseline />
          <AppBar position="fixed" sx={{ zIndex: t => t.zIndex.drawer + 1 }}>
            <Toolbar variant="dense">
              <IconButton color="inherit" edge="start" onClick={() => setDrawerOpen(true)}>
                <span className="material-icons">menu</span>
              </IconButton>
              <Typography sx={{ flexGrow: 1 }} variant="h6">絵描き</Typography>
              <IconButton color="inherit" onClick={() => togglePanel('artboards')}>
                <span className="material-icons">dashboard</span>
              </IconButton>
              <IconButton color="inherit" onClick={() => togglePanel('objects')}>
                <span className="material-icons">layers</span>
              </IconButton>
              {/* AppBarのボタンの処理を修正 */}
              <IconButton color="inherit" onClick={() => setGalleryDlg(true)}>
                <span className="material-icons">grid_view</span>
              </IconButton>
              <IconButton color="inherit" onClick={() => setExportDlg(true)}>
                <span className="material-icons">download</span>
              </IconButton>
            </Toolbar>
          </AppBar>

          {/* Drawer */} 
          <Drawer variant="temporary" open={drawerOpen} onClose={() => setDrawerOpen(false)} ModalProps={{ keepMounted: true }}>
            {drawerContent}
          </Drawer>

          {/* Main */}
          <Box sx={{ flex: 1, display: 'flex', flexDirection: 'column', overflow: 'hidden' }}>
            <Toolbar variant="dense" />

            {/* ツールバーを常に表示 */}
            <Box className="tool-scroll">
              <div className="tool-group">
                <ToolBtn icon="undo" label="元に戻す" onClick={undo} disabled={!canUndo} />
                <ToolBtn icon="redo" label="やり直す" onClick={redo} disabled={!canRedo} />
              </div>
              <div className="tool-group">
                <ToolBtn icon="mouse" label="選択" active={tool === 'select'} onClick={() => selectTool('select')} />
                <ToolBtn icon="draw" label="フリードロー" active={tool === 'draw'} onClick={() => selectTool('draw')} />
              </div>
              <div className="tool-group">
                <ToolBtn icon="crop_square" label="矩形" active={tool === 'rect'} onClick={() => handleShape('rect')} />
                <ToolBtn icon="circle" label="楕円" active={tool === 'ellipse'} onClick={() => handleShape('ellipse')} />
                <ToolBtn icon="arrow_forward" label="矢印" active={tool === 'arrow'} onClick={() => handleShape('arrow')} />
              </div>
              <div className="tool-group">
                <ToolBtn icon="title" label="テキスト" onClick={() => setTextDlg(true)} />
                <ToolBtn icon="image" label="画像" onClick={() => document.getElementById('fileUp').click()} />
              </div>
              <div className="tool-group">
                <ColorControl
                  label="塗りの色"
                  color={fillColor.color}
                  alpha={fillColor.alpha}
                  onColor={c => setFillColor(fc => ({ ...fc, color: c }))}
                  onAlpha={a => setFillColor(fc => ({ ...fc, alpha: a }))}
                />
                <ColorControl
                  label="線の色"
                  color={strokeColor.color}
                  alpha={strokeColor.alpha}
                  onColor={c => setStrokeColor(sc => ({ ...sc, color: c }))}
                  onAlpha={a => setStrokeColor(sc => ({ ...sc, alpha: a }))}
                />
              </div>
              <div className="tool-group">
                <ToolBtn icon="camera_alt" label="カメラ" onClick={startCamera} />
              </div>
            </Box>

            {modeControls}
            {mainContent()}
          </Box>

          {/* 隠しファイル入力 */}
          <input id="fileUp" type="file" accept="image/*" style={{ display: 'none' }}
            onChange={e => addImage(e.target.files[0])} />

          {/* コンテキストメニュー */}
          <Menu open={!!contextMenu} onClose={closeContextMenu}
            anchorReference="anchorPosition"
            anchorPosition={contextMenu ? { top: contextMenu.mouseY, left: contextMenu.mouseX } : undefined}
          >
            {contextMenuItems.map(item => (
              item.type === 'divider'
                ? <Divider key={item.label} />
                : <MenuItem key={item.label} onClick={() => {
                  item.action && item.action();
                  closeContextMenu();
                }}>
                  {item.label}
                </MenuItem>
            ))}
          </Menu>

          {/* 色変更ダイアログ */}
          <Dialog open={colorDlg} onClose={() => setColorDlg(false)}>
            <DialogTitle>
              {contextMenu?.colorType === 'fill' ? '塗りの色を選択' : '線の色を選択'}
            </DialogTitle>
            <DialogContent>
              <div className="color-controls">
                <div className="color-preview-large" style={{
                  background: colorToString({ color: colorVal, alpha:
                    contextMenu?.colorType === 'fill' ? fillColor.alpha : strokeColor.alpha
                  })
                }} />
                <div className="color-input-group">
                  <div className="color-input-row">
                    <input type="color"
                      value={colorVal}
                      onChange={e => setColorVal(e.target.value)}
                      style={{ width: '60px',height: 40 }}
                    />
                    <Slider
                      className="alpha-slider"
                      value={contextMenu?.colorType === 'fill' ?fillColor.alpha : strokeColor.alpha}
                      min={0}
                      max={1}
                      step={0.01}
                      onChange={(e, val) => {
                        if (contextMenu?.colorType === 'fill') {
                          setFillColor(c => ({ ...c, alpha: val }));
                        } else {
                          setStrokeColor(c => ({ ...c, alpha: val }));
                        }
                      }}
                    />
                  </div>
                  <Typography variant="caption" align="center">
                    透明度: {Math.round((contextMenu?.colorType === 'fill' ? fillColor.alpha : strokeColor.alpha) * 100)}%
                  </Typography>
                </div>
              </div>
            </DialogContent>
            <DialogActions>
              <Button onClick={e => setColorDlg(false)}>キャンセル</Button>
              <Button onClick={applyColor} variant="contained">適用</Button>
            </DialogActions>
          </Dialog>

          {/* テキストダイアログ */}
          <Dialog open={textDlg} onClose={() => setTextDlg(false)} maxWidth="sm" fullWidth>
            <DialogTitle>テキスト追加</DialogTitle>
            <DialogContent>
              <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2, mt: 1 }}>
                <TextField
                  fullWidth
                  multiline
                  rows={3}
                  label="テキスト"
                  placeholder="ここに入力してください"
                  value={textVal}
                  onChange={e => setTextVal(e.target.value)}
                />
                <FormControl fullWidth>
                  <FormLabel>スタイル</FormLabel>
                  <Box sx={{ display: 'flex', gap: 2, mt: 1 }}>
                    <TextField
                      type="number"
                      label="フォントサイズ"
                      value={textStyle.fontSize}
                      onChange={e => setTextStyle(s => ({ ...s, fontSize: parseInt(e.target.value) }))}
                      InputProps={{ inputProps: { min: 8, max: 144 } }}
                    />
                    <Button
                      variant="outlined"
                      onClick={handleTextColor}
                      sx={{ minWidth: 120 }}
                    >
                      文字色
                      <Box sx={{
                        width: 20, height: 20, ml: 1,
                        backgroundColor: textStyle.fill,
                        border: '2px solid #fff',
                        borderRadius                        : 1,
                        boxShadow: '0 0 0 1px rgba(0,0,0,0.1)'
                      }} />
                    </Button>
                  </Box>
                </FormControl>
              </Box>         
              </DialogContent>
            <DialogActions>
              <Button onClick={() => setTextDlg(false)}>キャンセル</Button>
              <Button onClick={handleAddText} variant="contained"
                disabled={!textVal.trim()}>追加</Button>
            </DialogActions>
          </Dialog>

          {/* サイズダイアログ */}
          <Dialog open={sizeDlg} onClose={() => setSizeDlg(false)}>
            <DialogTitle>ボードサイズ変更</DialogTitle>
            <DialogContent sx={{ display: 'flex', gap: 2, mt: 1 }}>
              <TextField type="number" label="幅(px)" fullWidth
                value={sizeVal.w} onChange={e => setSizeVal(s => ({ ...s, w: e.target.value }))} />
              <TextField type="number" label="高さ(px)" fullWidth
                value={sizeVal.h} onChange={e => setSizeVal(s => ({ ...s, h: e.target.value }))} />
            </DialogContent>
            <DialogActions>
              <Button onClick={() => setSizeDlg(false)}>キャンセル</Button>
              <Button onClick={() => {

                const w = parseInt(sizeVal.w, 10), h = parseInt(sizeVal.h, 10);
                if (w > 0 && h > 0) {
                  // 既存のコンテンツを保持したままサイズ変更
                  const cv = fabricRef.current;
                  cv.setWidth(w).setHeight(h);
                  cv.renderAll();

                  setBoards(bs => bs.map((b, i) => i === cur ? {
                    ...b,
                    w, h,
                    json: cv.toJSON()
                  } : b));
                  saveCurrent();
                  setSizeDlg(false);
                }
              }}>適用</Button>
            </DialogActions>
          </Dialog>

          {/* カメラダイアログ */}
          <Dialog open={!!camera} onClose={() => setCamera(null)} maxWidth="sm" fullWidth>
            <DialogTitle>写真を撮影</DialogTitle>
            <DialogContent>
              <Box sx={{ position: 'relative', width: '100%', paddingTop: '75%' }}>
                <video
                  autoPlay
                  style={{ position: 'absolute', top: 0, left: 0, width: '100%', height: '100%' }}
                  ref={video => {
                    if (video && camera) video.srcObject = camera;
                  }}
                />
              </Box>
            </DialogContent>
            <DialogActions>
              <Button onClick={() => setCamera(null)}>キャンセル</Button>
              <Button onClick={takePhoto} variant="contained">撮影</Button>
            </DialogActions>
          </Dialog>

          {/* ギャラリーダイアログ */}
          <Dialog open={galleryDlg} onClose={() => setGalleryDlg(false)} maxWidth="lg" fullWidth>
            <DialogTitle>アートボード一覧</DialogTitle>
            <DialogContent>
              <Grid container spacing={2} sx={{ mt: 1 }}>
                {boards.map((b, i) => (
                  <Grid item xs={12} sm={6} md={4} lg={3} key={b.id}>
                    <Card>
                      <CardActionArea onClick={() => {
                        saveCurrent();
                        setCur(i);
                        setGalleryDlg(false);
                      }}>
                        <div className="thumb-container">
                          <canvas className="thumb" ref={node => {
                            if (!node) return;
                            node.width = b.w;
                            node.height = b.h;
                            const ctx = node.getContext('2d');
                            ctx.fillStyle = '#fff';
                            ctx.fillRect(0, 0, b.w, b.h);
                            if (b.json) {
                              const tmp = new fabric.StaticCanvas(null, { width: b.w, height: b.h });
                              tmp.loadFromJSON(b.json, () => {
                                tmp.renderAll();
                                ctx.drawImage(tmp.lowerCanvasEl, 0, 0);
                                tmp.dispose();
                              });
                            }
                          }} />
                        </div>
                        <CardContent>
                          <Typography variant="subtitle1">{b.name}</Typography>
                          <Typography variant="body2" color="textSecondary">
                            {b.w} × {b.h}px
                          </Typography>
                        </CardContent>
                      </CardActionArea>
                    </Card>
                  </Grid>
                ))}
              </Grid>
            </DialogContent>
          </Dialog>

          {/* Excel出力設定ダイアログ */}
          <Dialog open={exportDlg} onClose={() => setExportDlg(false)} maxWidth="sm" fullWidth>
            <DialogTitle>Excel出力設定</DialogTitle>
            <DialogContent>
              <Box sx={{ mt: 2 }}>
                <FormControl component="fieldset" sx={{ mb: 2 }}>
                  <FormLabel>用紙サイズ</FormLabel>
                  <RadioGroup
                    value={exportOpts.paperSize}
                    onChange={(e) => setExportOpts(prev => ({ ...prev, paperSize: e.target.value }))}
                  >
                    <FormControlLabel value="A4" control={<Radio />} label="A4" />
                    <FormControlLabel value="A3" control={<Radio />} label="A3" />
                  </RadioGroup>
                </FormControl>

                <FormControl component="fieldset">
                  <FormLabel>用紙の向き</FormLabel>
                  <RadioGroup
                    value={exportOpts.orientation}
                    onChange={(e) => setExportOpts(prev => ({ ...prev, orientation: e.target.value }))}
                  >
                    <FormControlLabel value="portrait" control={<Radio />} label="縦" />
                    <FormControlLabel value="landscape" control={<Radio />} label="横" />
                  </RadioGroup>
                </FormControl>
              </Box>
            </DialogContent>
            <DialogActions>
              <Button onClick={() => setExportDlg(false)}>キャンセル</Button>
              <Button onClick={handleExport} variant="contained">出力</Button>
            </DialogActions>
          </Dialog>

          {/* Floating Panels */}
          {panels.artboards.open && (
            <div id="artboards" className="panel"
              style={{ left: panels.artboards.x, top: panels.artboards.y }}>
              <div className="panel-header" onMouseDown={e => startDrag(e, 'artboards')}>
                <Typography variant="subtitle2">アートボード</Typography>
                <Box sx={{ display: 'flex', gap: 1 }}>
                  <IconButton size="small" onClick={addNewBoard}>
                    <span className="material-icons">add</span>
                  </IconButton>
                  <IconButton size="small" onClick={() => setPanels(p => ({ ...p, artboards: { ...p.artboards, open: false } }))}>
                    <span className="material-icons">close</span>
                  </IconButton>
                </Box>
              </div>
              <List dense>
                {boards.map((b, i) => (

                  <ListItem button key={b.id} selected={i === cur}
                    onClick={() => { saveCurrent(); setCur(i); setView('single'); }}
                    secondaryAction={
                      <Box sx={{ display: 'flex', gap: 0.5 }}>
                        <IconButton size="small" onClick={e => { e.stopPropagation(); handleSize(); }}>
                          <span className="material-icons">straighten</span>
                        </IconButton>
                        <IconButton size="small" onClick={e => {
                          e.stopPropagation();
                          deleteBoard(b.id);
                        }}>
                          <span className="material-icons">delete</span>
                        </IconButton>
                      </Box>
                    }
                  >
                    <ListItemText
                      primary={b.name}
                      secondary={`${b.w} × ${b.h}px`}
                      primaryTypographyProps={{ variant: 'body2' }}
                      secondaryTypographyProps={{ variant: 'caption' }}
                    />
                  </ListItem>
                ))}
              </List>
            </div>
          )}

          {/* オブジェクトブラウザー */}
          {panels.objects.open && (
            <div id="objects" className="panel"
              style={{ left: panels.objects.x, top: panels.objects.y }}>
              <div className="panel-header" onMouseDown={e => startDrag(e, 'objects')}>
                <Typography variant="subtitle2">オブジェクト</Typography>
                <IconButton size="small" onClick={() => setPanels(p => ({ ...p, objects: { ...p.objects, open: false } }))}>
                  <span className="material-icons">close</span>
                </IconButton>
              </div>
              <List dense sx={{ p: 0 }}>
                {layers.map((layer, index) => (
                  <ListItem
                    key={layer.id}
                    className="object-list-item"
                    selected={fabricRef.current?.getActiveObject() === layer.obj}
                    onClick={e => {
                      e.stopPropagation();
                      selectObject(layer.obj);
                    }}
                    draggable
                    onDragStart={e => {
                      e.dataTransfer.setData('application/json', JSON.stringify({ index }));
                      e.currentTarget.style.opacity = '0.5';
                    }}
                    onDragEnd={e => { e.currentTarget.style.opacity = ''; }}
                    onDragOver={e => {
                      e.preventDefault();
                      e.currentTarget.style.borderTop = '2px solid #2196f3';
                    }}
                    onDragLeave={e => { e.currentTarget.style.borderTop = ''; }}
                    onDrop={e => {
                      e.preventDefault();
                      e.currentTarget.style.borderTop = '';
                      try {
                        const data = JSON.parse(e.dataTransfer.getData('application/json'));
                        if (typeof data.index === 'number') {
                          handleLayerReorder(data.index, index);
                        }
                      } catch (err) { }
                    }}
                  >
                    {/* ドラッグハンドルとオブジェクトタイプアイコン */}
                    <span className="material-icons layer-handle">drag_indicator</span>
                    <span className="material-icons object-icon" style={{ fontSize: 20 }}>
                      {layer.obj.type === 'rect' ? 'crop_square' :
                       layer.obj.type === 'ellipse' ? 'circle' :
                       layer.obj.type === 'textbox' ? 'title' :
                       layer.obj.type === 'group' ? 'arrow_forward' :
                       'radio_button_unchecked'}
                    </span>
                    {editingLayer.id === layer.id ? (
                      <TextField
                        value={editingLayer.value}
                        variant="standard"
                        onChange={e => setEditingLayer({ ...editingLayer, value: e.target.value })}
                        onBlur={() => finishEditingLayer(layer.id)}
                        onKeyDown={e => { if (e.key === 'Enter') finishEditingLayer(layer.id); }}
                        autoFocus
                        onClick={e => e.stopPropagation()}
                      />
                    ) : (
                      <Typography
                        variant="body2"
                        sx={{ flexGrow: 1 }}
                        onClick={e => {
                          e.stopPropagation();
                          startEditingLayer(layer);
                        }}
                      >
                        {layer.name}
                      </Typography>
                    )}
                    <div className="object-controls" style={{ display: 'flex', gap: '8px', alignItems: 'center' }}>
                      <IconButton
                        size="small"
                        onClick={e => {
                          e.stopPropagation();
                          layer.obj.visible = !layer.obj.visible;
                          fabricRef.current.requestRenderAll();
                          saveCurrent();
                        }}
                      >
                        <span className="material-icons">
                          {layer.obj.visible ? 'visibility' : 'visibility_off'}
                        </span>
                      </IconButton>
                      {/* 改善したカラ―コントロールのレイアウト */}
                      <div className="color-controls-compact" style={{ display: 'flex', flexDirection: 'column', gap: '4px' }}>
                        <div style={{ display: 'flex', alignItems: 'center', gap: '4px' }}>
                          <label style={{ fontSize: '10px' }}>塗:</label>
                          <input
                            type="color"
                            value={layer.obj.fill 
                              ? (layer.obj.fill.startsWith('rgba') ? rgbaToHex(layer.obj.fill) : layer.obj.fill)
                              : '#000000'}
                            onClick={e => e.stopPropagation()}
                            onChange={e => {
                              e.preventDefault();
                              // 塗り色の場合はnewAlphaは変更なし(null)
                              handleLayerColorChange(layer, 'fill', e.target.value, null);
                            }}
                          />
                          <Slider
                            size="small"
                            value={getAlpha(layer.obj.fill)}
                            min={0}
                            max={1}
                            step={0.01}
                            sx={{ width: 60 }}
                            onClick={e => e.stopPropagation()}
                            onChange={(e, val) => {
                               const baseColor = layer.obj.fill 
                                  ? (layer.obj.fill.startsWith('rgba') ? rgbaToHex(layer.obj.fill) : layer.obj.fill)
                                  : '#000000';
                               handleLayerColorChange(layer, 'fill', baseColor, val);
                            }}
                          />
                        </div>
                        <div style={{ display: 'flex', alignItems: 'center', gap: '4px' }}>
                          <label style={{ fontSize: '10px' }}>線:</label>
                          <input
                            type="color"
                            value={layer.obj.stroke 
                              ? (layer.obj.stroke.startsWith('rgba') ? rgbaToHex(layer.obj.stroke) : layer.obj.stroke)
                              : '#000000'}
                            onClick={e => e.stopPropagation()}
                            onChange={e => {
                              e.preventDefault();
                              handleLayerColorChange(layer, 'stroke', e.target.value, null);
                            }}
                          />
                          <Slider
                            size="small"
                            value={getAlpha(layer.obj.stroke)}
                            min={0}
                            max={1}
                            step={0.01}
                            sx={{ width: 60 }}
                            onClick={e => e.stopPropagation()}
                            onChange={(e, val) => {
                               const baseColor = layer.obj.stroke 
                                  ? (layer.obj.stroke.startsWith('rgba') ? rgbaToHex(layer.obj.stroke) : layer.obj.stroke)
                                  : '#000000';
                               handleLayerColorChange(layer, 'stroke', baseColor, val);
                            }}
                          />
                        </div>
                      </div>
                      <IconButton
                        size="small"
                        onClick={e => {
                          e.stopPropagation();
                          handleDelete(layer.obj);
                        }}
                      >
                        <span className="material-icons">delete</span>
                      </IconButton>
                    </div>
                  </ListItem>
                ))}

              </List>
            </div>
          )}
          {/* 確認ダイアログ */}
          <Dialog
            open={confirmDlg.open}
            onClose={handleConfirmClose}
            aria-labelledby="alert-dialog-title"
            aria-describedby="alert-dialog-description"
          >
            
            <DialogTitle id="alert-dialog-title">
              {confirmDlg.title}
            </DialogTitle>
            <DialogContent>
              <DialogContentText id="alert-dialog-description">
                {confirmDlg.message}
              </DialogContentText>
            </DialogContent>
            <DialogActions>
              <Button onClick={handleConfirmClose}>キャンセル</Button>
              <Button onClick={handleConfirm} autoFocus>
                OK
              </Button>
            </DialogActions>
          </Dialog>
        </Box>
      );
      // fabric.Canvas インスタンスのイベントハンドラを統一的に設定する関数を追加
      function setupCanvasHandlers(canvas) {
        const saveEvents = [
          'object:added',
          'object:removed',
          'object:modified',
          'object:rotated',
          'object:scaled',
          'object:moved',
          'object:skewed',
          'path:created'
        ];
      
        // 各イベントにsaveCurrentを追加
        saveEvents.forEach(eventName => {
          canvas.on(eventName, () => {
            updateLayers();
            saveCurrent();
          });
        });
      
        // 選択イベントの処理を修正
        canvas.on('selection:created', (e) => {
          if (e?.target) {
            try {
              e.target.selectable = true;
              e.target.evented = true;
              e.target.setCoords();
            } catch (err) {
              console.warn('Selection coordinates update failed:', err);
            }
          }
          updateLayers();
        });
      
        canvas.on('selection:updated', (e) => {
          if (e?.target) {
            try {
              e.target.selectable = true;
              e.target.evented = true;
              e.target.setCoords();
            } catch (err) {
              console.warn('Selection coordinates update failed:', err);
            }
          }
          updateLayers();
        });
      
        canvas.on('object:moving', (e) => {
          if (e?.target) {
            try {
              e.target.selectable = true;
              e.target.evented = true;
            } catch (err) {
              console.warn('Object moving event failed:', err);
            }
          }
        });
      
        canvas.on('object:modified', (e) => {
          if (e?.target) {
            try {
              e.target.selectable = true;
              e.target.evented = true;
              e.target.setCoords();
              canvas.setActiveObject(e.target);
            } catch (err) {
              console.warn('Object modified event failed:', err);
            }
          }
          updateLayers();
          saveCurrent();
        });
      
        // コンテキストメニュー処理も修正
        canvas.on('mouse:down', opt => {
          if (opt.e.button === 2) {
            opt.e.preventDefault();
            const target = opt.target;
            if (target) {
              try {
                target.setCoords();
              } catch (err) {
                console.warn('Context menu coordinates update failed:', err);
              }
            }
            setContextMenu({
              mouseX: opt.e.clientX,
              mouseY: opt.e.clientY,
              target: target,
              canvas: canvas
            });
          }
        });
          // 上下両方のキャンバス要素で mousedown を止める
        ['upperCanvasEl','lowerCanvasEl'].forEach(elName => {
          canvas[elName].addEventListener('mousedown', e => {
            e.stopPropagation();
          });
        });
      
        canvas.upperCanvasEl.addEventListener('contextmenu', e => e.preventDefault());
      }
    }

    // 色関連のユーティリティ関数
    function rgbaToHex(rgba) {
   
      const match = rgba.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
      if (!match) return '#000000';
      const [_, r, g, b] = match;
      return `#${(1 << 24 | r << 16 | g << 8 | b).toString(16).slice(1)}`
    }

    function getAlpha(color) {
      if (!color) return 1;
      if (typeof color !== 'string') return 1;
      if (!color.startsWith('rgba')) return 1;
      const match = color.match(/rgba\(.*,\s*([\d.]+)\)/);
      return match ? parseFloat(match[1]) : 1;
    }



    ReactDOM.createRoot(document.getElementById('root')).render(<App />);

  </script>
</body>
</html>

