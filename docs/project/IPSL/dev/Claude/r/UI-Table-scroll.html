<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>ページスクロール固定ヘッダー（修正版）</title>
  <!-- MUI UMD／Emotion は省略 -->
  <style>
    body { margin: 16px; font-family: Roboto, sans-serif; }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState } = React;
    const {
      Box, Paper, Table, TableBody, TableCell,
      TableHead, TableRow, TablePagination,
      TextField, Typography, styled, useTheme
    } = MaterialUI;

    // 先頭列とヘッダーの sticky 定義
    const StickyHeaderCell = styled(TableCell)(({ theme }) => ({
      position: 'sticky',
      top: 0,
      backgroundColor: theme.palette.background.paper,
      zIndex: theme.zIndex.appBar + 1,
      whiteSpace: 'nowrap',
    }));
    const StickyFirstCellHeader = styled(TableCell)(({ theme }) => ({
      position: 'sticky',
      top: 0,
      left: 0,
      backgroundColor: theme.palette.background.paper,
      zIndex: theme.zIndex.appBar + 2,
      whiteSpace: 'nowrap',
    }));
    const StickyFirstCellBody = styled(TableCell)(({ theme }) => ({
      position: 'sticky',
      left: 0,
      backgroundColor: theme.palette.background.paper,
      zIndex: theme.zIndex.appBar,
      whiteSpace: 'nowrap',
    }));

    function FixedHeaderOnPageScroll() {
      const theme = useTheme();
      const headers = ['列1','列2','列3','列4','列5','列6','列7'];
      const allRows = Array.from({ length: 100 }, (_, i) =>
        headers.map(h => `データ${i+1}-${h}`)
      );

      const [filter, setFilter] = useState('');
      const [page, setPage] = useState(0);
      const [rowsPerPage, setRowsPerPage] = useState(10);

      const filtered = allRows.filter(r => r.some(c => c.includes(filter)));
      const minWidth = headers.length * 120;

      return (
        <Box>
          <Typography variant="h5" gutterBottom>データ一覧</Typography>
          <Box mb={2}>
            <TextField
              label="検索"
              variant="outlined"
              size="small"
              value={filter}
              onChange={e => { setFilter(e.target.value); setPage(0); }}
            />
          </Box>
          <Paper>
            {/* ← 横スクロールだけ。overflowY: visible がミソ */}
            <TableContainer
              component="div"
              sx={{
                overflowX: 'auto',
                overflowY: 'visible'
              }}
            >
              {/* stickyHeader でも OK */}
              <Table stickyHeader sx={{ minWidth }} size="small">
                <TableHead>
                  <TableRow>
                    {headers.map((h,i) =>
                      i===0
                        ? <StickyFirstCellHeader key={i}><strong>{h}</strong></StickyFirstCellHeader>
                        : <StickyHeaderCell key={i}><strong>{h}</strong></StickyHeaderCell>
                    )}
                  </TableRow>
                </TableHead>
                <TableBody>
                  {filtered
                    .slice(page*rowsPerPage, page*rowsPerPage+rowsPerPage)
                    .map((row, ri) => (
                      <TableRow key={ri}>
                        {row.map((c, ci) =>
                          ci===0
                            ? <StickyFirstCellBody key={ci}>{c}</StickyFirstCellBody>
                            : <TableCell key={ci} sx={{ whiteSpace:'nowrap' }}>{c}</TableCell>
                        )}
                      </TableRow>
                  ))}
                </TableBody>
              </Table>
            </TableContainer>
            <TablePagination
              component="div"
              count={filtered.length}
              page={page}
              onPageChange={(_,p) => setPage(p)}
              rowsPerPage={rowsPerPage}
              onRowsPerPageChange={e => {
                setRowsPerPage(+e.target.value);
                setPage(0);
              }}
              rowsPerPageOptions={[5,10,25,50]}
            />
          </Paper>
        </Box>
      );
    }

    ReactDOM.createRoot(document.getElementById('root'))
      .render(<FixedHeaderOnPageScroll />);
  </script>
</body>
</html>