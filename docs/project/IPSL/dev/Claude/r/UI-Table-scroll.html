<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Enhanced Sticky Header Table</title>
  <!-- Roboto & Icons -->
  <link
    href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;600&display=swap"
    rel="stylesheet"
  />
  <link
    href="https://fonts.googleapis.com/icon?family=Material+Icons"
    rel="stylesheet"
  />
  <!-- React & Babel -->
  <script src="https://cdn.jsdelivr.net/npm/react@18/umd/react.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@babel/standalone/babel.min.js"></script>
  <!-- Emotion & MUI -->
  <script src="https://cdn.jsdelivr.net/npm/@emotion/react@11.11.3/dist/emotion-react.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@emotion/styled@11.11.0/dist/emotion-styled.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mui/material@5.15.3/umd/material-ui.production.min.js"></script>
  <style>
    body { 
      margin: 0; 
      font-family: Roboto, sans-serif; 
      background-color: #f5f5f5;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 24px;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useMemo, useCallback } = React;
    const {
      styled,
      useTheme,
      Box,
      Paper,
      Typography,
      TextField,
      Table,
      TableHead,
      TableRow,
      TableCell,
      TableBody,
      TablePagination,
      InputAdornment,
      Chip,
      TableContainer,
      alpha
    } = MaterialUI;

    //――――――――――――――――――――――――――――――――
    // スティッキーセルの定義（改良版）
    //――――――――――――――――――――――――――――――――
    const StickyFirstHeaderCell = styled(TableCell)(({ theme }) => ({
      position: 'sticky',
      top: 0,
      left: 0,
      backgroundColor: theme.palette.primary.main,
      color: theme.palette.primary.contrastText,
      zIndex: theme.zIndex.appBar + 2,
      whiteSpace: 'nowrap',
      fontWeight: 600,
      borderRight: `2px solid ${theme.palette.divider}`,
      '&::after': {
        content: '""',
        position: 'absolute',
        right: 0,
        top: 0,
        bottom: 0,
        width: '4px',
        background: `linear-gradient(to right, ${alpha(theme.palette.common.black, 0.1)}, transparent)`,
      }
    }));

    const StickyHeaderCell = styled(TableCell)(({ theme }) => ({
      position: 'sticky',
      top: 0,
      backgroundColor: theme.palette.primary.main,
      color: theme.palette.primary.contrastText,
      zIndex: theme.zIndex.appBar + 1,
      whiteSpace: 'nowrap',
      fontWeight: 600,
      borderBottom: `2px solid ${theme.palette.primary.dark}`,
    }));

    const StickyFirstBodyCell = styled(TableCell)(({ theme }) => ({
      position: 'sticky',
      left: 0,
      backgroundColor: alpha(theme.palette.background.paper, 0.95),
      backdropFilter: 'blur(10px)',
      zIndex: theme.zIndex.appBar,
      whiteSpace: 'nowrap',
      fontWeight: 500,
      borderRight: `1px solid ${theme.palette.divider}`,
      '&::after': {
        content: '""',
        position: 'absolute',
        right: 0,
        top: 0,
        bottom: 0,
        width: '4px',
        background: `linear-gradient(to right, ${alpha(theme.palette.common.black, 0.05)}, transparent)`,
      }
    }));

    const StyledTableRow = styled(TableRow)(({ theme }) => ({
      '&:nth-of-type(odd)': {
        backgroundColor: alpha(theme.palette.primary.main, 0.02),
      },
      '&:hover': {
        backgroundColor: alpha(theme.palette.primary.main, 0.08),
        cursor: 'pointer',
      },
      transition: 'background-color 0.2s ease',
    }));

    const StyledTableContainer = styled(TableContainer)(({ theme }) => ({
      maxHeight: '70vh',
      overflowX: 'auto',
      overflowY: 'visible',
      borderRadius: theme.shape.borderRadius,
      boxShadow: theme.shadows[2],
      '&::-webkit-scrollbar': {
        height: '8px',
      },
      '&::-webkit-scrollbar-track': {
        backgroundColor: theme.palette.grey[200],
        borderRadius: '4px',
      },
      '&::-webkit-scrollbar-thumb': {
        backgroundColor: theme.palette.grey[400],
        borderRadius: '4px',
        '&:hover': {
          backgroundColor: theme.palette.grey[500],
        },
      },
    }));

    //――――――――――――――――――――――――――――――――
    // ダミーデータ生成関数
    //――――――――――――――――――――――――――――――――
    const generateSampleData = () => {
      const categories = ['システム', '営業', '管理', '開発', '設計'];
      const statuses = ['進行中', '完了', '保留', '計画中'];
      const priorities = ['高', '中', '低'];
      
      return Array.from({ length: 150 }, (_, i) => ({
        id: i + 1,
        name: `プロジェクト${String(i + 1).padStart(3, '0')}`,
        category: categories[Math.floor(Math.random() * categories.length)],
        status: statuses[Math.floor(Math.random() * statuses.length)],
        priority: priorities[Math.floor(Math.random() * priorities.length)],
        startDate: new Date(2024, Math.floor(Math.random() * 12), Math.floor(Math.random() * 28) + 1).toLocaleDateString('ja-JP'),
        endDate: new Date(2024, Math.floor(Math.random() * 12), Math.floor(Math.random() * 28) + 1).toLocaleDateString('ja-JP'),
        progress: Math.floor(Math.random() * 101) + '%',
        budget: (Math.floor(Math.random() * 1000) + 100) + '万円',
        manager: `担当者${i + 1}`,
        description: `プロジェクト${i + 1}の詳細説明文です。`
      }));
    };

    //――――――――――――――――――――――――――――――――
    // ステータスチップコンポーネント
    //――――――――――――――――――――――――――――――――
    const StatusChip = ({ status }) => {
      const getColor = (status) => {
        switch(status) {
          case '完了': return 'success';
          case '進行中': return 'primary';
          case '保留': return 'warning';
          case '計画中': return 'default';
          default: return 'default';
        }
      };

      return (
        <Chip 
          label={status} 
          color={getColor(status)} 
          size="small"
          variant="outlined"
        />
      );
    };

    //――――――――――――――――――――――――――――――――
    // メインコンポーネント
    //――――――――――――――――――――――――――――――――
    function App() {
      const theme = useTheme();
      const [filterText, setFilterText] = useState('');
      const [page, setPage] = useState(0);
      const [rowsPerPage, setRowsPerPage] = useState(15);

      // サンプルデータ
      const sampleData = useMemo(() => generateSampleData(), []);

      // テーブルヘッダー定義
      const headers = [
        { key: 'name', label: 'プロジェクト名', width: 200 },
        { key: 'category', label: 'カテゴリ', width: 120 },
        { key: 'status', label: 'ステータス', width: 120 },
        { key: 'priority', label: '優先度', width: 100 },
        { key: 'startDate', label: '開始日', width: 120 },
        { key: 'endDate', label: '終了日', width: 120 },
        { key: 'progress', label: '進捗', width: 100 },
        { key: 'budget', label: '予算', width: 120 },
        { key: 'manager', label: '担当者', width: 120 },
        { key: 'description', label: '説明', width: 300 }
      ];

      // フィルタリング処理
      const filteredData = useMemo(() => {
        if (!filterText) return sampleData;
        
        return sampleData.filter(row =>
          Object.values(row).some(value =>
            value.toString().toLowerCase().includes(filterText.toLowerCase())
          )
        );
      }, [sampleData, filterText]);

      // 検索入力のハンドラー
      const handleFilterChange = useCallback((e) => {
        setFilterText(e.target.value);
        setPage(0);
      }, []);

      // ページ変更のハンドラー
      const handlePageChange = useCallback((_, newPage) => {
        setPage(newPage);
      }, []);

      // 行数変更のハンドラー
      const handleRowsPerPageChange = useCallback((e) => {
        setRowsPerPage(parseInt(e.target.value, 10));
        setPage(0);
      }, []);

      // 表示データの計算
      const displayData = useMemo(() => {
        const start = page * rowsPerPage;
        const end = start + rowsPerPage;
        return filteredData.slice(start, end);
      }, [filteredData, page, rowsPerPage]);

      const minWidth = headers.reduce((acc, header) => acc + header.width, 0);

      return (
        <div className="container">
          <Box mb={4}>
            <Typography variant="h4" gutterBottom sx={{ fontWeight: 600, color: 'primary.main' }}>
              プロジェクト管理システム
            </Typography>
            <Typography variant="body1" color="text.secondary">
              全{sampleData.length}件のプロジェクトデータ
            </Typography>
          </Box>

          <Paper elevation={3} sx={{ borderRadius: 2, overflow: 'hidden' }}>
            {/* 検索バー */}
            <Box p={3} sx={{ backgroundColor: alpha(theme.palette.primary.main, 0.05) }}>
              <TextField
                fullWidth
                label="プロジェクト検索"
                variant="outlined"
                size="small"
                value={filterText}
                onChange={handleFilterChange}
                placeholder="プロジェクト名、カテゴリ、ステータスなどで検索..."
                InputProps={{
                  startAdornment: (
                    <InputAdornment position="start">
                      <span className="material-icons">search</span>
                    </InputAdornment>
                  ),
                }}
                sx={{ 
                  '& .MuiOutlinedInput-root': {
                    backgroundColor: 'white',
                  }
                }}
              />
              {filterText && (
                <Box mt={2}>
                  <Typography variant="body2" color="text.secondary">
                    検索結果: {filteredData.length}件
                  </Typography>
                </Box>
              )}
            </Box>

            {/* テーブル */}
            <StyledTableContainer>
              <Table sx={{ minWidth }} size="small">
                <TableHead>
                  <TableRow>
                    <StickyFirstHeaderCell sx={{ width: headers[0].width }}>
                      <Box display="flex" alignItems="center">
                        <span className="material-icons" style={{ marginRight: 8, fontSize: 20 }}>
                          folder
                        </span>
                        {headers[0].label}
                      </Box>
                    </StickyFirstHeaderCell>
                    {headers.slice(1).map((header) => (
                      <StickyHeaderCell key={header.key} sx={{ width: header.width }}>
                        {header.label}
                      </StickyHeaderCell>
                    ))}
                  </TableRow>
                </TableHead>

                <TableBody>
                  {displayData.map((row) => (
                    <StyledTableRow key={row.id}>
                      <StickyFirstBodyCell>
                        <Box display="flex" alignItems="center">
                          <span className="material-icons" style={{ marginRight: 8, fontSize: 16, color: theme.palette.primary.main }}>
                            assignment
                          </span>
                          {row.name}
                        </Box>
                      </StickyFirstBodyCell>
                      <TableCell sx={{ whiteSpace: 'nowrap' }}>
                        <Chip label={row.category} size="small" variant="outlined" />
                      </TableCell>
                      <TableCell sx={{ whiteSpace: 'nowrap' }}>
                        <StatusChip status={row.status} />
                      </TableCell>
                      <TableCell sx={{ whiteSpace: 'nowrap' }}>
                        <Chip 
                          label={row.priority} 
                          size="small" 
                          color={row.priority === '高' ? 'error' : row.priority === '中' ? 'warning' : 'default'}
                        />
                      </TableCell>
                      <TableCell sx={{ whiteSpace: 'nowrap' }}>{row.startDate}</TableCell>
                      <TableCell sx={{ whiteSpace: 'nowrap' }}>{row.endDate}</TableCell>
                      <TableCell sx={{ whiteSpace: 'nowrap' }}>
                        <Box display="flex" alignItems="center">
                          <Typography variant="body2" sx={{ minWidth: 40 }}>
                            {row.progress}
                          </Typography>
                        </Box>
                      </TableCell>
                      <TableCell sx={{ whiteSpace: 'nowrap' }}>{row.budget}</TableCell>
                      <TableCell sx={{ whiteSpace: 'nowrap' }}>{row.manager}</TableCell>
                      <TableCell sx={{ 
                        maxWidth: 300, 
                        overflow: 'hidden', 
                        textOverflow: 'ellipsis',
                        whiteSpace: 'nowrap'
                      }}>
                        {row.description}
                      </TableCell>
                    </StyledTableRow>
                  ))}
                </TableBody>
              </Table>
            </StyledTableContainer>

            {/* ページネーション */}
            <TablePagination
              component="div"
              count={filteredData.length}
              page={page}
              onPageChange={handlePageChange}
              rowsPerPage={rowsPerPage}
              onRowsPerPageChange={handleRowsPerPageChange}
              rowsPerPageOptions={[10, 15, 25, 50, 100]}
              labelRowsPerPage="表示行数:"
              labelDisplayedRows={({ from, to, count }) => 
                `${from}-${to} / ${count !== -1 ? count : to}件`
              }
              sx={{
                borderTop: `1px solid ${theme.palette.divider}`,
                backgroundColor: alpha(theme.palette.primary.main, 0.02),
              }}
            />
          </Paper>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>