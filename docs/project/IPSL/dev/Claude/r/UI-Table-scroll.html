<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>MUI レスポンシブ・スティッキー列＆ヘッダー</title>
  <!-- Roboto & Icons -->
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap" rel="stylesheet" />
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet" />
  <!-- React & Babel -->
  <script src="https://cdn.jsdelivr.net/npm/react@18/umd/react.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@babel/standalone/babel.min.js"></script>
  <!-- Emotion & MUI -->
  <script src="https://cdn.jsdelivr.net/npm/@emotion/react@11.11.3/dist/emotion-react.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@emotion/styled@11.11.0/dist/emotion-styled.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mui/material@5.15.3/umd/material-ui.production.min.js"></script>
  <style>
    body { font-family: Roboto, sans-serif; margin: 16px; }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef } = React;
    const {
      Box, Paper, Table, TableBody, TableCell, TableContainer,
      TableHead, TableRow, TablePagination, TextField, Typography,
      styled, useTheme
    } = MaterialUI;

    // ヘッダー固定セル
    const StickyHeaderCell = styled(TableCell)(({ theme }) => ({
      position: 'sticky',
      top: 0,
      backgroundColor: theme.palette.background.paper,
      zIndex: theme.zIndex.appBar + 1,
      whiteSpace: 'nowrap',
    }));
    // ヘッダー先頭セル（縦横両方向固定）
    const StickyFirstCellHeader = styled(TableCell)(({ theme }) => ({
      position: 'sticky',
      top: 0,
      left: 0,
      backgroundColor: theme.palette.background.paper,
      zIndex: theme.zIndex.appBar + 2,
      whiteSpace: 'nowrap',
    }));
    // 本文先頭セル（縦固定なし、横方向のみ固定）
    const StickyFirstCellBody = styled(TableCell)(({ theme }) => ({
      position: 'sticky',
      left: 0,
      backgroundColor: theme.palette.background.paper,
      zIndex: theme.zIndex.appBar,
      whiteSpace: 'nowrap',
    }));

    function ResponsiveStickyTable() {
      const theme = useTheme();
      const headerRef = useRef(null);
      const bodyRef = useRef(null);

      // ダミーデータ
      const headers = ['列1','列2','列3','列4','列5','列6','列7'];
      const allRows = Array.from({ length: 100 }, (_, i) =>
        headers.map(h => `データ${i + 1}-${h}`)
      );

      // フィルター＆ページング
      const [filterText, setFilterText] = useState('');
      const [page, setPage] = useState(0);
      const [rowsPerPage, setRowsPerPage] = useState(10);

      const filtered = allRows.filter(row =>
        row.some(cell => cell.includes(filterText))
      );

      // ヘッダー ↔ 本文 スクロール同期
      useEffect(() => {
        const hdr = headerRef.current;
        const bdy = bodyRef.current;
        if (!hdr || !bdy) return;
        const sync = () => { hdr.scrollLeft = bdy.scrollLeft; };
        bdy.addEventListener('scroll', sync);
        hdr.addEventListener('scroll', () => { bdy.scrollLeft = hdr.scrollLeft; });
        return () => {
          bdy.removeEventListener('scroll', sync);
          hdr.removeEventListener('scroll', () => {});
        };
      }, []);

      const minWidth = headers.length * 120;  // 列数に合わせた最小幅

      return (
        <Box>
          <Typography variant="h5" gutterBottom>データ一覧</Typography>
          <Box mb={2}>
            <TextField
              label="検索"
              variant="outlined"
              size="small"
              value={filterText}
              onChange={e => { setFilterText(e.target.value); setPage(0); }}
            />
          </Box>
          <Paper>
            {/* ヘッダー部：横スクロールのみ */}
            <div ref={headerRef} style={{ overflowX: 'auto' }}>
              <Table sx={{ minWidth }} size="small">
                <TableHead>
                  <TableRow>
                    {headers.map((h, i) =>
                      i === 0
                        ? <StickyFirstCellHeader key={i}><strong>{h}</strong></StickyFirstCellHeader>
                        : <StickyHeaderCell key={i}><strong>{h}</strong></StickyHeaderCell>
                    )}
                  </TableRow>
                </TableHead>
              </Table>
            </div>
            {/* 本文部：縦横スクロール */}
            <TableContainer
              ref={bodyRef}
              sx={{ maxHeight: 400, overflow: 'auto' }}
            >
              <Table sx={{ minWidth }} size="small">
                <TableBody>
                  {filtered
                    .slice(page * rowsPerPage, page * rowsPerPage + rowsPerPage)
                    .map((row, ri) => (
                      <TableRow key={ri}>
                        {row.map((cell, ci) =>
                          ci === 0
                            ? <StickyFirstCellBody key={ci}>{cell}</StickyFirstCellBody>
                            : <TableCell key={ci}>{cell}</TableCell>
                        )}
                      </TableRow>
                    ))}
                </TableBody>
              </Table>
            </TableContainer>
            <TablePagination
              component="div"
              count={filtered.length}
              page={page}
              onPageChange={(_, p) => setPage(p)}
              rowsPerPage={rowsPerPage}
              onRowsPerPageChange={e => { setRowsPerPage(+e.target.value); setPage(0); }}
              rowsPerPageOptions={[5, 10, 25, 50]}
            />
          </Paper>
        </Box>
      );
    }

    ReactDOM.createRoot(document.getElementById('root'))
      .render(<ResponsiveStickyTable />);
  </script>
</body>
</html>