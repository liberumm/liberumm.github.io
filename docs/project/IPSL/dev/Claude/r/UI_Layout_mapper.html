<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<title>CSV 管理ツール（完全版）</title>

<!-- ===== CDN ===== -->
<script src="https://cdn.jsdelivr.net/npm/react@18/umd/react.production.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/react-dom@18/umd/react-dom.production.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mui/material@5.15.14/umd/material-ui.production.min.js"></script>
<script src="https://unpkg.com/react-beautiful-dnd@13.1.0/dist/react-beautiful-dnd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.2/babel.min.js"></script>
<script src="https://unpkg.com/xlsx/dist/xlsx.full.min.js"></script>

<!-- Roboto / Icons -->
<link rel="stylesheet"
      href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap" />
<link rel="stylesheet"
      href="https://fonts.googleapis.com/icon?family=Material+Icons" />

<style>
body { margin: 0; padding: 16px; font-family: Roboto, sans-serif; }
#root { max-width: 1200px; margin: auto; }
.droppableBox {
  min-height: 44px; padding: 8px;
  border: 1px dashed #ccc; border-radius: 4px;
  background: #fafafa; overflow-x: auto;
}
.draggableItem {
  padding: 4px 8px; margin-bottom: 4px;
  background: #e0e0e0; border-radius: 4px;
  cursor: grab; user-select: none;
}
</style>
</head>
<body>
<div id="root"></div>

<script type="text/babel">
/* ----------- インポート ----------- */
const {
  Container, Box, Button, Typography,
  Table, TableHead, TableRow, TableCell, TableBody, TableContainer, Paper,
  Dialog, DialogTitle, DialogContent, DialogActions,
  Grid, TextField, FormControl, InputLabel, Select, MenuItem,
  useTheme, useMediaQuery
} = MaterialUI;
const { DragDropContext, Droppable, Draggable } = ReactBeautifulDnd;

/* ----------- 定数・サンプル ----------- */
const BASE_FIELDS = ["商品コード","商品名","数量","価格","日付"];
const STORAGE_KEY = "csvMappingTemplates_v1_demo";

const SAMPLE_CSV = {
  "日本語ヘッダー": `商品コード,商品名,数量,価格,日付
A001,りんご,10,120,2025-05-01`,
  "Englishヘッダー": `code,name,qty,price,date
B001,Apple,15,110,2025-05-03`,
  "ランダム順": `price,date,itemCode,itemName,quantity
200,2025-05-05,C001,オレンジ,12`
};

const DEFAULT_TEMPLATES = [
  { name: "JapaneseHeader", mapping: {
    "商品コード":"商品コード","商品名":"商品名","数量":"数量","価格":"価格","日付":"日付" } },
  { name: "EnglishHeader", mapping: {
    "商品コード":"code","商品名":"name","数量":"qty","価格":"price","日付":"date" } },
  { name: "ShuffledHeader", mapping: {
    "商品コード":"itemCode","商品名":"itemName","数量":"quantity","価格":"price","日付":"date" } }
];

if (!localStorage.getItem(STORAGE_KEY)) {
  localStorage.setItem(STORAGE_KEY, JSON.stringify(DEFAULT_TEMPLATES));
}

const csvTo2D = txt =>
  XLSX.utils.sheet_to_json(
    XLSX.read(txt, { type:"string" }).Sheets.Sheet1,
    { header:1, defval:"" }
  );

/* ----------- ルート ----------- */
function App() {
  const [rows, setRows] = React.useState([]);
  const [openMap, setOpenMap]   = React.useState(false);
  const [openImp, setOpenImp]   = React.useState(false);
  const [openExp, setOpenExp]   = React.useState(false);

  return (
    <Container maxWidth="lg">
      {/* 操作ボタン */}
      <Box mb={2} display="flex" flexWrap="wrap" gap={1}>
        <Button variant="outlined" onClick={()=>setOpenMap(true)}>マッピング定義</Button>
        <Button variant="outlined" onClick={()=>setOpenImp(true)}>インポート</Button>
        <Button variant="outlined" onClick={()=>setOpenExp(true)}>エクスポート</Button>
      </Box>

      {/* 基本テーブル */}
      <TableContainer component={Paper} sx={{ overflowX:"auto" }}>
        <Table size="small">
          <TableHead>
            <TableRow>
              {BASE_FIELDS.map(f => <TableCell key={f}>{f}</TableCell>)}
            </TableRow>
          </TableHead>
          <TableBody>
            {rows.length ? rows.map((r,i)=>(
              <TableRow key={i}>
                {BASE_FIELDS.map(f=> <TableCell key={f}>{r[f]}</TableCell>)}
              </TableRow>
            )) : (
              <TableRow>
                <TableCell colSpan={BASE_FIELDS.length} align="center">
                  データがありません
                </TableCell>
              </TableRow>
            )}
          </TableBody>
        </Table>
      </TableContainer>

      {/* モーダル */}
      <MappingDialog open={openMap} onClose={()=>setOpenMap(false)}/>
      <ImportDialog  open={openImp} onClose={()=>setOpenImp(false)}
                     onAdd={rowsToAdd=>setRows(prev=>[...prev,...rowsToAdd])}/>
      <ExportDialog open={openExp} onClose={()=>setOpenExp(false)} rows={rows}/>
    </Container>
  );
}

/* ----------- マッピング定義モーダル ----------- */
function MappingDialog({ open, onClose }) {
  const full = useMediaQuery(useTheme().breakpoints.down('sm'));

  /* 状態 */
  const [templates, setTemplates] = React.useState(
    () => JSON.parse(localStorage.getItem(STORAGE_KEY))
  );
  const [tplName, setTplName]     = React.useState("");
  const [headers, setHeaders]     = React.useState([]);
  const [sample, setSample]       = React.useState({});
  const [mapping, setMapping]     = React.useState({});
  const [unassigned, setUnassigned]=React.useState([]);
  const [sampleKey, setSampleKey] = React.useState("");

  /* 初期プレビュー生成 */
  const initPreview = arr => {
    const hdr = arr[0]||[];
    const smp = {}; hdr.forEach((h,i)=>smp[h]=(arr[1]||[])[i]||"");
    setHeaders(hdr); setSample(smp);
    setMapping(Object.fromEntries(BASE_FIELDS.map(f=>[f,null])));
    setUnassigned(hdr);
  };

  /* ファイル / サンプル選択 */
  const handleSample = key => {
    setSampleKey(key);
    if (!key) { setHeaders([]); return; }
    initPreview(csvTo2D(SAMPLE_CSV[key]));
  };
  const handleFile = e => {
    const f = e.target.files[0]; if(!f) return;
    setSampleKey("");
    const r = new FileReader();
    r.onload = ev => initPreview(csvTo2D(ev.target.result));
    r.readAsText(f,"utf-8");
  };

  /* DnD */
  const onDragEnd = res => {
    const { source,destination,draggableId } = res;
    if(!destination) return;
    const src=source.droppableId, dst=destination.droppableId;
    if(src==="unassigned" && dst==="unassigned"){
      const list=[...unassigned];
      list.splice(source.index,1);
      list.splice(destination.index,0,draggableId);
      setUnassigned(list); return;
    }
    if(src==="unassigned" && BASE_FIELDS.includes(dst)){
      const prev=mapping[dst];
      setUnassigned(unassigned.filter(h=>h!==draggableId).concat(prev?prev:[]));
      setMapping({...mapping,[dst]:draggableId}); return;
    }
    if(BASE_FIELDS.includes(src) && dst==="unassigned"){
      const hdr=mapping[src]; if(!hdr) return;
      const list=[...unassigned];
      list.splice(destination.index,0,hdr);
      setUnassigned(list);
      setMapping({...mapping,[src]:null}); return;
    }
    if(BASE_FIELDS.includes(src) && BASE_FIELDS.includes(dst)){
      const newMap={...mapping};
      [newMap[src], newMap[dst]] = [newMap[dst], newMap[src]];
      setMapping(newMap);
    }
  };

  /* 保存 / 新規 / 削除 */
  const saveTemplate = () => {
    if(!tplName) return alert("テンプレート名を入力してください");
    const next = templates.filter(t=>t.name!==tplName)
      .concat({ name:tplName, mapping });
    setTemplates(next);
    localStorage.setItem(STORAGE_KEY, JSON.stringify(next));
    alert("保存しました");
  };
  const deleteTemplate = () => {
    if(!tplName) return;
    if(!confirm("削除しますか？")) return;
    const next = templates.filter(t=>t.name!==tplName);
    setTemplates(next);
    localStorage.setItem(STORAGE_KEY, JSON.stringify(next));
    setTplName(""); setHeaders([]); setSampleKey("");
  };

  return (
    <Dialog fullScreen={full} fullWidth maxWidth="lg" open={open} onClose={onClose}>
      <DialogTitle>マッピング定義</DialogTitle>
      <DialogContent dividers>
        {/* テンプレート名操作 */}
        <Grid container spacing={2}>
          <Grid item xs={12} md={5}>
            <TextField label="テンプレート名" value={tplName}
                       onChange={e=>setTplName(e.target.value)} fullWidth />
          </Grid>
          <Grid item xs={12} md={7}
                container alignItems="center" spacing={1}>
            <Grid item>
              <Button onClick={()=>{
                const n=prompt("新しいテンプレート名"); if(n) setTplName(n);
              }}>＋ 新規</Button>
            </Grid>
            <Grid item>
              <Button color="error" onClick={deleteTemplate}>🗑️ 削除</Button>
            </Grid>
            <Grid item>
              <Button variant="contained" onClick={saveTemplate}>保存</Button>
            </Grid>
          </Grid>
        </Grid>

        {/* サンプル / ファイル */}
        <Box mt={3}>
          <FormControl fullWidth>
            <InputLabel>デモサンプル</InputLabel>
            <Select value={sampleKey} label="デモサンプル"
                    onChange={e=>handleSample(e.target.value)}>
              <MenuItem value="">（ファイルを使う）</MenuItem>
              {Object.keys(SAMPLE_CSV).map(k=>(
                <MenuItem key={k} value={k}>{k}</MenuItem>
              ))}
            </Select>
          </FormControl>
          <Box mt={2}>
            <input type="file" accept=".csv" onChange={handleFile}/>
          </Box>
        </Box>

        {/* プレビュー & マッピング */}
        {headers.length > 0 && (
          <Box mt={3}>
            {/* ヘッダー & サンプル */}
            <Typography variant="subtitle1">ヘッダー & サンプル</Typography>
            <TableContainer component={Paper} sx={{overflowX:"auto",mb:2}}>
              <Table size="small">
                <TableHead><TableRow>{headers.map(h=>
                  <TableCell key={h}>{h}</TableCell>
                )}</TableRow></TableHead>
                <TableBody><TableRow>{headers.map(h=>
                  <TableCell key={h}>{sample[h]}</TableCell>
                )}</TableRow></TableBody>
              </Table>
            </TableContainer>

            {/* 変換データ */}
            <Typography variant="subtitle1">変換データ</Typography>
            <TableContainer component={Paper} sx={{overflowX:"auto",mb:2}}>
              <Table size="small">
                <TableHead><TableRow>{BASE_FIELDS.map(f=>
                  <TableCell key={f}>{f}</TableCell>
                )}</TableRow></TableHead>
                <TableBody><TableRow>{BASE_FIELDS.map(f=>{
                  const src = mapping[f];
                  return <TableCell key={f}>{src?sample[src]:""}</TableCell>;
                })}</TableRow></TableBody>
              </Table>
            </TableContainer>

            {/* DnD マッピング */}
            <Typography variant="subtitle1">ドラッグ & ドロップでマッピング</Typography>
            <DragDropContext onDragEnd={onDragEnd}>
              <Grid container spacing={2}>
                {/* 未割当 */}
                <Grid item xs={12} md={4}>
                  <Typography>未割当ヘッダー</Typography>
                  <Droppable droppableId="unassigned">
                    {prov=>(
                      <Box ref={prov.innerRef}{...prov.droppableProps} className="droppableBox">
                        {unassigned.map((h,i)=>(
                          <Draggable key={h} draggableId={h} index={i}>
                            {(p,snap)=>(
                              <Box ref={p.innerRef}
                                   {...p.draggableProps}{...p.dragHandleProps}
                                   className="draggableItem"
                                   sx={snap.isDragging?{zIndex:9999,boxShadow:3}:{}}
                                   style={p.draggableProps.style}>
                                {h}
                              </Box>
                            )}
                          </Draggable>
                        ))}
                        {prov.placeholder}
                      </Box>
                    )}
                  </Droppable>
                </Grid>
                {/* 割当先 */}
                <Grid item xs={12} md={8}>
                  <Grid container spacing={1}>
                    {BASE_FIELDS.map(fld=>(
                      <Grid item xs={6} key={fld}>
                        <Typography variant="body2">{fld}</Typography>
                        <Droppable droppableId={fld}>
                          {prov=>(
                            <Box ref={prov.innerRef}{...prov.droppableProps} className="droppableBox">
                              {mapping[fld] && (
                                <Draggable draggableId={mapping[fld]} index={0}>
                                  {(p,snap)=>(
                                    <Box ref={p.innerRef}
                                         {...p.draggableProps}{...p.dragHandleProps}
                                         className="draggableItem"
                                         sx={snap.isDragging?{zIndex:9999,boxShadow:3}:{}}
                                         style={p.draggableProps.style}>
                                      {mapping[fld]}
                                    </Box>
                                  )}
                                </Draggable>
                              )}
                              {prov.placeholder}
                            </Box>
                          )}
                        </Droppable>
                        <Typography variant="caption">
                          サンプル: {mapping[fld] ? sample[mapping[fld]] : "—"}
                        </Typography>
                      </Grid>
                    ))}
                  </Grid>
                </Grid>
              </Grid>
            </DragDropContext>
          </Box>
        )}
      </DialogContent>
      <DialogActions><Button onClick={onClose}>閉じる</Button></DialogActions>
    </Dialog>
  );
}

/* ----------- インポートモーダル ----------- */
function ImportDialog({ open, onClose, onAdd }) {
  const full = useMediaQuery(useTheme().breakpoints.down('sm'));
  const templates = JSON.parse(localStorage.getItem(STORAGE_KEY));

  const [tplName, setTplName] = React.useState("");
  const [sampleKey, setSampleKey] = React.useState("");
  const [file, setFile] = React.useState(null);
  const [preview, setPreview] = React.useState(null);

  const loadRows = txt => {
    const arr = csvTo2D(txt);
    const hdr = arr[0]||[], idx={}; hdr.forEach((h,i)=>idx[h]=i);
    const tpl = templates.find(t=>t.name===tplName); if(!tpl) return [];
    return arr.slice(1).map(r=>{
      const o={}; BASE_FIELDS.forEach(f=>{
        const src = tpl.mapping[f];
        o[f] = src && idx[src]!=null ? r[idx[src]] : "";
      }); return o;
    });
  };

  const handlePreview = () => {
    if(!tplName) return alert("マッピングタイプを選択してください");
    if(sampleKey) { setPreview(loadRows(SAMPLE_CSV[sampleKey])); return; }
    if(!file) return alert("CSV ファイルを選択してください");
    const reader=new FileReader();
    reader.onload = ev => setPreview(loadRows(ev.target.result));
    reader.readAsText(file,"utf-8");
  };

  const reset = () => { setPreview(null); setFile(null); setSampleKey(""); };

  return (
    <Dialog fullScreen={full} fullWidth maxWidth="md" open={open} onClose={onClose}>
      <DialogTitle>インポート</DialogTitle>
      <DialogContent dividers>
        <FormControl fullWidth sx={{ mb:2 }}>
          <InputLabel>マッピングタイプ</InputLabel>
          <Select value={tplName} label="マッピングタイプ"
                  onChange={e=>setTplName(e.target.value)}>
            {templates.map(t=>(
              <MenuItem key={t.name} value={t.name}>{t.name}</MenuItem>
            ))}
          </Select>
        </FormControl>

        <FormControl fullWidth sx={{ mb:2 }}>
          <InputLabel>デモサンプル</InputLabel>
          <Select value={sampleKey} label="デモサンプル"
                  onChange={e=>{
                    setSampleKey(e.target.value); setFile(null);
                    setPreview(e.target.value ? loadRows(SAMPLE_CSV[e.target.value]) : null);
                  }}>
            <MenuItem value="">（ファイルを使う）</MenuItem>
            {Object.keys(SAMPLE_CSV).map(k=>(
              <MenuItem key={k} value={k}>{k}</MenuItem>
            ))}
          </Select>
        </FormControl>

        <Box mb={2}>
          <input type="file" accept=".csv" onChange={e=>{
            const f=e.target.files[0]; if(!f) return;
            setFile(f); setSampleKey(""); setPreview(null);
          }}/>
        </Box>

        <Button variant="contained" onClick={handlePreview}>プレビュー</Button>

        <Box mt={3}>
          <Typography variant="subtitle1" gutterBottom>取込みプレビュー</Typography>
          {preview ? (
            <TableContainer component={Paper} sx={{ maxHeight:300, overflow:"auto" }}>
              <Table size="small" stickyHeader>
                <TableHead>
                  <TableRow>{BASE_FIELDS.map(f=> <TableCell key={f}>{f}</TableCell>)}</TableRow>
                </TableHead>
                <TableBody>
                  {preview.map((r,i)=>(
                    <TableRow key={i}>
                      {BASE_FIELDS.map(f=> <TableCell key={f}>{r[f]}</TableCell>)}
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </TableContainer>
          ) : (
            <Typography color="textSecondary">プレビュー結果がここに表示されます</Typography>
          )}
        </Box>
      </DialogContent>
      <DialogActions>
        {preview && <Button onClick={reset}>取消</Button>}
        {preview && <Button variant="contained" onClick={()=>{ onAdd(preview); reset(); }}>本取込み</Button>}
        <Button onClick={onClose}>閉じる</Button>
      </DialogActions>
    </Dialog>
  );
}

/* ----------- エクスポートモーダル ----------- */
function ExportDialog({ open, onClose, rows }) {
  const full = useMediaQuery(useTheme().breakpoints.down('sm'));

  const onDownload = () => {
    const ws  = XLSX.utils.json_to_sheet(rows, { header: BASE_FIELDS });
    const blob= new Blob([XLSX.utils.sheet_to_csv(ws)], { type:"text/csv" });
    const url = URL.createObjectURL(blob);
    const a   = document.createElement("a");
    a.href = url; a.download = "base_table.csv"; a.click();
    URL.revokeObjectURL(url);
    onClose();
  };

  return (
    <Dialog fullScreen={full} open={open} onClose={onClose}>
      <DialogTitle>エクスポート</DialogTitle>
      <DialogContent dividers>
        <Typography>
          現在の基本テーブルには <strong>{rows.length}</strong> 行あります。
        </Typography>
        <Typography>CSV ファイルとしてダウンロードしますか？</Typography>
      </DialogContent>
      <DialogActions>
        <Button onClick={onClose}>キャンセル</Button>
        <Button variant="contained" onClick={onDownload}>ダウンロード</Button>
      </DialogActions>
    </Dialog>
  );
}

ReactDOM.createRoot(document.getElementById("root")).render(<App/>);
</script>
</body>
</html>