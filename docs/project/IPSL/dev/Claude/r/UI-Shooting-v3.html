<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Cyber Scroll Shooter – Final Edition</title>
    <style>
        * { box-sizing: border-box; }
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', monospace;
            color: #00ffff;
            height: 100vh;
        }
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            /* Added for a subtle background animation */
            background: radial-gradient(circle at 50% 50%, rgba(0,255,255,0.05) 0%, rgba(0,0,0,0) 70%),
            repeating-linear-gradient(0deg, #0a0a2e, #0a0a2e 1px, #16213e 1px, #16213e 2px);
            animation: backgroundPulse 15s infinite alternate;
        }
        @keyframes backgroundPulse {
            0% { background-position: 0% 0%; }
            100% { background-position: 100% 100%; }
        }
        canvas {
            display: block;
            background: linear-gradient(135deg, #0a0a2e 0%, #16213e 50%, #0f3460 100%);
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(0,255,255,0.3);
            max-width: 100vw;
            max-height: 100vh;
        }
        .panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0,20,40,0.95) 0%, rgba(10,30,60,0.95) 100%);
            border: 2px solid #00ffff;
            padding: clamp(20px, 5vw, 40px);
            border-radius: 20px;
            box-shadow: 0 0 40px rgba(0,255,255,0.4), inset 0 0 20px rgba(0,255,255,0.1);
            text-align: center;
            z-index: 10;
            backdrop-filter: blur(10px);
            min-width: 280px;
            /* Removed animation for panels as per user request */
        }
        
        /* Keyframes for panelFadeIn are no longer used for .panel, but kept if other elements might use it */
        @keyframes panelFadeIn {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }
        
        .panel h1 {
            margin: 0 0 20px;
            font-size: clamp(20px, 6vw, 32px);
            text-shadow: 0 0 15px #00ffff;
            background: linear-gradient(45deg, #00ffff, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .panel button {
            background: linear-gradient(45deg, #001122, #003366);
            border: 2px solid #00ffff;
            color: #00ffff;
            padding: 12px 30px;
            font-size: clamp(16px, 4vw, 22px);
            cursor: pointer;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0,255,255,0.3);
            transition: all 0.3s ease;
            font-family: inherit;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .panel button:hover, .panel button:active {
            background: linear-gradient(45deg, #003366, #0066cc);
            box-shadow: 0 0 25px rgba(0,255,255,0.6);
            transform: scale(1.05);
        }
        
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: clamp(12px, 3vw, 16px);
            z-index: 5;
            text-shadow: 0 0 8px #00ffff;
            line-height: 1.4;
            background: rgba(0,20,40,0.7);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid rgba(0,255,255,0.3);
        }
        
        #score {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: clamp(16px, 4vw, 24px);
            z-index: 5;
            text-shadow: 0 0 8px #00ffff;
            background: rgba(0,20,40,0.7);
            padding: 8px 15px;
            border-radius: 8px;
            border: 1px solid rgba(0,255,255,0.3);
        }
        
        #hpbar {
            position: absolute;
            top: 60px;
            left: 10px;
            width: min(200px, 40vw);
            height: 12px;
            border: 2px solid #00ffff;
            border-radius: 6px;
            z-index: 6;
            background: rgba(0,0,0,0.5);
            overflow: hidden;
        }
        
        #hpfill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ffff00, #00ff00);
            transition: width 0.3s ease;
        }
        
        #touchControls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 200px;
            z-index: 8;
            display: none;
            pointer-events: none;
        }
        
        .control-area {
            position: absolute;
            pointer-events: all;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            border-radius: 50%;
            user-select: none;
        }
        
        #moveStick {
            bottom: 25px;
            left: 25px;
            width: 120px;
            height: 120px;
            background: radial-gradient(circle, rgba(0,255,255,0.2), rgba(0,255,255,0.05));
            border: 2px solid rgba(0,255,255,0.4);
        }
        
        #fireButton {
            bottom: 35px;
            right: 25px;
            width: 90px;
            height: 90px;
            background: radial-gradient(circle, rgba(255,100,100,0.3), rgba(255,100,100,0.1));
            border: 2px solid rgba(255,100,100,0.5);
            color: #ff6666;
            font-size: 36px;
        }
        
        #weaponButton {
            bottom: 135px;
            right: 25px;
            width: 60px;
            height: 60px;
            background: radial-gradient(circle, rgba(255,255,0,0.3), rgba(255,255,0,0.1));
            border: 2px solid rgba(255,255,0,0.5);
            color: #ffff66;
            font-size: 24px;
        }
        
        #bombButton {
            bottom: 85px;
            right: 125px;
            width: 70px;
            height: 70px;
            background: radial-gradient(circle, rgba(255,0,255,0.3), rgba(255,0,255,0.1));
            border: 2px solid rgba(255,0,255,0.5);
            color: #ff66ff;
            font-size: 30px;
        }
        
        #warpButton {
            bottom: 15px;
            right: 125px;
            width: 70px;
            height: 70px;
            background: radial-gradient(circle, rgba(100,100,255,0.3), rgba(100,100,255,0.1));
            border: 2px solid rgba(100,100,255,0.5);
            color: #8888ff;
            font-size: 30px;
        }
        
        @media (max-width: 768px), (pointer: coarse) {
            #touchControls { display: block; }
        }
        
        #hud {
            background: linear-gradient(135deg, rgba(0,20,40,0.8), rgba(0,40,80,0.8));
            border: 1px solid #00ffff;
            box-shadow: 0 0 10px #00ffff33;
            padding: 15px;
            border-radius: 5px;
            backdrop-filter: blur(5px);
        }
        
        .status-bar {
            height: 4px;
            background: #003366;
            border-radius: 2px;
            margin: 5px 0;
            position: relative;
        }
        
        .status-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ffff, #80ffff);
            border-radius: 2px;
            transition: width 0.3s ease;
        }
        
        .status-icon {
            width: 20px;
            height: 20px;
            margin-right: 5px;
            vertical-align: middle;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="menu" class="panel">
            <h1>⚡ CYBER SCROLL SHOOTER ⚡</h1>
            <p style="font-size: 14px; margin: -10px 0 20px;">Final Edition</p>
            <button id="newGameBtn">NEW GAME</button><br><br>
            <button id="continueBtn">CONTINUE</button>
        </div>
          
        <div id="result" class="panel" style="display:none">
            <h1 id="resText"></h1>
            <button id="retryBtn">↻ RETRY MISSION</button>
        </div>
          
        <div id="hud"></div>
        <div id="score">Score: 0</div>
        <div id="hpbar"><div id="hpfill"></div></div>
          
        <canvas id="game"></canvas>
          
        <div id="touchControls">
            <div id="moveStick" class="control-area"></div>
            <div id="fireButton" class="control-area">🔥</div>
            <div id="weaponButton" class="control-area">♻</div>
            <div id="bombButton" class="control-area">💣</div>
            <div id="warpButton" class="control-area">🌀</div>
        </div>
    </div>
    
    <script>
'use strict';
        /* ──────────────────────────────────────
         📌 基本定義・定数
        ────────────────────────────────────── */
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        
        let W, H;
        /**
        * Resizes the canvas to fit the window while maintaining aspect ratio.
        * Ensures responsiveness across different screen sizes.
        */
        function resizeCanvas() {
            const container = document.getElementById('gameContainer');
            const aspectRatio = 16 / 10; // Desired aspect ratio for the game
            const maxWidth = Math.min(window.innerWidth, 1200); // Max width for desktop
            const maxHeight = Math.min(window.innerHeight, 800); // Max height for desktop
              
            let canvasWidth = maxWidth;
            let canvasHeight = maxWidth / aspectRatio;
              
            if (canvasHeight > maxHeight) {
                canvasHeight = maxHeight;
                canvasWidth = canvasHeight * aspectRatio;
            }
              
            canvas.width = W = canvasWidth;
            canvas.height = H = canvasHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas(); // Initial call to set canvas size
        
        const SEG_W = 40; // Width of each terrain segment
        const SEG_RANGE = 3000; // Range for terrain generation (how far ahead/behind to generate)
        const ENEMY_INT = 1200; // Interval for enemy spawning in milliseconds
        const AIR_RESISTANCE = 0.98; // Player's movement dampening factor
        
        let scrollX = 0; // Current scroll position of the game world
        let keys = {}; // Object to track pressed keyboard keys
        let score = 0; // Player's current score
        let playing = false; // Game state: true if game is in progress
        let gameOver = false; // Game state: true if game is over
        let enemyTimer = null; // Timer for spawning enemies
        let high = Number(localStorage.getItem('cshooter-hi')) || 0; // High score loaded from local storage
        
        /* DOM elements */
        const hud = document.getElementById('hud'); // HUD display area
        const scoreEl = document.getElementById('score'); // Score display element
        const hpbar = document.getElementById('hpfill'); // Player HP bar fill element
        
        /* Utility functions */
        /**
        * Generates a random number between a and b (inclusive).
        * @param {number} a - The lower bound.
        * @param {number} b - The upper bound.
        * @returns {number} A random number.
        */
        const R = (a, b) => a + Math.random() * (b - a);
        
        const NEON = ['#00ffea', '#ff36ff', '#ff3366', '#ffe600', '#00ff7a']; // Array of neon colors
        /**
        * Returns a random neon color from the NEON array.
        * @returns {string} A hex color string.
        */
        const rNeon = () => NEON[Math.floor(Math.random() * NEON.length)];
        
        // シールド回復定数
        const SHIELD_REGEN_DELAY = 300; // 5秒間回復しない
        const SHIELD_REGEN_RATE = 0.15 / 60; // 3秒で20%回復（1秒で約6.66%）
        
        /* ──────────────────────────────────────
         📌 プレイヤー
        ────────────────────────────────────── */
        // 【変更】プレイヤーオブジェクトにシールド・翼HP・コアHPを追加（コアは固定で破壊されない）
        const player = {
            x: 0, y: H/2, vx: 0, vy: 0, dir: 1,
            w: 60, h: 35, maxSpeed: 6,
            // これまでのhpは今後wingHpとして扱う（ウィングとエンジンに相当）
            wingHp: 50, maxWingHp: 50,
            coreHp: 50, // コアHP（破壊されない）
            
            weapon: 'laser', bombs: 3, thrustPower: 0.5,
            isWarping: 0, lastWarpTime: 0, warpCooldown: 2000,
            isCharging: false, chargeLevel: 0, maxCharge: 100,
            robotW: 80, robotH: 50, humanW: 60, humanH: 35,
            isRobot: false, transformCooldown: 3000, lastTransformTime: 0,
            robotDamageMultiplier: 1.5,
            comboCount: 0, comboTimer: 0, maxComboTime: 180,
            bits: [],
            maxBits: 4,
            // ここから新規追加　シールドの値（自機はまずシールドがダメージを吸収）
            shield: 50, maxShield: 50,
            lastShieldDamage: 0 // 最後にシールドダメージを受けた時間
        };
        
        /* ビットドローンの定義 */
        class BitDrone {
            constructor(angle) {
                this.angle = angle;
                this.radius = 50; // 自機からの距離
                this.rotationSpeed = 0.02;
                this.hp = 1; // HPを1に減少
                this.invulnerable = 0; // 無敵時間
            }
            
            update(playerX, playerY) {
                this.angle += this.rotationSpeed;
                this.x = playerX + Math.cos(this.angle) * this.radius;
                this.y = playerY + Math.sin(this.angle) * this.radius;
            }
            
            draw(ctx, scrollX) {
                const screenX = this.x - scrollX;
                ctx.save();
                ctx.translate(screenX, this.y);
                ctx.fillStyle = '#00ffff';
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.arc(0, 0, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
            
            // 修正：player.dir （機首の向き）に合わせてbit_laserを発射する
            fire(dir) {
                bullets.push({
                    type: 'bit_laser',
                    x: this.x,
                    y: this.y,
                    w: 10,
                    h: 3,
                    vx: 36 * dir, // もともと12だったものを３倍に
                    vy: 0,
                    damage: 2,
                    color: '#00ffff'
                });
            }
        }
        
        // 【変更】ロボットモード用の描画関数を実装してエラーを回避
        function drawRobotParts() {
            // 簡易なロボットモードの描画例
            ctx.fillStyle = '#ff00ff';
            ctx.shadowColor = '#ff00ff';
            ctx.shadowBlur = 20;
            // ロボット胴体の描画
            ctx.fillRect(-player.robotW/2, -player.robotH/2, player.robotW, player.robotH);
            // ロボットの頭（丸型）
            ctx.beginPath();
            ctx.arc(0, -player.robotH/2, player.robotW/4, 0, Math.PI*2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }
        
        // 【変更】自機描画内にシールド表示とレーザー発射チャージエフェクトを追加
        function drawPlayer() {
            ctx.save();
            // 自機描画位置：画面中央（W/2）とplayer.y+player.h/2に配置
            ctx.translate(W/2, player.y + player.h/2);
            
            // シールドの描画
            if (player.shield > 0) {
                drawShield(0, 0, player.w * 0.8, player.shield / player.maxShield);
            }
            
            if (player.isWarping > 0) ctx.globalAlpha = player.isWarping / 15;
            ctx.scale(player.dir, 1);
            
            if (player.isRobot) {
                // ロボットモード：drawRobotParts()を使用
                drawRobotParts();
            } else {
                // 戦闘機モード：従来のパーツ描画
                drawFighterParts();
            }
            ctx.restore();
            
            // 【変更】ビットドローンの描画（機体周辺に配置）
            player.bits.forEach(bit => bit.draw(ctx, scrollX));
            
            // 【変更】レーザーのチャージエフェクトを機首付近に描画（自機描画位置を基準）
            if (player.isCharging) {
                const chargeRatio = player.chargeLevel / player.maxCharge;
                ctx.save();
                // 機首先端位置：画面中央から自機幅/2の位置（player.dirで左右）
                ctx.translate(W/2 + (player.w/2) * player.dir, player.y + player.h/2);
                ctx.fillStyle = `rgba(255,255,0,${0.5 + 0.5 * chargeRatio})`;
                ctx.beginPath();
                ctx.arc(0, 0, 10 + 20 * chargeRatio, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }
        
        // シールド描画関数を追加
        function drawShield(x, y, radius, ratio) {
            ctx.save();
            ctx.translate(x, y);
            
            // シールドの色は残量に応じて変化
            const shieldColor = ratio > 0.6 ? '#00ffff' : 
            ratio > 0.3 ? '#ffff00' : '#ff3300';
            
            // シールドを円形に描画
            ctx.beginPath();
            ctx.arc(0, 0, radius, 0, Math.PI * 2);
            
            // グラデーション効果
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, radius);
            gradient.addColorStop(0, `${shieldColor}22`);
            gradient.addColorStop(0.7, `${shieldColor}11`);
            gradient.addColorStop(1, `${shieldColor}00`);
            
            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.strokeStyle = shieldColor;
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // エネルギー波動効果
            if (ratio > 0) {
                ctx.globalAlpha = 0.3 * ratio;
                ctx.beginPath();
                ctx.arc(0, 0, radius + Math.sin(Date.now() * 0.003) * 5, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            ctx.restore();
        }
        
        // 【変更】戦闘機パーツの描画（エンジン表示は変更なし）
        function drawFighterParts() {
            const threshold = {
                wings: 25,
                engines: 10
            };
            
            // コア（常に表示）
            ctx.fillStyle = '#00aaff';
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.moveTo(player.w * 0.5, 0);
            ctx.lineTo(-player.w * 0.3, -player.h * 0.3);
            ctx.lineTo(-player.w * 0.4, 0);
            ctx.lineTo(-player.w * 0.3, player.h * 0.3);
            ctx.closePath();
            ctx.fill();
            
            // 左ウィング
            ctx.save();
            ctx.fillStyle = '#0088cc';
            ctx.rotate(-Math.PI/8);
            ctx.fillRect(-player.w * 0.7, -player.h * 0.15, player.w * 0.4, player.h * 0.08);
            ctx.restore();
            
            // 右ウィング
            ctx.save();
            ctx.fillStyle = '#0088cc';
            ctx.rotate(Math.PI/8);
            ctx.fillRect(-player.w * 0.7, player.h * 0.07, player.w * 0.4, player.h * 0.08);
            ctx.restore();
            
            // ウィング（旧式、残してもOK）
            if (player.wingHp > threshold.wings) {
                ctx.fillStyle = '#0088cc';
                ctx.beginPath();
                ctx.moveTo(-player.w * 0.3, -player.h * 0.4);
                ctx.lineTo(-player.w * 0.5, 0);
                ctx.lineTo(-player.w * 0.3, player.h * 0.4);
                ctx.closePath();
                ctx.fill();
            }
            
            // エンジン（wingHp > 10）
            if (player.wingHp > threshold.engines) {
                ctx.fillStyle = '#006699';
                ctx.fillRect(-player.w * 0.5, -player.h * 0.15, player.w * 0.2, player.h * 0.3);
                
                // エンジン発光エフェクト
                const engineGlow = ctx.createLinearGradient(
                -player.w * 0.7, 0,
                -player.w * 0.5, 0
                );
                engineGlow.addColorStop(0, '#00ffff00');
                engineGlow.addColorStop(1, '#00ffff44');
                ctx.fillStyle = engineGlow;
                ctx.fillRect(-player.w * 0.7, -player.h * 0.1, player.w * 0.2, player.h * 0.2);
            }
        }
        
        /* ──────────────────────────────────────
         📌 ワールド生成
        ────────────────────────────────────── */
        const stars = []; // Background stars for parallax
        const terrain = {}; // Stores terrain height for each segment
        const foregroundObjects = []; // Objects that are in the foreground (obstacles, decorations, buildings, etc.)
        const midgroundObjects = []; // Objects that are in the mid-ground, for more depth
        
        /**
        * Generates the game world: stars, terrain, and foreground/midground objects.
        */
        function makeWorld() {
            // Clear existing entities
            [stars, terrain, foregroundObjects, midgroundObjects].forEach(arr => arr.length = 0);
            
            // Generate background stars across 4 layers for parallax
            for (let l = 0; l < 4; l++) {
                for (let i = 0; i < 80; i++) {
                    stars.push({
                        x: R(0, W), y: R(0, H),
                        size: (l + 1) * 0.8, // Larger stars for closer layers
                        layer: l + 1, // Layer for parallax calculation
                        twinkle: R(0, Math.PI * 2) // Starting phase for twinkle effect
                    });
                }
            }
              
            // Generate terrain and place foreground/midground objects
            for (let i = -SEG_RANGE; i <= SEG_RANGE; i++) {
                // Combine multiple sine waves for more complex terrain
                terrain[i] = H * (0.8 + 0.1 * Math.sin(i * 0.01) + 0.05 * Math.sin(i * 0.005) + 0.02 * Math.cos(i * 0.02));
                  
                if (Math.random() < 0.05) { // 5% chance for a foreground obstacle
                    const isObstacle = Math.random() < 0.6; // 60% chance for collision-enabled obstacle
                    foregroundObjects.push({
                        type: isObstacle ? 'obstacle' : 'decoration',
                        x: i * SEG_W, y: R(H * 0.5, H),
                        w: R(40, 100), h: R(80, H * 0.6),
                        color: isObstacle ? '#ff4444' : '#102040',
                        rotation: isObstacle ? R(-0.1, 0.1) : 0 // Slight rotation for obstacles
                    });
                }
                
                if (Math.random() < 0.03) { // 3% chance for a midground object
                    midgroundObjects.push({
                        x: i * SEG_W, y: R(H * 0.3, H * 0.7),
                        w: R(100, 250), h: R(50, 150),
                        color: `rgba(15, 40, 80, ${R(0.5, 0.8)})`,
                        rotation: R(-0.05, 0.05)
                    });
                }
                
                // New static environment objects for enriched terrain
                if (Math.random() < 0.03) { // Buildings
                    foregroundObjects.push({
                        type: 'building',
                        x: i * SEG_W,
                        y: H - R(50, 200), // Grounded
                        w: R(50, 150),
                        h: R(50, 200),
                        color: `rgba(0, 50, 100, ${R(0.6, 0.9)})`,
                        outline: '#00ccff',
                        windowColor: '#00ffff'
                    });
                }
                if (Math.random() < 0.01) { // Mountains
                    foregroundObjects.push({
                        type: 'mountain',
                        x: i * SEG_W,
                        y: H - R(80, 300), // Grounded
                        w: R(150, 400),
                        h: R(100, 350),
                        color: `rgba(20, 30, 50, ${R(0.7, 0.9)})`,
                        outline: '#0055aa'
                    });
                }
                if (Math.random() < 0.005) { // Animals/People (very abstract cyber style)
                    const objectType = Math.random() < 0.5 ? 'animal' : 'person';
                    foregroundObjects.push({
                        type: objectType,
                        x: i * SEG_W,
                        y: H - R(20, 60), // Grounded
                        w: R(15, 30),
                        h: R(30, 60),
                        color: `rgba(255, 0, 255, ${R(0.7, 0.9)})`, // Pink/purple glow for organic life
                        outline: '#ff00ff'
                    });
                }
                if (Math.random() < 0.005) { // 0.5%の確率で空港オブジェクトを生成
                    foregroundObjects.push({
                        type: 'airport',
                        x: i * SEG_W,
                        y: getY(i) - 50, // 地面上に配置（高さ50）
                        w: 100,
                        h: 50,
                        color: '#666666',
                        outline: '#00ffff'
                    });
                }
            }
        }
         
        /**
        * Gets the terrain height at a given segment index.
        * @param {number} i - The segment index.
        * @returns {number} The Y-coordinate of the terrain.
        */
        const getY = i => terrain[i] || (H * 0.85);
        
        /* ──────────────────────────────────────
         📌 エンティティ & VFX
        ────────────────────────────────────── */
        const enemies = []; // Array of active enemies
        const bullets = []; // Array of active bullets (player and enemy)
        const particles = []; // Array of active particles for visual effects
        const bombEffects = []; // Array for bomb visual effects
        const items = []; // Array of dropped items
        const transformEffects = []; // Array for transformation visual effects
        
        /**
        * Spawns a new enemy at a random position.
        */
        function spawnEnemy() {
            const y = R(H * 0.1, H * 0.7);
            const types = ['bomber', 'fighter', 'heli'];
            const type = types[Math.floor(Math.random() * types.length)];
            let enemy = { 
                y, type, color: rNeon(),
                vx: (Math.random() < 0.5 ? -1 : 1) * R(0.8, 2.2),
                vy: R(-0.5, 0.5), lastShot: 0,
                spawnState: 'warping', spawnTimer: 60
            };
            // ランダムに右側または左側から出現
            if (Math.random() < 0.5) {
                enemy.x = scrollX + W + 100;
            } else {
                enemy.x = scrollX - 100;
                enemy.vx = -enemy.vx; // 左側出現なら速度を反転
            }
            if (type === 'bomber') {
                enemy.w = 60; enemy.h = 40;
                enemy.hp = enemy.maxHp = 5;
                enemy.vx *= 0.7;
            } else if (type === 'fighter') {
                enemy.w = 50; enemy.h = 30;
                enemy.hp = enemy.maxHp = 3;
                enemy.vx *= 1.5;
            } else {
                enemy.w = 40; enemy.h = 25;
                enemy.hp = enemy.maxHp = 2;
                enemy.vx *= 1.2;
            }
            enemies.push(enemy);
        }
        
        /**
        * Creates a burst of particles at a given location.
        * @param {number} x - X coordinate.
        * @param {number} y - Y coordinate.
        * @param {number} count - Number of particles to create.
        * @param {object} options - Particle properties (minSpeed, maxSpeed, color, gravity, type).
        */
        function createParticles(x, y, count, options) {
            for (let i = 0; i < count; i++) {
                const angle = R(0, Math.PI * 2); // Random direction
                const speed = R(options.minSpeed, options.maxSpeed); // Random speed
                particles.push({
                    x, y,
                    vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, // Velocity components
                    life: R(options.minLife || 20, options.maxLife || 40), // Particle lifespan
                    maxLife: options.maxLife || 40, // Max lifespan for opacity calculation
                    color: options.color, size: R(options.minSize || 1, options.maxSize || 4), // Visuals
                    gravity: options.gravity || 0, // Gravity effect
                    type: options.type || 'normal' // Particle type for different rendering
                });
            }
        }
        
        /**
        * Spawns an item at a given location.
        * @param {number} x - X coordinate.
        * @param {number} y - Y coordinate.
        */
        function spawnItem(x, y) {
            const types = ['hp_pack', 'bomb_refill', 'bit_drone'];
            const type = types[Math.floor(Math.random() * types.length)];
            items.push({
                x, y,
                vx: R(-1, 1),
                vy: R(-1, 1),
                life: 300,
                maxLife: 300,
                type,
                w: 20,
                h: 20,
                color: type === 'hp_pack' ? '#00ff00' : 
                type === 'bomb_refill' ? '#ff00ff' : '#00ffff'
            });
        }
        
        /* ──────────────────────────────────────
         📌 入力処理
        ────────────────────────────────────── */
        /**
        * Sets up event listeners for keyboard and touch controls.
        */
        function setupInput() {
            // Keyboard input handling
            window.addEventListener('keydown', e => {
                keys[e.key.toLowerCase()] = true; // Mark key as pressed
                if (playing && !gameOver) {
                    if (e.key === 'q') switchWeapon(); // Switch weapon
                    if (e.key === 'x') warpPlayer(); // Activate warp
                    if (e.key === 'c') transformPlayer(); // Transform player
                    if (e.key === ' ') {
                        e.preventDefault(); // Prevent scrolling
                        // Start charging laser or fire other weapons
                        if (player.weapon === 'laser' && !player.isCharging) player.isCharging = true;
                        else if (player.weapon !== 'laser') fire();
                    }
                }
            });
            
            window.addEventListener('keyup', e => {
                keys[e.key.toLowerCase()] = false; // Mark key as released
                // If laser was charging, fire it when space is released
                if (e.key === ' ' && player.isCharging) {
                    fire();
                    player.isCharging = false;
                }
            });
            
            // Touch controls for mobile
            const fireBtn = document.getElementById('fireButton');
            fireBtn.addEventListener('touchstart', e => {
                e.preventDefault();
                if (playing && !gameOver) {
                    if (player.weapon === 'laser') player.isCharging = true; else fire();
                }
            }, { passive: false }); // passive: false to allow preventDefault
            fireBtn.addEventListener('touchend', e => {
                e.preventDefault();
                if (playing && !gameOver && player.isCharging) {
                    fire();
                    player.isCharging = false;
                }
            });
            
            document.getElementById('weaponButton').addEventListener('touchstart', e => { e.preventDefault(); if(playing && !gameOver) switchWeapon(); });
            document.getElementById('bombButton').addEventListener('touchstart', e => { e.preventDefault(); if(playing && !gameOver && player.weapon === 'bomb') fire(); });
            document.getElementById('warpButton').addEventListener('touchstart', e => { e.preventDefault(); if(playing && !gameOver) warpPlayer(); });
            // New touch control for transformation
            // No specific UI button for 'c' key in current layout, but if one was added, attach listener here.
            // For now, it will be keyboard-only or implied on a combined touch button if needed.
            
            // Touch move stick (simplified for movement)
            const moveStick = document.getElementById('moveStick');
            let touchStartX = 0;
            let touchStartY = 0;
            let activeTouchId = null;
            
            moveStick.addEventListener('touchstart', e => {
                e.preventDefault();
                if (e.touches.length === 1) {
                    activeTouchId = e.touches[0].identifier;
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                    // Simulate key press for continuous movement
                    keys['w'] = keys['arrowup'] = false;
                    keys['s'] = keys['arrowdown'] = false;
                    keys['a'] = keys['arrowleft'] = false;
                    keys['d'] = keys['arrowright'] = false;
                }
            }, { passive: false });
            
            moveStick.addEventListener('touchmove', e => {
                e.preventDefault();
                if (activeTouchId !== null) {
                    const touch = Array.from(e.touches).find(t => t.identifier === activeTouchId);
                    if (touch) {
                        const dx = touch.clientX - touchStartX;
                        const dy = touch.clientY - touchStartY;
                        
                        // Reset keys
                        keys['w'] = keys['arrowup'] = false;
                        keys['s'] = keys['arrowdown'] = false;
                        keys['a'] = keys['arrowleft'] = false;
                        keys['d'] = keys['arrowright'] = false;
                        
                        const threshold = 20; // Sensitivity for movement
                        if (dx > threshold) keys['d'] = keys['arrowright'] = true;
                        else if (dx < -threshold) keys['a'] = keys['arrowleft'] = true;
                        
                        if (dy > threshold) keys['s'] = keys['arrowdown'] = true;
                        else if (dy < -threshold) keys['w'] = keys['arrowup'] = true;
                    }
                }
            }, { passive: false });
            
            moveStick.addEventListener('touchend', e => {
                e.preventDefault();
                activeTouchId = null;
                // Stop all movement when touch ends
                keys['w'] = keys['arrowup'] = false;
                keys['s'] = keys['arrowdown'] = false;
                keys['a'] = keys['arrowleft'] = false;
                keys['d'] = keys['arrowright'] = false;
            });
        }
        
        /**
        * Cycles through player's weapons.
        */
        function switchWeapon() {
            const weapons = ['laser', 'missile', 'bomb'];
            player.weapon = weapons[(weapons.indexOf(player.weapon) + 1) % weapons.length];
        }
        
        /**
        * Activates player warp, moving them forward instantly.
        */
        function warpPlayer() {
            if (Date.now() - player.lastWarpTime > player.warpCooldown) {
                player.lastWarpTime = Date.now();
                // Create a burst of particles at the player's old position before warping
                createParticles(player.x + W/2 - player.w/2, player.y + player.h/2, 50, { 
                    minSpeed: 3, maxSpeed: 8, color: '#00ffff', type: 'warp', minLife: 30, maxLife: 60
                });
                player.x += 300; // Instantly move player forward
                player.isWarping = 15; // Set warp animation frames
            }
        }
        
        /**
        * Transforms player between human and robot forms.
        */
        function transformPlayer() {
            if (Date.now() - player.lastTransformTime > player.transformCooldown) {
                player.lastTransformTime = Date.now();
                player.isRobot = !player.isRobot; // Toggle robot form
                
                // Change player dimensions and attributes based on form
                if (player.isRobot) {
                    player.w = player.robotW;
                    player.h = player.robotH;
                    player.maxSpeed = 4; // Robot is slower but stronger
                } else {
                    player.w = player.humanW;
                    player.h = player.humanH;
                    player.maxSpeed = 6; // Human form is faster
                }
                
                // Add transformation effect
                transformEffects.push({
                    x: player.x + W/4 - (player.isRobot ? player.robotW : player.humanW)/2, // Screen X position
                    y: player.y + (player.isRobot ? player.robotH : player.humanH)/2,
                    radius: 0,
                    maxRadius: 100,
                    life: 30,
                    maxLife: 30,
                    speed: 5,
                    color: player.isRobot ? '#ff00ff' : '#00ffff',
                    lineWidth: 10,
                    shadowBlur: 40
                });
                
                // Add particles for transformation
                createParticles(player.x + W/4, player.y + (player.isRobot ? player.robotH : player.humanH)/2, 50, { minSpeed: 2, maxSpeed: 10, color: player.isRobot ? '#ff00ff' : '#00ffff', type: 'transform_burst', minLife: 30, maxLife: 60 });
            }
        }
        
        /* ──────────────────────────────────────
         📌 発射システム
        ────────────────────────────────────── */
        /**
        * Fires a bullet based on the current weapon.
        */
        function fire() {
            const fireX = player.x + (player.dir === 1 ? player.w : 0); // Bullet origin X
            const fireY = player.y + player.h / 2; // Bullet origin Y
            // Adjust base damage based on player form
            const baseDamage = player.isRobot ? player.robotDamageMultiplier : 1;
              
            if (player.weapon === 'laser') {
                const chargeRatio = player.chargeLevel / player.maxCharge; // How charged the laser is
                bullets.push({
                    type: 'laser', x: fireX, y: fireY - (4 + 16 * chargeRatio) / 2,
                    vx: (15 * player.dir + 5 * chargeRatio) * 3,
                    vy: 0, // Faster and stronger with charge
                    w: 15 + 20 * chargeRatio, h: 4 + 16 * chargeRatio, // Larger with charge
                    color: '#ffff00', damage: 9999, piercing: (chargeRatio > 0.5)
                });
                player.chargeLevel = 0; // Reset charge
            } else if (player.weapon === 'missile') {
                bullets.push({
                    type: 'missile', x: fireX, y: fireY - 3, vx: 10 * player.dir, vy: 0,
                    w: 18, h: 6, color: '#ff8800', damage: (baseDamage * 3), speed: 8, fuel: 120, // Missile properties
                });
            } else if (player.weapon === 'bomb' && player.bombs > 0) {
                player.bombs--;
                bombEffects.push({
                    x: W/2,
                    y: player.y + player.h/2,
                    radius: 0,
                    maxRadius: Math.max(W, H) * 0.8,
                    life: 60,
                    maxLife: 60,
                    color: '#00ffff'
                });
                // 画面内の敵と敵弾を破壊
                enemies.forEach(e => {
                    const screenX = e.x - scrollX;
                    if (screenX >= 0 && screenX <= W) {
                        e.hp = 0;
                    }
                });
                bullets = bullets.filter(b => b.type !== 'enemy');
            }
        }
        
        /* ──────────────────────────────────────
         📌 更新処理
        ────────────────────────────────────── */
        /**
        * Main update function, calls all other update functions.
        */
        function update() {
            if (!playing || gameOver) return; // Only update if game is playing
            updatePlayer();
            updateEnemies();
            updateBullets();
            updateParticles();
            updateBombEffects(); // Update bomb effects
            updateItems(); // Update items
            updateTransformEffects(); // Update transform effects
            checkCollisions();
        }
        
        /**
        * Updates player's position, velocity, and state.
        */
        function updatePlayer() {
            // Handle player movement input
            let inputX = (keys['d'] || keys['arrowright'] ? 1 : 0) - (keys['a'] || keys['arrowleft'] ? 1 : 0);
            let inputY = (keys['s'] || keys['arrowdown'] ? 1 : 0) - (keys['w'] || keys['arrowup'] ? 1 : 0);
            if (inputX !== 0) player.dir = Math.sign(inputX); // Update player direction
            
            // Apply thrust and air resistance
            player.vx += inputX * player.thrustPower;
            player.vy += inputY * player.thrustPower;
            player.vx *= AIR_RESISTANCE;
            player.vy *= AIR_RESISTANCE;
              
            // Update player position
            player.x += player.vx;
            player.y += player.vy;
            
            // Collision with terrain
            const groundY = getY(Math.floor(player.x / SEG_W)) - player.h;
            if (player.y > groundY) { player.y = groundY; player.vy = 0; }
            // Keep player within vertical screen bounds
            player.y = Math.max(0, Math.min(H - player.h, player.y));
            
            // Update game scroll position
            scrollX = player.x - W / 2;
              
            // スラスターパーティクル（自機の後方、機首向きに連動）
            let thrusterX = W/2 - player.dir * player.w/2;
            let thrusterY = player.y + player.h/2;
            if (player.isWarping > 0) {
                player.isWarping--;
                // ワープエフェクトをスローで大きく
                createParticles( player.x + thrusterX, thrusterY, 6, { minSpeed: 0.5, maxSpeed: 2, color: '#00ffff', type: 'warp_trail', minLife: 40, maxLife: 80 });
            }
            // 常にエンジン（後方）からスラスターパーティクルを出す
            createParticles(player.x + thrusterX/2 , thrusterY, 2, { minSpeed: 0.5, maxSpeed: 1.5, color: '#ffcc00', type: 'thruster' });
            
            // Update laser charge level
            if (player.isCharging) player.chargeLevel = Math.min(player.maxCharge, player.chargeLevel + 1.5);
            
            if (player.comboTimer > 0) {
                player.comboTimer--;
                if (player.comboTimer <= 0) {
                    player.comboCount = 0;
                }
            }
            
            // 【変更】各ビットドローンを更新・攻撃（機首方向に連動）
            player.bits.forEach((bit) => {
                bit.update(player.x, player.y);
                if (keys[' ']) {
                    bit.fire(player.dir);
                }
            });
            
            // ビットドローンの生存チェック
            player.bits = player.bits.filter(bit => bit.hp > 0);
            
            // シールド回復処理
            if (player.shield < player.maxShield &&
            player.lastShieldDamage + SHIELD_REGEN_DELAY < Date.now()) {
                player.shield = Math.min(player.maxShield, player.shield + player.maxShield * SHIELD_REGEN_RATE);
            }
        }
        
        /**
        * Updates enemy positions and behavior.
        */
        function updateEnemies() {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];
                // Remove dead enemies and add score
                if (e.hp <= 0) {
                    enemies.splice(i, 1);
                    
                    // コンボカウントの更新
                    player.comboCount++;
                    player.comboTimer = player.maxComboTime;
                    
                    // コンボボーナスの計算（10%ずつ増加）
                    const comboBonus = Math.floor(100 * (1 + (player.comboCount - 1) * 0.1));
                    score += comboBonus;
                    
                    // エフェクトとアイテムドロップ
                    createParticles(e.x, e.y, 15, { 
                        minSpeed: 2, maxSpeed: 8, 
                        color: e.color, 
                        gravity: 0.1, 
                        type: 'explosion' 
                    });
                    
                    if (Math.random() < 0.4) {
                        spawnItem(e.x, e.y);
                    }
                    continue;
                }
                // Handle enemy warp-in state
                if (e.spawnState === 'warping') {
                    if (--e.spawnTimer <= 0) e.spawnState = 'active';
                    continue;
                }
                // Enemy shooting logic
                if (Math.random() < 0.01 && Date.now() - e.lastShot > 2000) {
                    const dx = player.x - e.x, dy = player.y - e.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < W) { // Only shoot if player is somewhat nearby
                        bullets.push({ type: 'enemy', x: e.x, y: e.y, vx: (dx/dist)*5, vy: (dy/dist)*5, w: 8, h: 8, color: '#ff3333', damage: 10 });
                        e.lastShot = Date.now();
                    }
                }
                // Update enemy position
                e.x += e.vx; e.y += e.vy;
                // Remove enemies that go off-screen
                if (e.x < scrollX - 100) enemies.splice(i, 1);
            }
        }
        
        /**
        * Updates bullet positions and handles missile guidance.
        */
        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                // Missile guidance logic
                if (b.type === 'missile' && b.fuel-- > 0) {
                    let target = null, minDist = Infinity;
                    // Find closest enemy as target
                    enemies.forEach(e => {
                        const dist = Math.hypot(e.x - b.x, e.y - b.y);
                        if (dist < minDist && dist < W/2) { minDist = dist; target = e; }
                    });
                    if (target) {
                        // Adjust velocity towards target
                        const angle = Math.atan2(target.y - b.y, target.x - b.x);
                        b.vx += (Math.cos(angle) * b.speed - b.vx) * 0.1;
                        b.vy += (Math.sin(angle) * b.speed - b.vy) * 0.1;
                    }
                }
                // Update bullet position
                b.x += b.vx; b.y += b.vy;
                // Remove bullets that go off-screen
                if (b.x < scrollX - 50 || b.x > scrollX + W + 50 || b.y < -50 || b.y > H + 50) bullets.splice(i, 1);
            }
        }
        
        /**
        * Updates particle positions and lifespans.
        */
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.life--;
                if (p.life <= 0) { particles.splice(i, 1); continue; }
                p.x += p.vx; p.y += p.vy; p.vy += p.gravity;
                // Slowly shrink particles
                p.size = Math.max(0, p.size - 0.05);
            }
        }
        
        /**
        * Updates bomb effect animations.
        */
        function updateBombEffects() {
            for (let i = bombEffects.length - 1; i >= 0; i--) {
                const effect = bombEffects[i];
                effect.life--;
                if (effect.life <= 0) {
                    bombEffects.splice(i, 1);
                    continue;
                }
                // Expand the radius
                effect.radius = (effect.maxRadius * (effect.maxLife - effect.life)) / effect.maxLife;
            }
        }
        
        /**
        * Updates item positions and lifespans.
        */
        function updateItems() {
            for (let i = items.length - 1; i >= 0; i--) {
                const item = items[i];
                item.life--;
                if (item.life <= 0) {
                    items.splice(i, 1);
                    continue;
                }
                item.x += item.vx;
                item.y += item.vy;
                item.vx *= 0.95; // Damping
                item.vy *= 0.95;
            }
        }
        
        /**
        * Updates transformation effect animations.
        */
        function updateTransformEffects() {
            for (let i = transformEffects.length - 1; i >= 0; i--) {
                const effect = transformEffects[i];
                effect.life--;
                if (effect.life <= 0) {
                    transformEffects.splice(i, 1);
                    continue;
                }
                effect.radius += effect.speed;
                effect.opacity = effect.life / effect.maxLife;
            }
        }
        
        
         
        /* ──────────────────────────────────────
         📌 衝突検出
        ────────────────────────────────────── */
        /**
        * Checks for collisions between various game entities.
        */
        function checkCollisions() {
            // [変更1] プレイヤーの衝突判定領域を画面中央(W/2)基準に修正（アイテム取得問題の解消）
            const playerBox = { x: W/2 - player.w/2, y: player.y, w: player.w, h: player.h };
            
            // Player-Enemy collision
            enemies.forEach((e, ei) => {
                if (e.spawnState !== 'active') return; // Cannot collide during warp-in
                const enemyBox = { x: e.x - scrollX, y: e.y, w: e.w, h: e.h };
                if (isColliding(playerBox, enemyBox)) {
                    e.hp = 0; // 敵を破壊
                    const damage = 25; // 衝突ダメージ
                    if (player.shield > 0) {
                        // シールドがダメージを吸収
                        if (player.shield >= damage) {
                            player.shield -= damage;
                        } else {
                            const rem = damage - player.shield;
                            player.shield = 0;
                            player.wingHp -= rem;
                        }
                    } else {
                        // シールドがなければ直接wingHpにダメージ
                        player.wingHp -= damage;
                    }
                    // 爆発パーティクル
                    createParticles(e.x, e.y, 30, { minSpeed: 2, maxSpeed: 8, color: e.color, gravity: 0.1, type: 'explosion' });
                }
            });
            
            // Bullet-Enemy and Bullet-Player collisions
            for (let bi = bullets.length - 1; bi >= 0; bi--) {
                const b = bullets[bi];
                const bulletBox = { x: b.x - scrollX, y: b.y, w: b.w, h: b.h };
                if (b.type !== 'enemy') { // Player bullets
                    let hit = false;
                    for (let ei = enemies.length - 1; ei >= 0; ei--) {
                        const e = enemies[ei];
                        if (e.spawnState !== 'active') continue;
                        const enemyBox = { x: e.x - scrollX, y: e.y, w: e.w, h: e.h };
                        if (isColliding(bulletBox, enemyBox)) {
                            e.hp -= b.damage; // Apply damage
                            hit = true;
                            // Create impact particles at collision point
                            createParticles(b.x, b.y, 5, { minSpeed: 1, maxSpeed: 3, color: b.color, type: 'impact', minLife: 10, maxLife: 20 });
                            break; // Bullet can only hit one enemy
                        }
                    }
                    if (hit) {
                        bullets.splice(bi, 1); // Remove bullet if it hit
                    }
                } else { // Enemy bullets
                    if (isColliding(bulletBox, playerBox)) {
                        if (player.shield > 0) {
                            player.shield = Math.max(0, player.shield - b.damage);
                            player.lastShieldDamage = Date.now();
                            // シールド被弾時にビットドローンを1つ減らす
                            if (player.bits.length > 0) {
                                player.bits.pop();
                            }
                        } else {
                            player.wingHp -= b.damage;
                        }
                        bullets.splice(bi, 1);
                        createParticles(b.x, b.y, 10, { minSpeed: 1, maxSpeed: 4, color: '#ff0000', type: 'impact', minLife: 15, maxLife: 30 });
                    }
                }
            }
            
            // Player-Item collision
            for (let i = items.length - 1; i >= 0; i--) {
                const item = items[i];
                const itemBox = { x: item.x - scrollX, y: item.y, w: item.w, h: item.h };
                if (isColliding(playerBox, itemBox)) {
                    if (item.type === 'hp_pack') {
                        player.hp = Math.min(player.maxHp, player.hp + 20);
                    } else if (item.type === 'bomb_refill') {
                        player.bombs = Math.min(player.bombs + 1, 5);
                    } else if (item.type === 'bit_drone' && player.bits.length < player.maxBits) {
                        const angle = (Math.PI * 2 / (player.bits.length + 1)) * player.bits.length;
                        player.bits.push(new BitDrone(angle));
                    }
                    createParticles(item.x, item.y, 10, {
                        minSpeed: 1,
                        maxSpeed: 3,
                        color: item.color,
                        type: 'collect'
                    });
                    items.splice(i, 1);
                }
            }
            
            // Player-Foreground Obstacle collision
            foregroundObjects.forEach(obj => {
                if (obj.type !== 'obstacle') return;
                // Adjust obstacle position for parallax scrolling
                const objBox = { x: obj.x - scrollX * 1.5, y: obj.y, w: obj.w, h: obj.h };
                if (isColliding(playerBox, objBox)) {
                    player.hp -= 1; // Player takes continuous damage
                    obj.color = rNeon(); // Flash obstacle color
                    // Create small collision particles
                    createParticles(playerBox.x + playerBox.w/2, playerBox.y + playerBox.h/2, 2, { minSpeed: 0.5, maxSpeed: 2, color: '#ff0000', type: 'collision' });
                }
            });
            
            // 空港との衝突処理
            foregroundObjects.forEach((obj, idx) => {
                if (obj.type === 'airport') {
                    const objBox = { x: obj.x - scrollX, y: obj.y, w: obj.w, h: obj.h };
                    if (isColliding(playerBox, objBox)) {
                        // 補給処理（シールド全回復、弾庫補給）
                        player.shield = player.maxShield;
                        player.bombs = 5;
                        createParticles(W/2, player.y + player.h/2, 20, { minSpeed: 1, maxSpeed: 3, color: '#ffffff', type: 'landing' });
                        foregroundObjects.splice(idx, 1); // 空港オブジェクトを除去
                    }
                }
            });
            
            // ゲームオーバーチェック（wingHpが0以下になったら）
            if (player.wingHp <= 0 && !gameOver) {
                gameOver = true;
                endGame();
            }
        }
        
        /**
        * Checks if two rectangular bounding boxes are colliding.
        * @param {object} a - First box {x, y, w, h}.
        * @param {object} b - Second box {x, y, w, h}.
        * @returns {boolean} True if colliding, false otherwise.
        */
        const isColliding = (a,b) => a.x<b.x+b.w && a.x+a.w>b.x && a.y<b.y+b.h && a.y+a.h>b.y;
        
        /* ──────────────────────────────────────
         📌 描画システム
        ────────────────────────────────────── */
        /**
        * Main rendering function, calls all other draw functions.
        */
        function render() {
            ctx.clearRect(0, 0, W, H); // Clear the canvas
            drawBackground();
            drawTerrain();
            drawMidground(); // Draw midground objects
            
            // Draw particles
            particles.forEach(p => {
                ctx.globalAlpha = p.life / p.maxLife; // Fade out particles over time
                ctx.fillStyle = p.color;
                // Adjust particle position based on type for visual consistency
                let drawX = p.x;
                if (p.type !== 'warp_trail' && p.type !== 'thruster' && p.type !== 'transform_burst') { // Most particles scroll
                    drawX -= scrollX;
                } else { // Thruster/warp trail/transform burst particles are relative to player's screen position
                drawX = p.x - (player.x - W/4); // Fix their x position relative to player
            }
            ctx.fillRect(drawX, p.y, p.size, p.size);
        });
        ctx.globalAlpha = 1;
        
        // Draw bullets
        bullets.forEach(b => {
            ctx.fillStyle = b.color;
            ctx.shadowColor = b.color;
            ctx.shadowBlur = 10;
            ctx.fillRect(b.x - scrollX, b.y, b.w, b.h);
            ctx.shadowBlur = 0; // Reset shadow
        });
        
        drawPlayer();
        drawEnemies();
        drawForeground(); // Draw foreground obstacles
        drawBombEffects(); // Draw bomb effects
        drawItems(); // Draw dropped items
        drawTransformEffects(); // Draw transformation effects
        updateHUD();
    }
    
    /**
    * Draws the starry background with parallax effect.
    */
    function drawBackground() {
        ctx.fillStyle = '#0a0a2e'; ctx.fillRect(0,0,W,H); // Base background color
        stars.forEach(s => {
            // Calculate parallax scroll
            let x = (s.x - scrollX * (s.layer / 4));
            // Wrap stars around the screen
            x = (x % (W + 50) + (W + 50)) % (W + 50) - 50;
            ctx.globalAlpha = 0.5 + 0.5 * Math.sin(s.twinkle += 0.01); // Twinkling effect
            ctx.fillStyle = '#fff';
            ctx.fillRect(x, s.y, s.size, s.size);
        });
        ctx.globalAlpha = 1;
    }
    
    /**
    * Draws the terrain using line segments.
    */
    function drawTerrain() {
        ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 1.5; ctx.globalAlpha = 0.4;
        ctx.beginPath();
        const startSeg = Math.floor(scrollX / SEG_W);
        const endSeg = startSeg + Math.ceil(W / SEG_W) + 2; // +2 for off-screen drawing
        for (let i = startSeg; i <= endSeg; i++) {
            const xPos = i * SEG_W - scrollX;
            const yPos = getY(i);
            if (i === startSeg) {
                ctx.moveTo(xPos, yPos);
            } else {
                ctx.lineTo(xPos, yPos);
            }
        }
        ctx.stroke();
        ctx.globalAlpha = 1;
    }
    
    /**
    * Draws the player spaceship or robot.
    */
    function drawPlayer() {
        ctx.save();
        ctx.translate(W/2, player.y + player.h/2);
        
        // シールドの描画
        if (player.shield > 0) {
            drawShield(0, 0, player.w * 0.8, player.shield / player.maxShield);
        }
        
        if (player.isWarping > 0) ctx.globalAlpha = player.isWarping / 15;
        ctx.scale(player.dir, 1);
        
        if (player.isRobot) {
            // ロボットモード：drawRobotParts()を使用
            drawRobotParts();
        } else {
            // 戦闘機モード：従来のパーツ描画
            drawFighterParts();
        }
        ctx.restore();
        
        // ビットドローン描画
        player.bits.forEach(bit => bit.draw(ctx, scrollX));
        
        // 【変更】レーザーのチャージエフェクトを機首付近に描画（自機描画位置を基準）
        if (player.isCharging) {
            const chargeRatio = player.chargeLevel / player.maxCharge;
            ctx.save();
            // 機首先端位置：画面中央から自機幅/2の位置（player.dirで左右）
            ctx.translate(W/2 + (player.w/2) * player.dir, player.y + player.h/2);
            ctx.fillStyle = `rgba(255,255,0,${0.5 + 0.5 * chargeRatio})`;
            ctx.beginPath();
            ctx.arc(0, 0, 10 + 20 * chargeRatio, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }
    }
    
    /**
    * Draws all active enemies.
    */
    function drawEnemies() {
        enemies.forEach(e => {
            const screenX = e.x - scrollX;
            if (screenX < -e.w || screenX > W + e.w) return;
            ctx.save();
            ctx.translate(screenX + e.w/2, e.y + e.h/2);
            
            if (e.spawnState === 'warping') {
                const p = (60 - e.spawnTimer) / 60;
                ctx.globalAlpha = p;
                ctx.scale(p, p);
                ctx.rotate(p * Math.PI * 2);
                createParticles(e.x, e.y, 1, { minSpeed: 1, maxSpeed: 2, color: '#fff', type: 'spawn_fx' });
            }
            
            // タイプごとのリアルなデザイン
            if (e.type === 'bomber') {
                // 爆撃機 - 重厚で角ばったデザイン
                ctx.shadowColor = e.color;
                ctx.shadowBlur = 12;
                
                // メイン胴体
                ctx.fillStyle = e.color;
                ctx.fillRect(-e.w/2, -e.h/3, e.w, e.h/1.5);
                
                // ノーズコーン
                ctx.beginPath();
                ctx.moveTo(e.w/2, 0);
                ctx.lineTo(e.w/3, -e.h/4);
                ctx.lineTo(e.w/3, e.h/4);
                ctx.closePath();
                ctx.fill();
                
                // 主翼
                ctx.fillRect(-e.w/3, -e.h/2, e.w/1.5, e.h/8);
                ctx.fillRect(-e.w/3, e.h/2 - e.h/8, e.w/1.5, e.h/8);
                
                // エンジン
                const engineColor = '#444';
                ctx.fillStyle = engineColor;
                ctx.fillRect(-e.w/2.5, -e.h/2.5, e.w/6, e.h/3);
                ctx.fillRect(-e.w/2.5, e.h/5, e.w/6, e.h/3);
                
                // 排気炎
                if (Math.random() > 0.7) {
                    ctx.fillStyle = '#ff6600';
                    ctx.fillRect(-e.w/2.2, -e.h/3, e.w/12, e.h/8);
                    ctx.fillRect(-e.w/2.2, e.h/4, e.w/12, e.h/8);
                }
                
                // コックピット
                ctx.fillStyle = '#000080';
                ctx.fillRect(e.w/6, -e.h/6, e.w/4, e.h/3);
                
            } else if (e.type === 'fighter') {
                // 戦闘機 - スマートで鋭角的なデザイン
                ctx.shadowColor = e.color;
                ctx.shadowBlur = 8;
                
                // メイン胴体
                ctx.fillStyle = e.color;
                ctx.beginPath();
                ctx.moveTo(e.w * 0.5, 0);              // 鋭いノーズ
                ctx.lineTo(e.w * 0.2, -e.h * 0.15);    // 上部胴体
                ctx.lineTo(-e.w * 0.4, -e.h * 0.1);    // 胴体後部上
                ctx.lineTo(-e.w * 0.5, 0);             // 尾部
                ctx.lineTo(-e.w * 0.4, e.h * 0.1);     // 胴体後部下
                ctx.lineTo(e.w * 0.2, e.h * 0.15);     // 下部胴体
                ctx.closePath();
                ctx.fill();
                
                // 主翼（デルタ翼風）
                ctx.beginPath();
                ctx.moveTo(e.w * 0.1, -e.h * 0.15);
                ctx.lineTo(-e.w * 0.2, -e.h * 0.5);    // 左翼端
                ctx.lineTo(-e.w * 0.3, -e.h * 0.2);    // 翼付け根
                ctx.lineTo(-e.w * 0.3, e.h * 0.2);     // 翼付け根
                ctx.lineTo(-e.w * 0.2, e.h * 0.5);     // 右翼端
                ctx.lineTo(e.w * 0.1, e.h * 0.15);
                ctx.closePath();
                ctx.fill();
                
                // エンジン排気口
                ctx.fillStyle = '#333';
                ctx.fillRect(-e.w/2, -e.h/8, e.w/8, e.h/4);
                
                // アフターバーナー
                if (Math.random() > 0.6) {
                    ctx.fillStyle = '#0099ff';
                    ctx.fillRect(-e.w/1.8, -e.h/12, e.w/6, e.h/6);
                    ctx.fillStyle = '#66ccff';
                    ctx.fillRect(-e.w/1.9, -e.h/16, e.w/8, e.h/8);
                }
                
                // コックピット
                ctx.fillStyle = '#001122';
                ctx.beginPath();
                ctx.ellipse(e.w/4, 0, e.w/8, e.h/6, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // 武装ハードポイント
                ctx.fillStyle = '#666';
                ctx.fillRect(-e.w/8, -e.h/3, e.w/12, e.h/8);
                ctx.fillRect(-e.w/8, e.h/4, e.w/12, e.h/8);
                
            } else if (e.type === 'heli') {
                // ヘリコプター - 複雑で機械的なデザイン
                ctx.shadowColor = e.color;
                ctx.shadowBlur = 10;
                
                // メイン胴体（楕円形）
                ctx.fillStyle = e.color;
                ctx.beginPath();
                ctx.ellipse(0, e.h/6, e.w/2.5, e.h/3, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // テールブーム
                ctx.fillRect(-e.w/2.5, e.h/8, e.w/1.5, e.h/6);
                
                // テールローター
                const tailRotorAngle = (Date.now() * 0.05) % (Math.PI * 2);
                ctx.save();
                ctx.translate(-e.w/2, e.h/6);
                ctx.rotate(tailRotorAngle);
                ctx.fillStyle = '#888';
                ctx.fillRect(-e.w/8, -1, e.w/4, 2);
                ctx.fillRect(-1, -e.w/8, 2, e.w/4);
                ctx.restore();
                
                // メインローター軸
                ctx.fillStyle = '#333';
                ctx.fillRect(-e.w/20, -e.h/2, e.w/10, e.h/3);
                
                // メインローターブレード（回転）
                const mainRotorAngle = (Date.now() * 0.1) % (Math.PI * 2);
                ctx.save();
                ctx.translate(0, -e.h/3);
                ctx.rotate(mainRotorAngle);
                ctx.fillStyle = '#666';
                // ブレード1
                ctx.fillRect(-e.w/1.2, -3, e.w/0.6, 6);
                // ブレード2
                ctx.rotate(Math.PI / 2);
                ctx.fillRect(-e.w/1.2, -3, e.w/0.6, 6);
                ctx.restore();
                
                // ローターハブ
                ctx.fillStyle = '#444';
                ctx.beginPath();
                ctx.ellipse(0, -e.h/3, e.w/12, e.w/12, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // コックピット
                ctx.fillStyle = '#001122';
                ctx.beginPath();
                ctx.ellipse(e.w/6, e.h/6, e.w/6, e.h/8, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // ランディングスキッド
                ctx.fillStyle = '#555';
                ctx.fillRect(-e.w/3, e.h/2.5, e.w/1.5, e.h/12);
                ctx.fillRect(-e.w/4, e.h/2.2, e.w/20, e.h/8);
                ctx.fillRect(e.w/5, e.h/2.2, e.w/20, e.h/8);
                
                // 武装ポッド
                ctx.fillStyle = '#444';
                ctx.fillRect(-e.w/6, e.h/3, e.w/8, e.h/6);
                ctx.fillRect(e.w/12, e.h/3, e.w/8, e.h/6);
            }
            
            // ダメージエフェクト
            if (e.health < e.maxHealth * 0.3) {
                // 煙エフェクト
                if (Math.random() > 0.8) {
                    createParticles(e.x, e.y, 1, { 
                        minSpeed: 0.5, 
                        maxSpeed: 1.5, 
                        color: '#666', 
                        type: 'smoke',
                        life: 30 
                    });
                }
                
                // 火花
                if (Math.random() > 0.9) {
                    createParticles(e.x, e.y, 2, { 
                        minSpeed: 2, 
                        maxSpeed: 4, 
                        color: '#ffaa00', 
                        type: 'sparks',
                        life: 15 
                    });
                }
            }
            
            ctx.restore();
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;
        });
    }
    
    /**
    * Draws midground decorative objects with slower parallax.
    */
    function drawMidground() {
        midgroundObjects.forEach(obj => {
            const screenX = obj.x - scrollX * 0.8; // Slower parallax for midground
            if (screenX < -obj.w || screenX > W) return;
            ctx.save();
            ctx.translate(screenX + obj.w/2, obj.y + obj.h/2);
            ctx.rotate(obj.rotation);
            ctx.fillStyle = obj.color;
            ctx.fillRect(-obj.w/2, -obj.h/2, obj.w, obj.h);
            ctx.restore();
        });
    }
    
    /**
    * Draws foreground obstacles and decorations with faster parallax.
    */
    function drawForeground() {
        foregroundObjects.forEach(obj => {
            const screenX = obj.x - scrollX * 1.5; // Faster parallax for foreground
            if (screenX < -obj.w || screenX > W) return;
            
            ctx.save();
            ctx.translate(screenX + obj.w / 2, obj.y + obj.h / 2);
            ctx.rotate(obj.rotation);
              
            ctx.fillStyle = obj.color;
            ctx.strokeStyle = obj.outline || 'transparent';
            ctx.lineWidth = 2;
              
            // Drawing based on object type
            if (obj.type === 'obstacle' || obj.type === 'decoration') {
                ctx.fillRect(-obj.w/2, -obj.h/2, obj.w, obj.h);
                ctx.strokeRect(-obj.w/2, -obj.h/2, obj.w, obj.h);
            } else if (obj.type === 'building') {
                ctx.fillRect(-obj.w/2, -obj.h/2, obj.w, obj.h);
                ctx.strokeRect(-obj.w/2, -obj.h/2, obj.w, obj.h);
                // Add simple windows
                ctx.fillStyle = obj.windowColor || '#00ffff';
                const windowW = obj.w * 0.15;
                const windowH = obj.h * 0.1;
                for (let r = 0; r < 3; r++) {
                    for (let c = 0; c < 2; c++) {
                        ctx.fillRect(-obj.w/4 + c * obj.w/4.5, -obj.h/3 + r * obj.h/4, windowW, windowH);
                    }
                }
            } else if (obj.type === 'mountain') {
                ctx.beginPath();
                ctx.moveTo(-obj.w/2, obj.h/2);
                ctx.lineTo(0, -obj.h/2);
                ctx.lineTo(obj.w/2, obj.h/2);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            } else if (obj.type === 'animal') {
                ctx.beginPath();
                ctx.ellipse(0, 0, obj.w/2, obj.h/3, 0, 0, Math.PI * 2); // Body
                ctx.fill();
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(obj.w/4, -obj.h/3, obj.w/8, 0, Math.PI * 2); // Head
                ctx.fill();
                ctx.stroke();
            } else if (obj.type === 'person') {
                ctx.fillRect(-obj.w/4, -obj.h/2, obj.w/2, obj.h/2); // Body
                ctx.beginPath();
                ctx.arc(0, -obj.h/2, obj.w/4, 0, Math.PI * 2); // Head
                ctx.fill();
                ctx.stroke();
            }
            ctx.restore();
        });
    }
    
    /**
    * Draws active bomb explosion effects.
    */
    function drawBombEffects() {
        bombEffects.forEach(effect => {
            const opacity = effect.life / effect.maxLife;
            ctx.globalAlpha = opacity * 0.6;
            ctx.strokeStyle = effect.color;
            ctx.lineWidth = 5 * opacity;
            ctx.shadowColor = effect.color;
            ctx.shadowBlur = 30 * opacity; // Glow effect
            
            ctx.beginPath();
            ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2);
            ctx.stroke();
            
            // Inner flash
            ctx.globalAlpha = opacity * 0.3;
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(effect.x, effect.y, effect.radius * 0.2, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.globalAlpha = 1; // Reset alpha
            ctx.shadowBlur = 0; // Reset shadow
        });
    }
    
    /**
    * Draws active dropped items.
    */
    function drawItems() {
        items.forEach(item => {
            const screenX = item.x - scrollX;
            ctx.save();
            ctx.translate(screenX + item.w/2, item.y + item.h/2);
            
            // アイテム発光エフェクト
            ctx.globalAlpha = 0.3 + Math.sin(Date.now() * 0.01) * 0.2;
            ctx.shadowColor = item.color;
            ctx.shadowBlur = 15 + Math.sin(Date.now() * 0.01) * 5;
            
            // アイテム種類別の形状
            switch(item.type) {
                case 'hp_pack':
                // 十字型
                ctx.fillStyle = '#00ff00';
                ctx.fillRect(-item.w/4, -item.h/2, item.w/2, item.h);
                ctx.fillRect(-item.w/2, -item.h/4, item.w, item.h/2);
                break;
                case 'bomb_refill':
                // 円形+三角
                ctx.fillStyle = '#ff00ff';
                ctx.beginPath();
                ctx.arc(0, 0, item.w/2, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(0, -item.h/2);
                ctx.lineTo(item.w/4, -item.h/2 - item.h/4);
                ctx.lineTo(-item.w/4, -item.h/2 - item.h/4);
                ctx.fill();
                break;
                case 'bit_drone':
                // 六角形
                ctx.fillStyle = '#00ffff';
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (i * Math.PI * 2) / 6;
                    const x = Math.cos(angle) * item.w/2;
                    const y = Math.sin(angle) * item.w/2;
                    i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
                // 中心点
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(0, 0, item.w/6, 0, Math.PI * 2);
                ctx.fill();
                break;
            }
            
            // 取得可能範囲表示
            ctx.globalAlpha = 0.2;
            ctx.strokeStyle = item.color;
            ctx.beginPath();
            ctx.arc(0, 0, item.w, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.restore();
        });
    }
    
    /**
    * Draws active transformation effects.
    */
    function drawTransformEffects() {
        transformEffects.forEach(effect => {
            const screenX = effect.x - scrollX;
            ctx.globalAlpha = effect.opacity;
            ctx.strokeStyle = effect.color;
            ctx.lineWidth = effect.lineWidth * effect.opacity;
            ctx.shadowColor = effect.color;
            ctx.shadowBlur = effect.shadowBlur * effect.opacity;
            ctx.beginPath();
            ctx.arc(screenX, effect.y, effect.radius, 0, Math.PI * 2);
            ctx.stroke();
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;
        });
    }
    
    
     
    /* ──────────────────────────────────────
     📌 UI & ゲーム制御
    ────────────────────────────────────── */
    /**
    * Updates the Heads-Up Display (HUD) with current game information.
    */
    function updateHUD() {
        scoreEl.textContent = `Score: ${score}`;
        let weaponText = player.weapon.toUpperCase();
        if (player.weapon === 'bomb') weaponText += ` x${player.bombs}`; // Show bomb count
        else if (player.weapon === 'laser' && player.isCharging) weaponText += ` ${Math.floor(player.chargeLevel)}%`; // Show laser charge
        hud.innerHTML = `Weapon: ${weaponText}<br>High Score: ${high}<br>Form: ${player.isRobot ? 'ROBOT' : 'HUMAN'}`; // Show player form
        // シールドゲージの表示（%に換算）
        const shieldPct = Math.max(0, player.shield / player.maxShield) * 100;
        const wingPct = Math.max(0, player.wingHp / player.maxWingHp) * 100;
        hud.innerHTML += `<br>Shield: ${Math.floor(shieldPct)}%`;
        hud.innerHTML += `<br>Wing HP: ${Math.floor(wingPct)}%`;
        hpbar.style.width = wingPct + '%';
        if (player.comboCount > 1) {
            hud.innerHTML += `<br>Combo: ${player.comboCount}x`;
        }
    }
    
    /**
    * The main game loop, called repeatedly using requestAnimationFrame.
    */
    function gameLoop() {
        if (!playing) return; // Stop loop if game is not playing
        update(); // Update game state
        render(); // Redraw game elements
        requestAnimationFrame(gameLoop); // Request next frame
    }
    
    /**
    * Initializes and starts a new game.
    */
    function startGame(isNewGame = true) {
        if (isNewGame) {
            // 完全リセット
            score = 0;
            high = Number(localStorage.getItem('cshooter-hi')) || 0;
        }
        
        // プレイヤー状態のリセット
        Object.assign(player, {
            x: 0, y: H/2, vx: 0, vy: 0,
            wingHp: 50, shield: 50,
            bombs: 3,
            isWarping: 0,
            lastWarpTime: 0,
            isCharging: false,
            chargeLevel: 0,
            isRobot: false,
            lastTransformTime: 0,
            w: player.humanW,
            h: player.humanH,
            maxSpeed: 6,
            bits: []
        });
        
        // Hide menu and result screens
        document.getElementById('menu').style.display = 'none';
        document.getElementById('result').style.display = 'none';
          
        // Clear all dynamic game entities
        enemies.length = 0;
        bullets.length = 0;
        particles.length = 0;
        bombEffects.length = 0; // Clear bomb effects
        items.length = 0; // Clear dropped items
        transformEffects.length = 0; // Clear transformation effects
        score = 0;
        scrollX = 0;
        gameOver = false;
          
        makeWorld(); // Re-generate the game world
          
        playing = true;
        clearInterval(enemyTimer); // Clear any existing enemy spawn timer
        enemyTimer = setInterval(spawnEnemy, ENEMY_INT); // Start new enemy spawn timer
          
        gameLoop(); // Start the main game loop
    }
    
    /**
    * Ends the current game session.
    */
    function endGame() {
        playing = false;
        clearInterval(enemyTimer); // Stop enemy spawning
        if (score > high) { // Update high score if current score is higher
            high = score;
            localStorage.setItem('cshooter-hi', high);
        }
        document.getElementById('resText').textContent = `FINAL SCORE: ${score}`; // Display final score
        document.getElementById('result').style.display = 'block'; // Show result panel
    }
    
    // Event listeners for start and retry buttons
    document.getElementById('newGameBtn').addEventListener('click', () => startGame(true));
    document.getElementById('continueBtn').addEventListener('click', () => startGame(false));
    document.getElementById('retryBtn').addEventListener('click', () => startGame(true));
    
    setupInput(); // Initialize input handling
</script>
</body>
</html>
