<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Multi-Board Painter with Undo/Redo & Context Menu</title>

  <!-- React / ReactDOM / MUI / Babel / Fabric.js -->
  <script src="https://cdn.jsdelivr.net/npm/react@18/umd/react.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mui/material@5.15.14/umd/material-ui.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.2/babel.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.2.4/fabric.min.js"></script>
  <script src="https://unpkg.com/xlsx/dist/xlsx.full.min.js"></script>
  <script src="https://unpkg.com/exceljs/dist/exceljs.min.js"></script>

  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap">
  <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">

  <style>
    html, body, #root { height:100%; margin:0; overflow:hidden; }
    .canvas-container {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      background: #f5f5f5;
      padding: 24px;
      overflow: hidden;
    }
    .canvas-wrapper {
      position: relative;
      transform-origin: center;
      transition: transform 0.2s;
    }
    .zoom-controls {
      position: absolute;
      bottom: 16px;
      right: 16px;
      display: flex;
      gap: 8px;
      padding: 8px;
      background: rgba(255,255,255,0.9);
      border-radius: 4px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .current-status {
      position: absolute;
      bottom: 16px;
      left: 16px;
      display: flex;
      gap: 16px;
      padding: 8px;
      background: rgba(255,255,255,0.9);
      border-radius: 4px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      align-items: center;
    }
    .current-color {
      width: 24px;
      height: 24px;
      border-radius: 4px;
      border: 2px solid #fff;
      box-shadow: 0 0 0 1px rgba(0,0,0,0.1);
    }
    .current-colors {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .color-preview {
      display: flex;
      flex-direction: column;
      gap: 4px;
      cursor: pointer;
    }
    .color-label {
      font-size: 10px;
      text-align: center;
      color: #666;
    }
    canvas {
      display: block;
      margin: 0 auto;
      border: 1px solid #ccc;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .tool-scroll {
      display: flex;
      overflow-x: auto;
      gap: 1rem;
      padding: .75rem;
      background: #fff;
      border-bottom: 1px solid #eee;
    }
    .tool-group {
      display: flex;
      gap: .5rem;
      padding: 0 .5rem;
      border-right: 1px solid #eee;
    }
    .tool-group:last-child { border-right:none; }
    .layer-color {
      width: 28px; height: 28px;
      border: 2px solid #fff;
      border-radius: 4px;
      padding: 0; margin-right: 8px;
      cursor: pointer;
      box-shadow: 0 0 0 1px rgba(0,0,0,0.1);
    }
    .color-palette {
      display: grid;
      grid-template-columns: repeat(6,1fr);
      gap: .5rem;
      padding: .5rem;
      background:#fff;
      border-radius:4px;
    }
    .color-swatch {
      width:32px; height:32px;
      border-radius:4px;
      cursor:pointer;
      border:2px solid #fff;
      box-shadow:0 0 0 1px rgba(0,0,0,0.1);
    }
    .thumb-container {
      position: relative;
      padding-top: 75%;
      background:#fff;
      border-radius:4px;
      overflow:hidden;
      box-shadow:0 1px 3px rgba(0,0,0,0.1);
    }
    .thumb {
      position:absolute;
      top:0; left:0;
      width:100%; height:100%;
      object-fit:contain;
    }
    .panel {
      position:absolute;
      background:white;
      border-radius:4px;
      box-shadow:0 2px 8px rgba(0,0,0,0.15);
      min-width:240px; max-width:320px;
      display:flex; flex-direction:column;
      max-height:80vh;
      resize:both; overflow:auto;
    }
    .panel-header {
      padding:8px 16px;
      background:#f5f5f5;
      border-bottom:1px solid #ddd;
      cursor:move; user-select:none;
      display:flex; align-items:center; justify-content:space-between;
    }
    .color-controls { display:flex; flex-direction:column; gap:16px; padding:16px; }
    .color-preview-large {
      width:100%; height:60px;
      border-radius:4px;
      box-shadow:0 1px 3px rgba(0,0,0,0.2);
    }
    .layer-colors { display:flex; gap:8px; }
    .layer-color-item { display:flex; flex-direction:column; align-items:center; gap:4px; }
    .color-input-group { display:flex; flex-direction:column; gap:8px; }
    .color-input-row { display:flex; align-items:center; gap:8px; }
    .alpha-slider { flex:1; }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const {
      Box, AppBar, Toolbar, IconButton, Typography, Button, CssBaseline,
      Drawer, List, ListItem, ListItemText, Divider, Tooltip,
      Dialog, DialogTitle, DialogContent, DialogActions, TextField,
      Menu, MenuItem, Grid, ListItemIcon, FormControl, FormLabel,
      RadioGroup, FormControlLabel, Radio, Slider
    } = MaterialUI;

    /* ---------- 色ユーティリティ ---------- */
    function colorToString(color){
      if(!color) return '#000000';
      if(typeof color==='string') return color;
      const {color:hex='#000000',alpha=1}=color;
      if(alpha===1) return hex;
      const r=parseInt(hex.slice(1,3),16);
      const g=parseInt(hex.slice(3,5),16);
      const b=parseInt(hex.slice(5,7),16);
      return `rgba(${r},${g},${b},${alpha})`;
    }
    function rgbaToHex(rgba){
      const m=rgba.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
      if(!m) return '#000000';
      const [_,r,g,b]=m;
      return `#${(1<<24 | r<<16 | g<<8 | b).toString(16).slice(1)}`;
    }
    const getAlpha=c=>(c&&c.startsWith('rgba')?parseFloat(c.split(',')[3]):1);

    /* ---------- StatusBar ---------- */
    function StatusBar({fillColor,strokeColor,boardSize,onColorClick,onSizeClick}){
      return(
        <div className="current-status">
          <div className="current-colors">
            <Tooltip title="塗りの色">
              <div className="color-preview" onClick={e=>{e.stopPropagation();onColorClick('fill',fillColor.color);}}>
                <div className="current-color" style={{background:colorToString(fillColor)}}/>
                <span className="color-label">塗り ({Math.round(fillColor.alpha*100)}%)</span>
              </div>
            </Tooltip>
            <Tooltip title="線の色">
              <div className="color-preview" onClick={e=>{e.stopPropagation();onColorClick('stroke',strokeColor.color);}}>
                <div className="current-color" style={{background:colorToString(strokeColor)}}/>
                <span className="color-label">線 ({Math.round(strokeColor.alpha*100)}%)</span>
              </div>
            </Tooltip>
          </div>
          <Tooltip title="サイズを変更">
            <Button size="small" sx={{textTransform:'none'}} onClick={onSizeClick}>
              {boardSize.w} × {boardSize.h}px
            </Button>
          </Tooltip>
        </div>
      );
    }

    /* ---------- ZoomControls ---------- */
    function ZoomControls({zoom,onZoomChange}){
      return(
        <div className="zoom-controls">
          <IconButton size="small" onClick={()=>onZoomChange(-0.1)}>
            <span className="material-icons">remove</span>
          </IconButton>
          <Typography variant="body2" sx={{minWidth:40,textAlign:'center'}}>
            {Math.round(zoom*100)}%
          </Typography>
          <IconButton size="small" onClick={()=>onZoomChange(0.1)}>
            <span className="material-icons">add</span>
          </IconButton>
        </div>
      );
    }

    /* ================================================================= */
    /*                              App                                  */
    /* ================================================================= */
    function App() {
      const drawerWidth=260;

      /* ----- state ----- */
      const [boards,setBoards]=React.useState([{id:1,name:'ボード1',w:800,h:600,json:null,history:[],historyIndex:-1}]);
      const [cur,setCur]=React.useState(0);
      const [view,setView]=React.useState('single');
      const [drawerOpen,setDrawerOpen]=React.useState(false);

      const [tool,setTool]=React.useState('select');
      const [textDlg,setTextDlg]=React.useState(false);
      const [textVal,setTextVal]=React.useState('');
      const [sizeDlg,setSizeDlg]=React.useState(false);
      const [sizeVal,setSizeVal]=React.useState({w:800,h:600});

      const [layers,setLayers]=React.useState([]);
      const [contextMenu,setContextMenu]=React.useState(null);
      const [colorDlg,setColorDlg]=React.useState(false);
      const [colorVal,setColorVal]=React.useState('#000000');

      const fabricRef=React.useRef(null);
      const [zoom,setZoom]=React.useState(1);
      const [camera,setCamera]=React.useState(null);

      const [panels,setPanels]=React.useState({
        artboards:{open:true,x:16,y:80},
        objects:{open:true,x:window.innerWidth-336,y:80}
      });

      const [galleryDlg,setGalleryDlg]=React.useState(false);
      const [exportDlg,setExportDlg]=React.useState(false);
      const [exportOpts,setExportOpts]=React.useState({orientation:'landscape',paperSize:'A4',preview:null});

      const [fillColor,setFillColor]=React.useState({color:'#000000',alpha:1});
      const [strokeColor,setStrokeColor]=React.useState({color:'#000000',alpha:1});

      const [textStyle,setTextStyle]=React.useState({fontSize:20,fill:'#000000',fontFamily:'sans-serif'});

      /* ----- Fabric 初期化 ----- */
      React.useEffect(()=>{
        const cv=new fabric.Canvas('fabricCanvas',{preserveObjectStacking:true});
        cv.freeDrawingBrush.color='#000';
        cv.freeDrawingBrush.width=2;
        fabricRef.current=cv;

        cv.on('object:added',updateLayers);
        cv.on('object:removed',updateLayers);
        cv.on('object:modified',updateLayers);

        cv.on('mouse:down',opt=>{
          if(opt.e.button===2&&opt.target){
            opt.e.preventDefault();
            setContextMenu({mouseX:opt.e.clientX,mouseY:opt.e.clientY,forObject:opt.target});
          }
        });
        cv.upperCanvasEl.addEventListener('contextmenu',e=>e.preventDefault());

        loadBoard(0);
        return()=>cv.dispose();
      },[]);

      /* ボード切替 */
      React.useEffect(()=>{if(fabricRef.current) loadBoard(cur);},[cur]);

      /* ブラシ色同期 */
      React.useEffect(()=>{
        if(fabricRef.current) fabricRef.current.freeDrawingBrush.color=colorToString(strokeColor);
      },[strokeColor]);

      /* ---------- Board ヘルパ ---------- */
      function loadJSON(json,w,h){
        const cv=fabricRef.current;
        cv.clear();
        cv.setWidth(w).setHeight(h);
        cv.setBackgroundColor('#fff',cv.renderAll.bind(cv));
        if(json){
          cv.loadFromJSON(json,()=>{cv.renderAll();updateLayers();});
        }else{cv.renderAll();updateLayers();}
      }
      function loadBoard(idx){
        const b=boards[idx];
        loadJSON(b.json,b.w,b.h);
        setBoards(bs=>bs.map((bd,i)=>{
          if(i===idx&&bd.history.length===0){
            const snap=fabricRef.current.toJSON();
            return {...bd,history:[snap],historyIndex:0};
          }
          return bd;
        }));
        selectTool('select',false);
      }
      function saveCurrent(){
        const cv=fabricRef.current,newJson=cv.toJSON();
        setBoards(bs=>bs.map((b,i)=>{
          if(i===cur){
            const hist=b.history.slice(0,b.historyIndex+1);
            hist.push(newJson);
            return {...b,json:newJson,history:hist,historyIndex:hist.length-1};
          }
          return b;
        }));
        updateLayers();
      }

      /* Undo / Redo */
      const bcur=boards[cur];
      const canUndo=bcur.historyIndex>0;
      const canRedo=bcur.historyIndex<bcur.history.length-1;
      const undo=()=>{if(canUndo){const idx=bcur.historyIndex-1;loadJSON(bcur.history[idx],bcur.w,bcur.h);setBoards(bs=>bs.map((b,i)=>i===cur?{...b,historyIndex:idx,json:bcur.history[idx]}:b));}};const redo=()=>{if(canRedo){const idx=bcur.historyIndex+1;loadJSON(bcur.history[idx],bcur.w,bcur.h);setBoards(bs=>bs.map((b,i)=>i===cur?{...b,historyIndex:idx,json:bcur.history[idx]}:b));}};

      /* Tool 切替 */
      function selectTool(name,save=true){
        if(save) saveCurrent();
        const cv=fabricRef.current;
        setTool(name);
        cv.isDrawingMode=(name==='draw');
        const selectable=(name==='select');
        cv.selection=selectable;
        cv.forEachObject(o=>o.selectable=selectable);
      }

      /* レイヤー更新 */
      function updateLayers(){
        const objs=fabricRef.current.getObjects();
        setLayers(objs.map((o,i)=>({id:i,obj:o,name:`${o.type} ${i+1}`})));
      }

      /* 画像追加 */
      function addImage(file){
        if(!file?.type.startsWith('image/')) return;
        const url=URL.createObjectURL(file);
        fabric.Image.fromURL(url,img=>{
          img.set({left:40,top:40,objectCaching:false});
          fabricRef.current.add(img).setActiveObject(img);
          saveCurrent();
        });
      }

      /* applyColor (一本化) */
      function applyColor(){
        if(!contextMenu) return;
        const {forObject:obj,colorType}=contextMenu;
        const next={color:colorVal,alpha:colorType==='fill'?fillColor.alpha:strokeColor.alpha};

        if(obj){
          obj.set(colorType,colorToString(next));
          fabricRef.current.requestRenderAll();
        }else{
          if(colorType==='fill') setFillColor(next);
          if(colorType==='stroke'){
            setStrokeColor(next);
            fabricRef.current.freeDrawingBrush.color=colorToString(next);
          }
          if(colorType==='text') setTextStyle(s=>({...s,fill:colorVal}));
        }
        saveCurrent();
        setColorDlg(false);
        setContextMenu(null);
      }

      /* 削除 */
      const handleDelete=obj=>{
        const cv=fabricRef.current;
        cv.discardActiveObject();
        cv.remove(obj);
        cv.requestRenderAll();
        updateLayers();
        saveCurrent();
      };

      /* 形状追加 */
      function handleShape(type){
        selectTool(type);
        const cv=fabricRef.current;
        let obj;
        const common={left:60,top:60,fill:colorToString(fillColor),stroke:colorToString(strokeColor),strokeWidth:2};
        switch(type){
          case'rect': obj=new fabric.Rect({...common,width:100,height:60}); break;
          case'ellipse': obj=new fabric.Ellipse({...common,rx:50,ry:30}); break;
          case'arrow':{
            const line=new fabric.Line([0,0,100,0],common);
            const arrow=new fabric.Triangle({
              fill:colorToString(strokeColor),
              width:14,height:20,left:100,top:0,angle:90,
              originX:'center',originY:'center'
            });
            obj=new fabric.Group([line,arrow],common); break;
          }
        }
        if(obj){
          obj.setControlsVisibility({mtr:true});
          cv.add(obj).setActiveObject(obj);
          saveCurrent();
        }
      }

      /* サイズダイアログ → handleSize */
      const handleSize=()=>{const b=boards[cur];setSizeVal({w:b.w,h:b.h});setSizeDlg(true);};

      /* Zoom */
      const handleZoom=delta=>setZoom(z=>{const nz=Math.max(0.1,Math.min(5,z+delta));fabricRef.current.setZoom(nz);return nz;});

      /* カメラ */
      const startCamera=async()=>{try{const s=await navigator.mediaDevices.getUserMedia({video:true});setCamera(s);}catch(e){console.error(e);}};const takePhoto=()=>{const v=document.querySelector('video'),c=document.createElement('canvas');c.width=v.videoWidth; c.height=v.videoHeight;c.getContext('2d').drawImage(v,0,0);c.toBlob(b=>{addImage(new File([b],'photo.jpg',{type:'image/jpeg'}));setCamera(null);},'image/jpeg');};

      /* パネルドラッグ */
      const dragRef=React.useRef(null);
      const startDrag=(e,id)=>{
        const panel=document.getElementById(id),r=panel.getBoundingClientRect();
        dragRef.current={id,ox:e.clientX-r.left,oy:e.clientY-r.top};
        e.preventDefault();
      };
      React.useEffect(()=>{
        const onMove=e=>{
          if(!dragRef.current) return;
          setPanels(p=>({...p,[dragRef.current.id]:{...p[dragRef.current.id],
            x:e.clientX-dragRef.current.ox,y:e.clientY-dragRef.current.oy}}));
        };
        const onUp=()=>{dragRef.current=null;};
        window.addEventListener('mousemove',onMove);
        window.addEventListener('mouseup',onUp);
        return()=>{window.removeEventListener('mousemove',onMove);window.removeEventListener('mouseup',onUp);};
      },[]);

      /* ContextMenu items */
      const contextMenuItems=React.useMemo(()=>{
        if(!contextMenu) return[];
        if(contextMenu.forObject){
          const t=contextMenu.forObject;
          return[
            {label:'コピー',icon:'content_copy',action:()=>{t.clone(c=>{c.set({left:c.left+10,top:c.top+10});fabricRef.current.add(c).setActiveObject(c);saveCurrent();});}},
            {type:'divider'},
            {label:'最前面へ',icon:'vertical_align_top',action:()=>{t.bringToFront();saveCurrent();}},
            {label:'最背面へ',icon:'vertical_align_bottom',action:()=>{t.sendToBack();saveCurrent();}},
            {label:'1つ前面へ',icon:'arrow_upward',action:()=>{t.bringForward();saveCurrent();}},
            {label:'1つ背面へ',icon:'arrow_downward',action:()=>{t.sendBackwards();saveCurrent();}},
            {type:'divider'},
            {label:'削除',icon:'delete',action:()=>handleDelete(t)}
          ];
        }
        return[
          {label:'画像を挿入',icon:'image',action:()=>document.getElementById('fileUp').click()},
          {label:'カメラで撮影',icon:'camera_alt',action:startCamera},
          {type:'divider'},
          {label:'キャンバスをクリア',icon:'clear',action:()=>{
            if(confirm('キャンバスをクリアしますか？')){
              const cv=fabricRef.current;cv.clear();cv.setWidth(bcur.w).setHeight(bcur.h);
              cv.setBackgroundColor('#fff',cv.renderAll.bind(cv));saveCurrent();
            }
          }}
        ];
      },[contextMenu]);

      /* Drawer 中の Layer 色変更ユーティリティ */
      function handleLayerColorChange(layer,type,color,alpha){
        const obj=layer.obj;
        if(!obj) return;
        const a=alpha!==undefined?alpha:getAlpha(type==='fill'?obj.fill:obj.stroke);
        obj.set(type,colorToString({color,alpha:a}));
        fabricRef.current.requestRenderAll();
        saveCurrent();
      }

      /* Drawer Content (Artboards / Layers) */
      const drawerContent=(
        <Box sx={{width:drawerWidth}}>
          <Toolbar/>
          <Typography sx={{px:2,py:1}} variant="subtitle1">Artboards</Typography>
          <List>
            {boards.map((b,i)=>(

              <ListItem button key={b.id} selected={i===cur}
                onClick={()=>{saveCurrent();setCur(i);setView('single');setDrawerOpen(false);}}>
                <ListItemText primary={b.name} secondary={`${b.w}×${b.h}`}/>
              </ListItem>
            ))}
          </List>
          <Divider/>
          <Button fullWidth onClick={()=>{const nid=Math.max(...boards.map(b=>b.id))+1;setBoards([...boards,{id:nid,name:`ボード${nid}`,w:800,h:600,json:null,history:[],historyIndex:-1}]);saveCurrent();setCur(boards.length);setDrawerOpen(false);}}>＋ 新規ボード</Button>
          <Divider sx={{my:2}}/>
          <Typography sx={{px:2,py:1}} variant="subtitle1">Layers</Typography>
          <List>
            {layers.slice().reverse().map(layer=>(

              <ListItem key={layer.id} button
                selected={fabricRef.current?.getActiveObject()===layer.obj}
                onClick={()=>{fabricRef.current.setActiveObject(layer.obj);fabricRef.current.requestRenderAll();}}
                secondaryAction={
                  <Box sx={{display:'flex',gap:0.5}}>
                    <div className="layer-colors">
                      {layer.obj.fill!==undefined&&(
                        <div className="layer-color-item">
                          <Box sx={{display:'flex',alignItems:'center',gap:1}}>
                            <input type="color" className="layer-color"
                              value={layer.obj.fill&&layer.obj.fill.startsWith('rgba')?rgbaToHex(layer.obj.fill):(layer.obj.fill||'#000000')}
                              onChange={e=>handleLayerColorChange(layer,'fill',e.target.value)}/>
                            <Slider size="small" value={getAlpha(layer.obj.fill)} min={0} max={1} step={0.01} sx={{width:60}}
                              onChange={(e,v)=>handleLayerColorChange(layer,'fill',rgbaToHex(layer.obj.fill),v)}/>
                          </Box>
                          <Typography variant="caption">塗り</Typography>
                        </div>
                      )}
                      {layer.obj.stroke!==undefined&&(
                        <div className="layer-color-item">
                          <input type="color" className="layer-color"
                            value={layer.obj.stroke||'#000000'}
                            onChange={e=>handleLayerColorChange(layer,'stroke',e.target.value)}/>
                          <Typography variant="caption">線</Typography>
                        </div>
                      )}
                    </div>
                    <IconButton size="small" onClick={()=>handleDelete(layer.obj)}>
                      <span className="material-icons">delete</span>
                    </IconButton>
                  </Box>
                }>
                <ListItemIcon sx={{minWidth:36}}>
                  <span className="material-icons" style={{fontSize:20}}>
                    {layer.obj.type==='rect'?'crop_square':
                     layer.obj.type==='ellipse'?'circle':
                     layer.obj.type==='i-text'?'title':
                     layer.obj.type==='group'?'arrow_forward':'radio_button_unchecked'}
                  </span>
                </ListItemIcon>
                <ListItemText primary={layer.name} primaryTypographyProps={{variant:'body2'}}/>
              </ListItem>
            ))}

          </List>
        </Box>
      );

      /* ToolBtn */
      const ToolBtn=({icon,label,active,onClick,disabled})=>(

        <Tooltip title={label}>
          <IconButton size="small" color={active?'primary':'default'} onClick={onClick} disabled={disabled}>
            <span className="material-icons">{icon}</span>
          </IconButton>
        </Tooltip>
      );

      /* パネル表示トグル */
      const togglePanel=id=>setPanels(p=>({...p,[id]:{...p[id],open:!p[id].open}}));

      /* テキストカラー処理 */
      const handleTextColor = () => {
        setColorVal(textStyle.fill);
        setContextMenu({ colorType: 'text' });
        setColorDlg(true);
      };

      /* テキスト追加処理 */
      const handleAddText = () => {
        if (!textVal.trim()) return;
        
        const text = new fabric.IText(textVal.trim(), {
          left: 60,
          top: 60,
          fontSize: textStyle.fontSize,
          fill: textStyle.fill,
          fontFamily: textStyle.fontFamily
        });
        
        fabricRef.current.add(text).setActiveObject(text);
        saveCurrent();
        setTextDlg(false);
        setTextVal('');
      };

      /* 新規ボード追加 */
      const addNewBoard = () => {
        const nid = Math.max(...boards.map(b => b.id)) + 1;
        setBoards([...boards, {
          id: nid,
          name: `ボード${nid}`,
          w: 800,
          h: 600,
          json: null,
          history: [],
          historyIndex: -1
        }]);
        saveCurrent();
        setCur(boards.length);
        setGalleryDlg(false);
      };

      /* ----- JSX Render ----- */
      return(
        <Box sx={{height:'100%',display:'flex'}}
          onDragOver={e=>e.preventDefault()}
          onDrop={e=>addImage(e.dataTransfer.files[0])}
          onWheel={e=>{if(e.ctrlKey){e.preventDefault();handleZoom(e.deltaY>0?-0.1:0.1);}}}>
          <CssBaseline/>

          {/* AppBar */}
          <AppBar position="fixed" sx={{zIndex:t=>t.zIndex.drawer+1}}>
            <Toolbar variant="dense">
              <IconButton color="inherit" edge="start" onClick={()=>setDrawerOpen(true)}>
                <span className="material-icons">menu</span>
              </IconButton>
              <Typography sx={{flexGrow:1}} variant="h6">お絵描きシステム</Typography>
              <IconButton color="inherit" onClick={()=>togglePanel('artboards')}>
                <span className="material-icons">dashboard</span>
              </IconButton>
              <IconButton color="inherit" onClick={()=>togglePanel('objects')}>
                <span className="material-icons">layers</span>
              </IconButton>
              <IconButton color="inherit" onClick={()=>setGalleryDlg(true)}>
                <span className="material-icons">grid_view</span>
              </IconButton>
            </Toolbar>
          </AppBar>

          {/* Drawer */}
          <Drawer variant="temporary" open={drawerOpen} onClose={()=>setDrawerOpen(false)} ModalProps={{keepMounted:true}}>
            {drawerContent}
          </Drawer>

          {/* Main */}
          <Box sx={{flex:1,display:'flex',flexDirection:'column',overflow:'hidden'}}>
            <Toolbar variant="dense"/>

            {/* ToolBar */}
            <Box className="tool-scroll">
              <div className="tool-group">
                <ToolBtn icon="undo" label="元に戻す" onClick={undo} disabled={!canUndo}/>
                <ToolBtn icon="redo" label="やり直す" onClick={redo} disabled={!canRedo}/>
              </div>
              <div className="tool-group">
                <ToolBtn icon="mouse" label="選択" active={tool==='select'} onClick={()=>selectTool('select')}/>
                <ToolBtn icon="brush" label="フリードロー" active={tool==='draw'} onClick={()=>selectTool('draw')}/>
              </div>
              <div className="tool-group">
                <ToolBtn icon="crop_square" label="矩形" active={tool==='rect'} onClick={()=>handleShape('rect')}/>
                <ToolBtn icon="circle"      label="楕円" active={tool==='ellipse'} onClick={()=>handleShape('ellipse')}/>
                <ToolBtn icon="arrow_forward" label="矢印" active={tool==='arrow'} onClick={()=>handleShape('arrow')}/>
              </div>
              <div className="tool-group">
                <ToolBtn icon="title" label="テキスト" onClick={()=>setTextDlg(true)}/>
                <ToolBtn icon="image" label="画像" onClick={()=>document.getElementById('fileUp').click()}/>
              </div>
              <div className="tool-group">
                <ToolBtn icon="palette" label="カラー" onClick={()=>{setColorVal(fillColor.color); setContextMenu({colorType:'fill'}); setColorDlg(true);}}/>
                <ToolBtn icon="straighten" label="サイズ" onClick={handleSize}/>
              </div>
              <div className="tool-group">
                <ToolBtn icon="camera_alt" label="カメラ" onClick={startCamera}/>
              </div>
            </Box>

            {/* Canvas + Status + Zoom */}
            <Box className="canvas-container">
              <div className="canvas-wrapper" style={{transform:`scale(${zoom})`}}>
                <canvas id="fabricCanvas"></canvas>
              </div>

              <StatusBar
                fillColor={fillColor}
                strokeColor={strokeColor}
                boardSize={{w:bcur.w,h:bcur.h}}
                onColorClick={(type,color)=>{setColorVal(color);setContextMenu({colorType:type});setColorDlg(true);}}
                onSizeClick={handleSize}
              />

              <ZoomControls zoom={zoom} onZoomChange={handleZoom}/>
            </Box>
          </Box>

          {/* Hidden file input */}
          <input id="fileUp" type="file" accept="image/*" style={{display:'none'}} onChange={e=>addImage(e.target.files[0])}/>

          {/* Context Menu (唯一) */}
          <Menu open={!!contextMenu} onClose={()=>setContextMenu(null)}
            anchorReference="anchorPosition"
            anchorPosition={contextMenu?{top:contextMenu.mouseY,left:contextMenu.mouseX}:undefined}>
            {contextMenuItems.map((it,i)=>(

              it.type==='divider'?<Divider key={i}/>:
              <MenuItem key={i} onClick={()=>{it.action();setContextMenu(null);}}>
                <ListItemIcon><span className="material-icons">{it.icon}</span></ListItemIcon>
                <ListItemText>{it.label}</ListItemText>
              </MenuItem>
            ))}
          </Menu>

          {/* 色変更ダイアログ */}
          <Dialog open={colorDlg} onClose={()=>setColorDlg(false)}>
            <DialogTitle>
              {contextMenu?.colorType === 'fill' ? '塗りの色を選択' : '線の色を選択'}
            </DialogTitle>
            <DialogContent>
              <div className="color-controls">
                <div className="color-preview-large" style={{
                  background: colorToString({color:colorVal, alpha:
                    contextMenu?.colorType === 'fill' ? fillColor.alpha : strokeColor.alpha
                  })
                }}/>
                <div className="color-input-group">
                  <div className="color-input-row">
                    <input type="color" 
                      value={colorVal} 
                      onChange={e=>setColorVal(e.target.value)}
                      style={{width:'60px',height:40}}
                    />
                    <Slider
                      className="alpha-slider"
                      value={contextMenu?.colorType === 'fill' ? fillColor.alpha : strokeColor.alpha}
                      min={0}
                      max={1}
                      step={0.01}
                      onChange={(e,val) => {
                        if (contextMenu?.colorType === 'fill') {
                          setFillColor(c => ({...c, alpha:val}));
                        } else {
                          setStrokeColor(c => ({...c, alpha:val}));
                        }
                      }}
                    />
                  </div>
                  <Typography variant="caption" align="center">
                    透明度: {Math.round((contextMenu?.colorType === 'fill' ? fillColor.alpha : strokeColor.alpha) * 100)}%
                  </Typography>
                </div>
              </div>
            </DialogContent>
            <DialogActions>
              <Button onClick={()=>setColorDlg(false)}>キャンセル</Button>
              <Button onClick={applyColor} variant="contained">OK</Button>
            </DialogActions>
          </Dialog>

          {/* テキストダイアログ */}
          <Dialog open={textDlg} onClose={()=>setTextDlg(false)} maxWidth="sm" fullWidth>
            <DialogTitle>テキスト追加</DialogTitle>
            <DialogContent>
              <Box sx={{display:'flex', flexDirection:'column', gap:2, mt:1}}>
                <TextField
                  fullWidth
                  multiline
                  rows={3}
                  label="テキスト"
                  placeholder="ここに入力してください"
                  value={textVal}
                  onChange={e=>setTextVal(e.target.value)}
                />
                <FormControl fullWidth>
                  <FormLabel>スタイル</FormLabel>
                  <Box sx={{display:'flex', gap:2, mt:1}}>
                    <TextField
                      type="number"
                      label="フォントサイズ"
                      value={textStyle.fontSize}
                      onChange={e=>setTextStyle(s=>({...s, fontSize:parseInt(e.target.value)}))}
                      InputProps={{ inputProps: { min: 8, max: 144 } }}
                    />
                    <Button
                      variant="outlined"
                      onClick={handleTextColor}
                      sx={{minWidth:120}}
                    >
                      文字色
                      <Box sx={{
                        width:20, height:20, ml:1,
                        backgroundColor:textStyle.fill,
                        border:'2px solid #fff',
                        borderRadius:1,
                        boxShadow:'0 0 0 1px rgba(0,0,0,0.1)'
                      }}/>
                    </Button>
                  </Box>
                </FormControl>
              </Box>
            </DialogContent>
            <DialogActions>
              <Button onClick={()=>setTextDlg(false)}>キャンセル</Button>
              <Button onClick={handleAddText} variant="contained" 
                disabled={!textVal.trim()}>追加</Button>
            </DialogActions>
          </Dialog>

          {/* サイズダイアログ */}
          <Dialog open={sizeDlg} onClose={()=>setSizeDlg(false)}>
            <DialogTitle>ボードサイズ変更</DialogTitle>
            <DialogContent sx={{display:'flex',gap:2,mt:1}}>
              <TextField type="number" label="幅(px)" fullWidth
                value={sizeVal.w} onChange={e=>setSizeVal(s=>({...s,w:e.target.value}))} />
              <TextField type="number" label="高さ(px)" fullWidth
                value={sizeVal.h} onChange={e=>setSizeVal(s=>({...s,h:e.target.value}))} />
            </DialogContent>
            <DialogActions>
              <Button onClick={()=>setSizeDlg(false)}>キャンセル</Button>
              <Button onClick={()=>{

                const w=parseInt(sizeVal.w,10), h=parseInt(sizeVal.h,10);
                if(w>0&&h>0){
                  // 既存のコンテンツを保持したままサイズ変更
                  const cv = fabricRef.current;
                  cv.setWidth(w).setHeight(h);
                  cv.renderAll();
                  
                  setBoards(bs=>bs.map((b,i)=>i===cur?{
                    ...b,
                    w,h,
                    json:cv.toJSON()
                  }:b));
                  saveCurrent();
                  setSizeDlg(false);
                }
              }}>適用</Button>
            </DialogActions>
          </Dialog>

          {/* カメラダイアログ */}
          <Dialog open={!!camera} onClose={() => setCamera(null)} maxWidth="sm" fullWidth>
            <DialogTitle>写真を撮影</DialogTitle>
            <DialogContent>
              <Box sx={{position: 'relative', width: '100%', paddingTop: '75%'}}>
                <video 
                  autoPlay 
                  style={{position: 'absolute', top: 0, left: 0, width: '100%', height: '100%'}}
                  ref={video => {
                    if (video && camera) video.srcObject = camera;
                  }}
                />
              </Box>
            </DialogContent>
            <DialogActions>
              <Button onClick={() => setCamera(null)}>キャンセル</Button>
              <Button onClick={takePhoto} variant="contained">撮影</Button>
            </DialogActions>
          </Dialog>

          {/* Floating Panels */}
          {panels.artboards.open && (
            <div id="artboards" className="panel" 
              style={{left:panels.artboards.x, top:panels.artboards.y}}>
              <div className="panel-header" onMouseDown={e=>startDrag(e,'artboards')}>
                <Typography variant="subtitle2">アートボード</Typography>
                <Box sx={{display:'flex',gap:1}}>
                  <IconButton size="small" onClick={addNewBoard}>
                    <span className="material-icons">add</span>
                  </IconButton>
                  <IconButton size="small" onClick={()=>setPanels(p=>({...p,artboards:{...p.artboards,open:false}}))}>
                    <span className="material-icons">close</span>
                  </IconButton>
                </Box>
              </div>
              <List dense>
                {boards.map((b,i)=>(

                  <ListItem button key={b.id} selected={i===cur}
                    onClick={()=>{saveCurrent();setCur(i);}}
                    secondaryAction={
                      <Box sx={{display:'flex',gap:0.5}}>
                        <IconButton size="small" onClick={(e)=>{e.stopPropagation();handleSize();}}>
                          <span className="material-icons">straighten</span>
                        </IconButton>
                        <IconButton size="small" onClick={(e)=>{

                          e.stopPropagation();
                          if(confirm('このアートボードを削除しますか？')) {
                            deleteBoard(b.id);
                          }
                        }}>
                          <span className="material-icons">delete</span>
                        </IconButton>
                      </Box>
                    }
                  >
                    <ListItemText 
                      primary={b.name}
                      secondary={`${b.w} × ${b.h}px`}
                      primaryTypographyProps={{variant:'body2'}}
                      secondaryTypographyProps={{variant:'caption'}}
                    />
                  </ListItem>
                ))}
              </List>
            </div>
          )}

          {panels.objects.open && (
            <div id="objects" className="panel"
              style={{left:panels.objects.x, top:panels.objects.y}}>
              <div className="panel-header" onMouseDown={e=>startDrag(e,'objects')}>
                <Typography variant="subtitle2">オブジェクト</Typography>
                <IconButton size="small" onClick={()=>setPanels(p=>({...p,objects:{...p.objects,open:false}}))}>
                  <span className="material-icons">close</span>
                </IconButton>
              </div>
              <List dense>
                {layers.slice().reverse().map(layer=>(

                  <ListItem key={layer.id}
                    button
                    selected={fabricRef.current?.getActiveObject() === layer.obj}
                    onClick={()=>{

                      fabricRef.current.setActiveObject(layer.obj);
                      fabricRef.current.requestRenderAll();
                    }}
                    secondaryAction={
                      <Box sx={{display:'flex',gap:0.5}}>
                        <div className="layer-colors">
                          {layer.obj.fill !== undefined && (
                            <div className="layer-color-item">
                              <Box sx={{display:'flex', alignItems:'center', gap:1}}>
                                <input type="color" className="layer-color"
                                  value={
                                    layer.obj.fill && typeof layer.obj.fill === 'string' && layer.obj.fill.startsWith('rgba')
                                      ? rgbaToHex(layer.obj.fill)
                                      : (layer.obj.fill || '#000000')
                                  }
                                  onChange={e => handleLayerColorChange(layer, 'fill', e.target.value)}
                                />
                                <Slider
                                  size="small"
                                  value={getAlpha(layer.obj.fill)}
                                  min={0}
                                  max={1}
                                  step={0.01}
                                  sx={{width:60}}
                                  onChange={(e,val) => {
                                    const color =
                                      layer.obj.fill && typeof layer.obj.fill === 'string' && layer.obj.fill.startsWith('rgba')
                                        ? rgbaToHex(layer.obj.fill)
                                        : (layer.obj.fill || '#000000');
                                    handleLayerColorChange(layer, 'fill', color, val);
                                  }}
                                />
                              </Box>
                              <Typography variant="caption">塗り</Typography>
                            </div>
                          )}
                          {layer.obj.stroke !== undefined && (
                            <div className="layer-color-item">
                              <input type="color" className="layer-color"
                                value={layer.obj.stroke||'#000000'}
                                onChange={e=>{
                                  layer.obj.set('stroke',e.target.value);
                                  fabricRef.current.requestRenderAll();
                                  saveCurrent();
                                }}
                              />
                              <Typography variant="caption">線</Typography>
                            </div>
                          )}
                        </div>
                        <IconButton size="small" onClick={()=>handleDelete(layer.obj)}>
                          <span className="material-icons">delete</span>
                        </IconButton>
                      </Box>
                    }
                  >
                    <ListItemIcon sx={{minWidth:36}}>
                      <span className="material-icons" style={{fontSize:20}}>
                        {layer.obj.type === 'rect' ? 'crop_square' :
                         layer.obj.type === 'ellipse' ? 'circle' :
                         layer.obj.type === 'i-text' ? 'title' :
                         layer.obj.type === 'group' ? 'arrow_forward' :
                         'radio_button_unchecked'}
                      </span>
                    </ListItemIcon>
                    <ListItemText 
                      primary={layer.name}
                      primaryTypographyProps={{variant:'body2'}}
                    />
                  </ListItem>
                ))}
              </List>
            </div>
          )}

          {/* Context Menu */}
          <Menu open={!!contextMenu} onClose={()=>setContextMenu(null)}
            anchorReference="anchorPosition"
            anchorPosition={contextMenu ? {top:contextMenu.mouseY, left:contextMenu.mouseX} : undefined}
          >
            {contextMenuItems.map((item,i) => (
              item.type === 'divider' ? <Divider key={i}/> :
              <MenuItem key={i} onClick={()=>{item.action?.();setContextMenu(null);}} disabled={item.disabled}>
                <ListItemIcon><span className="material-icons">{item.icon}</span></ListItemIcon>
                <ListItemText>{item.label}</ListItemText>
              </MenuItem>
            ))}
          </Menu>

          {/* アートボード一覧モーダル */}
          <Dialog 
            open={galleryDlg} 
            onClose={()=>setGalleryDlg(false)}
            maxWidth="lg"
            fullWidth
          >
            <DialogTitle>アートボード一覧</DialogTitle>
            <DialogContent>
              <Grid container spacing={2} sx={{mt:1}}>
                {boards.map((b,i)=>(

                  <Grid item xs={6} sm={4} md={3} lg={2} key={b.id}
                    onClick={()=>{saveCurrent();setCur(i);setGalleryDlg(false);}}
                    sx={{cursor:'pointer'}}
                  >
                    <div className="thumb-container">
                      <canvas className="thumb" ref={node=>{
                        if(!node) return;
                        node.width=b.w;
                        node.height=b.h;
                        const ctx=node.getContext('2d');
                        ctx.fillStyle='#fff';
                        ctx.fillRect(0,0,node.width,node.height);
                        if(b.json){
                          const tmp=new fabric.StaticCanvas(null,{width:b.w,height:b.h});
                          tmp.loadFromJSON(b.json,()=>{tmp.renderAll();ctx.drawImage(tmp.lowerCanvasEl,0,0);tmp.dispose();});
                        }
                      }} />
                    </div>
                    <Typography variant="caption">{b.name}</Typography>
                  </Grid>
                ))}
                <Grid item xs={6} sm={4} md={3} lg={2}>
                  <Button 
                    variant="outlined" 
                    sx={{
                      width:'100%',
                      height:'100%',
                      minHeight:200,
                      display:'flex',
                      flexDirection:'column',
                      gap:1
                    }}
                    onClick={()=>{

                      const nid = boards[boards.length-1].id+1;
                      setBoards([...boards,{
                        id:nid,
                        name:`ボード${nid}`,
                        w:800,h:600,
                        json:null,
                        history:[],
                        historyIndex:-1
                      }]);
                      setCur(boards.length);
                      setGalleryDlg(false);
                    }}
                  >
                    <span className="material-icons">add</span>
                    新規ボード
                  </Button>
                </Grid>
              </Grid>
            </DialogContent>
          </Dialog>

          {/* Excel出力設定ダイアログ */}
          <Dialog open={exportDlg} onClose={()=>setExportDlg(false)} maxWidth="sm" fullWidth>
            <DialogTitle>Excel出力設定</DialogTitle>
            <DialogContent>
              <Box sx={{display:'flex', flexDirection:'column', gap:2, mt:1}}>
                <FormControl>
                  <FormLabel>用紙サイズ</FormLabel>
                  <RadioGroup 
                    row 
                    value={exportOpts.paperSize}
                    onChange={e=>setExportOpts(o=>({...o,paperSize:e.target.value}))}
                  >
                    <FormControlLabel value="A4" control={<Radio/>} label="A4"/>
                    <FormControlLabel value="A3" control={<Radio/>} label="A3"/>
                  </RadioGroup>
                </FormControl>
                
                <FormControl>
                  <FormLabel>用紙の向き</FormLabel>
                  <RadioGroup
                    row
                    value={exportOpts.orientation}
                    onChange={e=>setExportOpts(o=>({...o,orientation:e.target.value}))}
                  >
                    <FormControlLabel value="portrait" control={<Radio/>} label="縦"/>
                    <FormControlLabel value="landscape" control={<Radio/>} label="横"/>
                  </RadioGroup>
                </FormControl>
    
                {exportOpts.preview && (
                  <Box sx={{mt:2}}>
                    <Typography variant="subtitle2" gutterBottom>プレビュー</Typography>
                    <Box sx={{
                      width:'100%',
                      maxHeight:300,
                      overflow:'auto',
                      border:'1px solid #ccc',
                      borderRadius:1
                    }}>
                      <img 
                        src={exportOpts.preview} 
                        style={{
                          width:'100%',
                          height:'auto',
                          display:'block'
                        }}
                      />
                    </Box>
                  </Box>
                )}
              </Box>
            </DialogContent>
            <DialogActions>
              <Button onClick={()=>setExportDlg(false)}>キャンセル</Button>
              <Button onClick={handleExport} variant="contained">出力</Button>
            </DialogActions>
          </Dialog>
        </Box>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App/>);
  </script>
</body>
</html>
