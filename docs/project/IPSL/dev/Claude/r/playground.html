<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <title>Finalize行: 違う行にフォーカス移動・行選択変えたときも自動Finalize</title>
    <!-- React and ReactDOM (CDN) -->
    <script src="https://cdn.jsdelivr.net/npm/react@18/umd/react.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/react-dom@18/umd/react-dom.production.min.js"></script>

    <!-- MUI (Material-UI) -->
    <script src="https://cdn.jsdelivr.net/npm/@mui/material@5.11.15/umd/material-ui.production.min.js"></script>

    <!-- Babel for JSX -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.21.0/babel.min.js"></script>

    <!-- Emotion ライブラリ -->
    <script src="https://cdn.jsdelivr.net/npm/@emotion/react@11.11.0/dist/emotion-react.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@emotion/styled@11.11.0/dist/emotion-styled.umd.min.js"></script>

    <!-- Material-UI Styles (Google Fonts & Icons) -->
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap"
    />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/icon?family=Material+Icons"
    />
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel">
      const {
        Table,
        TableBody,
        TableCell,
        TableContainer,
        TableRow,
        Paper
      } = MaterialUI;

      // 1行の表示
      function SegmentedRow({
        rowIndex,
        digitsPerRow,
        inputRefs,
        values,
        selectedRow,
        focusedCell,
        editingRow,
        onRowClick,
        onCellClick,
        handleInputChange,
        handleKeyDown
      }) {
        const handleRowClick = () => {
          onRowClick(rowIndex);
        };

        const cells = [];
        for (let colIndex = 0; colIndex < digitsPerRow; colIndex++) {
          const globalIndex = rowIndex * digitsPerRow + colIndex;
          const handleCellClickLocal = (e) => {
            e.stopPropagation();
            onCellClick(rowIndex, colIndex);
          };

          cells.push(
            <React.Fragment key={`digit-${globalIndex}`}>
              <input
                type="text"
                maxLength="1"
                ref={inputRefs[globalIndex]}
                value={values[rowIndex][colIndex]}
                style={{
                  width: "40px",
                  height: "50px",
                  fontSize: "24px",
                  textAlign: "center",
                  border: "2px solid black",
                  boxSizing: "border-box",
                  marginRight:
                    (digitsPerRow - colIndex - 1) % 3 === 0 && colIndex !== digitsPerRow - 1
                      ? "5px"
                      : "0",
                  backgroundColor:
                    focusedCell &&
                    focusedCell[0] === rowIndex &&
                    focusedCell[1] === colIndex
                      ? "#CCFFFF"
                      : "white"
                }}
                onClick={handleCellClickLocal}
                onFocus={(e) => e.target.select()}
                onChange={(e) => handleInputChange(e, rowIndex, colIndex)}
                onKeyDown={(e) => handleKeyDown(e, rowIndex, colIndex)}
              />
              {(digitsPerRow - colIndex - 1) % 3 === 0 &&
                colIndex !== digitsPerRow - 1 && (
                  <span
                    style={{ fontSize: "24px", userSelect: "none" }}
                  >
                    ,
                  </span>
                )}
            </React.Fragment>
          );
        }

        return (
          <TableRow
            onClick={handleRowClick}
            style={{
              cursor: "pointer",
              backgroundColor:
                selectedRow === rowIndex
                  ? "#FFFFCC"
                  : "transparent"
            }}
          >
            <TableCell>
              <div style={{ display: "inline-flex", alignItems: "center" }}>
                {cells}
              </div>
            </TableCell>
          </TableRow>
        );
      }

      function SegmentedInputTable() {
        const rowCount = 5;
        const digitsPerRow = 10;
        const totalCells = rowCount * digitsPerRow;

        // 入力値管理
        const [values, setValues] = React.useState(
          Array.from({ length: rowCount }, () =>
            Array.from({ length: digitsPerRow }, () => "")
          )
        );

        // 選択中の行
        const [selectedRow, setSelectedRow] = React.useState(null);
        // フォーカス中のセル
        const [focusedCell, setFocusedCell] = React.useState(null);
        // 「いま実際に編集している行」を記憶しておく
        const [editingRow, setEditingRow] = React.useState(null);

        const inputRefs = React.useRef([]);
        if (inputRefs.current.length === 0) {
          for (let i = 0; i < totalCells; i++) {
            inputRefs.current.push(React.createRef());
          }
        }

        // 行確定 (空欄を0埋め)
        const finalizeCurrentRow = (rowIndex) => {
          if (rowIndex == null) return;
          setValues((prev) => {
            return prev.map((arr, r) => {
              if (r === rowIndex) {
                return arr.map((v) => (v === "" ? "0" : v));
              }
              return arr;
            });
          });
        };

        // 行クリック: 編集行が別なら finalize してから、editingRow 更新
        const handleRowClick = (newRowIndex) => {
          if (editingRow !== null && editingRow !== newRowIndex) {
            finalizeCurrentRow(editingRow);
          }
          setSelectedRow(newRowIndex);
          setFocusedCell(null);
          setEditingRow(newRowIndex);
        };

        // セルクリック: 同様に編集行が別なら finalize → editingRow更新
        const handleCellClick = (newRowIndex, newColIndex) => {
          if (editingRow !== null && editingRow !== newRowIndex) {
            finalizeCurrentRow(editingRow);
          }
          setSelectedRow(newRowIndex);
          setFocusedCell([newRowIndex, newColIndex]);
          setEditingRow(newRowIndex);

          const globalIndex = newRowIndex * digitsPerRow + newColIndex;
          const ref = inputRefs.current[globalIndex];
          if (ref && ref.current) {
            ref.current.focus();
          }
        };

        // セル変更: 値をセット → 右端なら次セル or ...
        const handleInputChange = (e, rowIndex, colIndex) => {
          const digit = e.target.value.replace(/[^0-9]/g, "").slice(-1);
          setValues((prev) => {
            const updated = prev.map((rowArr, r) => {
              if (r !== rowIndex) return rowArr;
              return rowArr.map((val, c) => (c === colIndex ? digit : val));
            });
            return updated;
          });

          // 入力直後に次のセルへ
          if (digit !== "") {
            const globalIndex = rowIndex * digitsPerRow + colIndex;
            if (globalIndex < totalCells - 1) {
              const nextRef = inputRefs.current[globalIndex + 1];
              if (nextRef && nextRef.current) {
                nextRef.current.focus();
              }
              setFocusedCell([rowIndex, colIndex + 1]);
            }
          }
        };

        // キー操作（セル編集モード中）
        const handleKeyDown = (e, rowIndex, colIndex) => {
          if (!focusedCell) return;
          const globalIndex = rowIndex * digitsPerRow + colIndex;

          if (["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown"].includes(e.key)) {
            e.preventDefault();
            let newRow = rowIndex;
            let newCol = colIndex;

            if (e.key === "ArrowLeft") {
              if (colIndex > 0) {
                newCol = colIndex - 1;
              } else if (rowIndex > 0) {
                newRow = rowIndex - 1;
                newCol = digitsPerRow - 1;
              } else return;
            } else if (e.key === "ArrowRight") {
              if (colIndex < digitsPerRow - 1) {
                newCol = colIndex + 1;
              } else {
                // 右端でさらに右→ 次行に移る
                if (rowIndex < rowCount - 1) {
                  // 行が変わる前に finalize
                  finalizeCurrentRow(rowIndex);
                  newRow = rowIndex + 1;
                  newCol = 0;
                } else {
                  // 最終行右端なら何もしない
                  return;
                }
              }
            } else if (e.key === "ArrowUp") {
              if (rowIndex > 0) {
                // 行が変わる→ finalize
                finalizeCurrentRow(rowIndex);
                newRow = rowIndex - 1;
              } else return;
            } else if (e.key === "ArrowDown") {
              if (rowIndex < rowCount - 1) {
                finalizeCurrentRow(rowIndex);
                newRow = rowIndex + 1;
              } else return;
            }

            // もし新Row != oldRow なら editingRowも更新
            if (newRow !== rowIndex) {
              setEditingRow(newRow);
            }

            // 移動先セルへ
            const newGlobalIndex = newRow * digitsPerRow + newCol;
            if (inputRefs.current[newGlobalIndex] && inputRefs.current[newGlobalIndex].current) {
              inputRefs.current[newGlobalIndex].current.focus();
            }
            setFocusedCell([newRow, newCol]);
            setSelectedRow(newRow);
            return;
          }

          if (e.key === "Backspace") {
            if (values[rowIndex][colIndex] === "") {
              if (globalIndex > 0) {
                const prevRef = inputRefs.current[globalIndex - 1];
                if (prevRef && prevRef.current) {
                  prevRef.current.focus();
                  setFocusedCell([
                    Math.floor((globalIndex - 1) / digitsPerRow),
                    (globalIndex - 1) % digitsPerRow
                  ]);
                }
              }
            }
            return;
          }

          if (e.key === "Enter") {
            e.preventDefault();
            finalizeCurrentRow(rowIndex);
            if (rowIndex < rowCount - 1) {
              // 次行に移動
              const nextGlobalIndex = (rowIndex + 1) * digitsPerRow;
              const ref = inputRefs.current[nextGlobalIndex];
              if (ref && ref.current) {
                ref.current.focus();
              }
              setFocusedCell([rowIndex + 1, 0]);
              setSelectedRow(rowIndex + 1);
              setEditingRow(rowIndex + 1);
            } else {
              // 最終行
              setFocusedCell(null);
            }
            return;
          }
        };

        // 「行モード」(セル未フォーカス)時の右詰め入力
        // かつ editingRow が変更されたら finalize
        React.useEffect(() => {
          function handleGlobalKeyDown(e) {
            // セルフォーカスがある場合はスルー
            if (focusedCell !== null) return;
            // 行未選択ならスルー
            if (selectedRow === null) return;

            // 0-9 → 右詰め
            if (/^[0-9]$/.test(e.key)) {
              e.preventDefault();

              // editingRow が選択された行と異なるなら finalize
              if (editingRow !== selectedRow) {
                if (editingRow !== null) {
                  finalizeCurrentRow(editingRow);
                }
                setEditingRow(selectedRow);
              }

              const digit = e.key;
              setValues((prev) => {
                const updated = [...prev];
                const rowArray = [...updated[selectedRow]];
                for (let c = digitsPerRow - 1; c >= 0; c--) {
                  if (rowArray[c] === "") {
                    rowArray[c] = digit;
                    break;
                  }
                }
                updated[selectedRow] = rowArray;
                return updated;
              });
            }

            // Backspace → 末尾削除
            if (e.key === "Backspace") {
              e.preventDefault();
              if (editingRow !== selectedRow) {
                if (editingRow !== null) finalizeCurrentRow(editingRow);
                setEditingRow(selectedRow);
              }
              setValues((prev) => {
                const updated = [...prev];
                const rowArray = [...updated[selectedRow]];
                for (let c = digitsPerRow - 1; c >= 0; c--) {
                  if (rowArray[c] !== "") {
                    rowArray[c] = "";
                    break;
                  }
                }
                updated[selectedRow] = rowArray;
                return updated;
              });
            }

            // Enter → finalize & 次行
            if (e.key === "Enter") {
              e.preventDefault();
              finalizeCurrentRow(selectedRow);
              if (selectedRow < rowCount - 1) {
                setSelectedRow(selectedRow + 1);
                setEditingRow(selectedRow + 1);
              } else {
                setSelectedRow(null);
                setEditingRow(null);
              }
            }
          }

          window.addEventListener("keydown", handleGlobalKeyDown);
          return () => {
            window.removeEventListener("keydown", handleGlobalKeyDown);
          };
        }, [selectedRow, editingRow, focusedCell, digitsPerRow, rowCount]);

        // テーブル行を組み立て
        const rows = [];
        for (let row = 0; row < rowCount; row++) {
          rows.push(
            <SegmentedRow
              key={"row-" + row}
              rowIndex={row}
              digitsPerRow={digitsPerRow}
              inputRefs={inputRefs.current}
              values={values}
              selectedRow={selectedRow}
              focusedCell={focusedCell}
              editingRow={editingRow}
              onRowClick={handleRowClick}
              onCellClick={handleCellClick}
              handleInputChange={handleInputChange}
              handleKeyDown={handleKeyDown}
            />
          );
        }

        return (
          <TableContainer component={Paper} style={{ maxWidth: 800, margin: "30px auto" }}>
            <Table>
              <TableBody>{rows}</TableBody>
            </Table>
          </TableContainer>
        );
      }

      ReactDOM.render(<SegmentedInputTable />, document.getElementById('root'));
    </script>
  </body>
</html>