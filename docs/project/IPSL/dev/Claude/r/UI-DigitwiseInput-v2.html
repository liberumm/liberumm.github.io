<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <title>Digit Table (React 19 + MUI 7 + ESM + Babel)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- Roboto -->
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap"
    />

    <!-- Material Icons -->
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/icon?family=Material+Icons"
    />

    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        height: 100%;
      }
      body {
        font-family: "Roboto", "Helvetica", "Arial", sans-serif;
      }
      #root {
        height: 100vh;
        width: 100vw;
      }
      .code-input textarea {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace !important;
        font-size: 12px !important;
        line-height: 1.5 !important;
        white-space: pre;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <!-- Babel Standalone（JSX -> JS 変換） -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- React / MUI を ESM import して Babel 変換コードに渡す -->
    <script type="module">
      import React from "https://esm.sh/react@19.2.0";
      import { createRoot } from "https://esm.sh/react-dom@19.2.0/client";
      import * as MaterialUI from "https://esm.sh/@mui/material@7.3.5?deps=react@19.2.0,react-dom@19.2.0";

      const appCode = `
        const {
          Table,
          TableBody,
          TableCell,
          TableContainer,
          TableRow,
          Paper,
          TextField,
          Typography,
          Button
        } = MaterialUI;

        // 全角数字 → 半角数字
        function toHalfWidth(str) {
          return str.replace(/[\\uFF10-\\uFF19]/g, function(c) {
            return String.fromCharCode(c.charCodeAt(0) - 0xFEE0);
          });
        }

        // ["", "1", "2"] → 整数 (空欄は0とみなす)
        function rowDigitsToNumber(digitArray) {
          const numStr = digitArray.join("").trim();
          return numStr === "" ? 0 : parseInt(numStr, 10);
        }

        // 整数 → 右詰めセル配列
        function numberToRowDigits(num, digitsPerRow) {
          if (!Number.isFinite(num)) num = 0;
          let s = String(num);
          if (s.length > digitsPerRow) {
            s = s.slice(-digitsPerRow);
          }
          const result = Array(digitsPerRow).fill("");
          for (let i = 0; i < s.length; i++) {
            result[digitsPerRow - s.length + i] = s[i];
          }
          return result;
        }

        // 各行表示コンポーネント
        function SegmentedRow(props) {
          const {
            rowIndex,
            digitsPerRow,
            overflowDigits,
            inputRefs,
            values,
            selectedRow,
            focusedCell,
            editingRow,
            onRowClick,
            onCellClick,
            onRowReset,
            handleInputChange,
            handleKeyDown
          } = props;

          const handleRowClick = function() {
            onRowClick(rowIndex);
          };

          // No.列
          const noCell = (
            <TableCell
              onClick={function(e) {
                e.stopPropagation();
                handleRowClick();
              }}
              style={{
                cursor: "pointer",
                backgroundColor: selectedRow === rowIndex ? "#FFFFCC" : "transparent",
                width: "60px",
                textAlign: "center",
                fontWeight: "bold"
              }}
            >
              {rowIndex + 1}
            </TableCell>
          );

          // 行リセットボタン列
          const resetButtonCell = (
            <TableCell
              onClick={function(e) { e.stopPropagation(); }}
              style={{
                width: "100px",
                backgroundColor: selectedRow === rowIndex ? "#FFFFCC" : "transparent"
              }}
            >
              <Button variant="outlined" size="small" onClick={function() { onRowReset(rowIndex); }}>
                行リセット
              </Button>
            </TableCell>
          );

          // データセル群
          const dataCells = [];
          for (let colIndex = 0; colIndex < digitsPerRow; colIndex++) {
            const globalIndex = rowIndex * digitsPerRow + colIndex;
            const handleCellClickLocal = function(e) {
              e.stopPropagation();
              onCellClick(rowIndex, colIndex);
            };

            const isFocused =
              focusedCell &&
              focusedCell.row === rowIndex &&
              focusedCell.col === colIndex;

            dataCells.push(
              <React.Fragment key={"digit-" + globalIndex}>
                <input
                  type="text"
                  inputMode="numeric"
                  pattern="[0-9]*"
                  maxLength="1"
                  ref={inputRefs[globalIndex]}
                  value={values[rowIndex][colIndex]}
                  style={{
                    width: "40px",
                    height: "50px",
                    fontSize: "24px",
                    textAlign: "center",
                    border: "2px solid black",
                    boxSizing: "border-box",
                    marginRight:
                      (digitsPerRow - colIndex - 1) % 3 === 0 && colIndex !== digitsPerRow - 1
                        ? "5px"
                        : "0",
                    backgroundColor: isFocused ? "#CCFFFF" : "white"
                  }}
                  onClick={handleCellClickLocal}
                  onFocus={function(e) { e.target.select(); }}
                  onChange={function(e) { handleInputChange(e, rowIndex, colIndex); }}
                  onKeyDown={function(e) { handleKeyDown(e, rowIndex, colIndex); }}
                />
                {(digitsPerRow - colIndex - 1) % 3 === 0 &&
                  colIndex !== digitsPerRow - 1 && (
                    <span style={{ fontSize: "24px", userSelect: "none" }}>,</span>
                  )}
              </React.Fragment>
            );
          }

          return (
            <TableRow
              onClick={handleRowClick}
              style={{
                cursor: "pointer",
                backgroundColor: selectedRow === rowIndex ? "#FFFFCC" : "transparent"
              }}
            >
              {noCell}
              {resetButtonCell}
              <TableCell style={{ backgroundColor: "transparent" }}>
                <div style={{ display: "inline-flex", alignItems: "center" }}>
                  {/* 桁溢れ列用の非活性セル */}
                  {Array(overflowDigits).fill(0).map(function(_, idx) {
                    return (
                      <React.Fragment key={"overflow-" + idx}>
                        <Typography
                          variant="h6"
                          style={{
                            width: "40px",
                            height: "50px",
                            lineHeight: "50px",
                            textAlign: "center",
                            border: "2px solid #999",
                            boxSizing: "border-box",
                            marginRight: "5px",
                            backgroundColor: "#f5f5f5",
                            color: "#666"
                          }}
                        >
                          0
                        </Typography>
                        {((overflowDigits - idx) % 3 === 0) && (idx < overflowDigits - 1) && (
                          <Typography
                            variant="h6"
                            style={{
                              fontSize: "24px",
                              userSelect: "none",
                              lineHeight: "50px"
                            }}
                          >
                            ,
                          </Typography>
                        )}
                      </React.Fragment>
                    );
                  })}
                  {dataCells}
                </div>
              </TableCell>
            </TableRow>
          );
        }

        // メインコンポーネント
        function FullFeaturedTable() {
          const [rowCount, setRowCount] = React.useState(5);
          const [digitsPerRow, setDigitsPerRow] = React.useState(10);
          const [overflowDigits, setOverflowDigits] = React.useState(0);

          const [values, setValues] = React.useState(
            Array.from({ length: rowCount }, function() {
              return Array.from({ length: digitsPerRow }, function() { return ""; });
            })
          );

          const [selectedRow, setSelectedRow] = React.useState(null);
          const [focusedCell, setFocusedCell] = React.useState(null);
          const [editingRow, setEditingRow] = React.useState(null);

          const totalCells = rowCount * digitsPerRow;
          const inputRefs = React.useRef([]);

          React.useEffect(function() {
            const newRefs = Array.from({ length: totalCells }, function() { return React.createRef(); });
            if (inputRefs.current) {
              const minLength = Math.min(inputRefs.current.length, newRefs.length);
              for (let i = 0; i < minLength; i++) {
                if (inputRefs.current[i] && inputRefs.current[i].current) {
                  newRefs[i] = inputRefs.current[i];
                }
              }
            }
            inputRefs.current = newRefs;
          }, [totalCells]);

          const [pendingFocus, setPendingFocus] = React.useState(null);
          React.useEffect(function() {
            if (!pendingFocus) return;
            const r = pendingFocus[0];
            const c = pendingFocus[1];
            const index = r * digitsPerRow + c;
            const ref = inputRefs.current[index];
            if (ref && ref.current) {
              ref.current.focus();
            }
            setPendingFocus(null);
          }, [pendingFocus, digitsPerRow]);

          // 行・列数変更時に values を同期
          React.useEffect(function() {
            setSelectedRow(null);
            setFocusedCell(null);
            setEditingRow(null);
            setPendingFocus(null);

            setValues(function(prev) {
              const newVals = Array(rowCount).fill(0).map(function(_, r) {
                if (r < prev.length) {
                  const row = prev[r].slice();
                  if (row.length > digitsPerRow) {
                    return row.slice(-digitsPerRow);
                  }
                  if (row.length < digitsPerRow) {
                    return row.concat(Array(digitsPerRow - row.length).fill(""));
                  }
                  return row;
                }
                return Array(digitsPerRow).fill("");
              });
              return newVals;
            });
          }, [rowCount, digitsPerRow]);

          // 行確定処理
          const finalizeCurrentRow = function(rowIndex) {
            if (rowIndex == null || rowIndex < 0 || rowIndex >= rowCount) return;

            const isLastRow = rowIndex === rowCount - 1;

            setValues(function(prev) {
              const newVals = prev.slice();
              newVals[rowIndex] = newVals[rowIndex].map(function(v) { return v === "" ? "0" : v; });
              if (isLastRow) {
                newVals.push(Array(digitsPerRow).fill(""));
              }
              return newVals;
            });

            if (isLastRow) {
              setRowCount(function(prev) { return prev + 1; });

              const newRowIndex = rowIndex + 1;

              setTimeout(function() {
                setSelectedRow(newRowIndex);
                setEditingRow(newRowIndex);

                if (focusedCell !== null) {
                  setFocusedCell({ row: newRowIndex, col: 0 });
                  setPendingFocus([newRowIndex, 0]);
                } else {
                  setFocusedCell(null);
                  setPendingFocus(null);
                }
              }, 0);
            }
          };

          // フォーカス更新処理
          const updateFocusState = function(row, col, shouldFinalize, currentRow) {
            if (shouldFinalize === void 0) shouldFinalize = false;
            if (currentRow === void 0) currentRow = null;

            const updateStates = function() {
              setSelectedRow(row);
              setEditingRow(row);
              setFocusedCell({ row: row, col: col });

              setTimeout(function() {
                setPendingFocus([row, col]);
              }, 0);
            };

            if (shouldFinalize && currentRow !== null) {
              finalizeCurrentRow(currentRow);
              setTimeout(updateStates, 0);
            } else {
              updateStates();
            }
          };

          // セルクリック
          const handleCellClick = function(r, c) {
            if (editingRow !== null && editingRow !== r) {
              finalizeCurrentRow(editingRow);
            }
            updateFocusState(r, c, false);
          };

          // セル入力
          const handleInputChange = function(e, r, c) {
            const half = toHalfWidth(e.target.value);
            const digit = half.replace(/[^0-9]/g, "").slice(-1) || "";
            setValues(function(prev) {
              const newVals = prev.slice();
              newVals[r] = newVals[r].slice();
              newVals[r][c] = digit;
              return newVals;
            });
            if (digit !== "") {
              if (c < digitsPerRow - 1) {
                updateFocusState(r, c + 1, false, r);
              } else {
                const isLastRow = r === rowCount - 1;
                if (isLastRow) {
                  handleLastRow(r);
                } else {
                  finalizeCurrentRow(r);
                }
              }
            }
          };

          // 行リセット
          const handleRowReset = function(rowIndex) {
            setValues(function(prev) {
              const newVals = prev.slice();
              newVals[rowIndex] = Array(digitsPerRow).fill("");
              return newVals;
            });
          };

          // 行クリック
          const handleRowClick = function(rowIndex) {
            if (editingRow !== null && editingRow !== rowIndex) {
              finalizeCurrentRow(editingRow);
            }
            setSelectedRow(rowIndex);
            setFocusedCell(null);
            setEditingRow(rowIndex);
          };

          // セルキー操作
          const handleKeyDown = function(e, r, c) {
            if (!focusedCell) return;

            const half = toHalfWidth(e.key);
            if (/^[0-9]$/.test(half)) {
              e.preventDefault();
              setValues(function(prev) {
                const newVals = prev.slice();
                newVals[r] = newVals[r].slice();
                newVals[r][c] = half;
                return newVals;
              });
              if (c < digitsPerRow - 1) {
                updateFocusState(r, c + 1, false, r);
              } else {
                finalizeCurrentRow(r);
              }
              return;
            }

            if (["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown"].includes(e.key)) {
              e.preventDefault();
              let newR = r;
              let newC = c;
              if (e.key === "ArrowLeft") {
                if (c > 0) newC--;
              } else if (e.key === "ArrowRight") {
                if (c < digitsPerRow - 1) {
                  newC++;
                } else if (r < rowCount - 1) {
                  newR++;
                  newC = 0;
                }
              } else if (e.key === "ArrowUp") {
                if (r > 0) newR--;
              } else if (e.key === "ArrowDown") {
                if (r < rowCount - 1) {
                  newR++;
                } else {
                  finalizeCurrentRow(r);
                  setTimeout(function() {
                    updateFocusState(r + 1, 0, false);
                    setPendingFocus([r + 1, 0]);
                  }, 0);
                  return;
                }
              }
              updateFocusState(newR, newC, newR !== r, r);
              return;
            }

            if (e.key === "Backspace") {
              if (values[r][c] === "") {
                if (c > 0) {
                  updateFocusState(r, c - 1, false, r);
                }
              }
              return;
            }

            if (e.key === "Enter") {
              e.preventDefault();
              const isLastRow = r === rowCount - 1;
              finalizeCurrentRow(r);
              requestAnimationFrame(function() {
                const nextR = isLastRow ? rowCount : r + 1;
                updateFocusState(nextR, 0, false);
              });
            }
          };

          // 最終行処理
          const handleLastRow = function(currentRow) {
            setValues(function(prev) {
              const newVals = prev.slice();
              newVals[currentRow] = newVals[currentRow].map(function(v) { return v === "" ? "0" : v; });
              newVals.push(Array(digitsPerRow).fill(""));
              return newVals;
            });

            setRowCount(function(prev) { return prev + 1; });

            const newRowIndex = currentRow + 1;

            setTimeout(function() {
              setSelectedRow(newRowIndex);
              setEditingRow(newRowIndex);
              setFocusedCell({ row: newRowIndex, col: 0 });
              setPendingFocus([newRowIndex, 0]);
            }, 0);
          };

          // 行モードグローバルキー
          React.useEffect(function() {
            function handleGlobalKeyDown(e) {
              if (focusedCell !== null) return;
              if (selectedRow === null) return;

              if (e.key === "ArrowUp" || e.key === "ArrowDown") {
                e.preventDefault();

                if (e.key === "ArrowUp" && selectedRow > 0) {
                  const newRow = selectedRow - 1;
                  finalizeCurrentRow(selectedRow);
                  setSelectedRow(newRow);
                  setEditingRow(newRow);
                } else if (e.key === "ArrowDown") {
                  if (selectedRow < rowCount - 1) {
                    const newRow = selectedRow + 1;
                    finalizeCurrentRow(selectedRow);
                    setSelectedRow(newRow);
                    setEditingRow(newRow);
                  } else if (selectedRow === rowCount - 1) {
                    handleLastRow(selectedRow);
                  }
                }
                return;
              }

              const half = toHalfWidth(e.key);
              if (/^[0-9]$/.test(half)) {
                e.preventDefault();
                setValues(function(prev) {
                  const newVals = prev.slice();
                  let rowNum = rowDigitsToNumber(newVals[selectedRow]);
                  const newNum = rowNum * 10 + parseInt(half, 10);
                  newVals[selectedRow] = numberToRowDigits(newNum, digitsPerRow);

                  if (selectedRow === rowCount - 1 && String(newNum).length === digitsPerRow) {
                    newVals.push(Array(digitsPerRow).fill(""));
                    setTimeout(function() {
                      setRowCount(function(prev) { return prev + 1; });
                      setSelectedRow(selectedRow + 1);
                      setEditingRow(selectedRow + 1);
                    }, 0);
                  }
                  return newVals;
                });
                return;
              }

              if (e.key === "Backspace") {
                e.preventDefault();
                if (editingRow !== selectedRow) {
                  if (editingRow !== null) {
                    finalizeCurrentRow(editingRow);
                  }
                  setEditingRow(selectedRow);
                }
                setValues(function(prev) {
                  const newVals = prev.slice();
                  const rowNum = rowDigitsToNumber(newVals[selectedRow]);
                  const newNum = Math.floor(rowNum / 10);
                  newVals[selectedRow] = numberToRowDigits(newNum, digitsPerRow);
                  return newVals;
                });
                return;
              }

              if (e.key === "Enter") {
                e.preventDefault();
                finalizeCurrentRow(selectedRow);
                if (selectedRow < rowCount - 1) {
                  setSelectedRow(selectedRow + 1);
                  setEditingRow(selectedRow + 1);
                } else {
                  setSelectedRow(null);
                  setEditingRow(null);
                }
              }
            }

            window.addEventListener("keydown", handleGlobalKeyDown);
            return function() {
              window.removeEventListener("keydown", handleGlobalKeyDown);
            };
          }, [selectedRow, editingRow, focusedCell, rowCount, digitsPerRow, values]);

          // 合計行計算
          const calculateTotalsAndOverflow = function() {
            const totals = Array.from({ length: digitsPerRow }, function() { return 0; });

            values.forEach(function(row) {
              row.forEach(function(val, colIndex) {
                const num = parseInt(val, 10);
                if (!isNaN(num)) {
                  totals[colIndex] += num;
                }
              });
            });

            const overflowArray = [];
            for (let i = totals.length - 1; i >= 0; i--) {
              if (totals[i] >= 10) {
                const carry = Math.floor(totals[i] / 10);
                totals[i] = totals[i] % 10;
                if (i > 0) {
                  totals[i - 1] += carry;
                } else {
                  let remaining = carry;
                  while (remaining > 0) {
                    overflowArray.unshift(remaining % 10);
                    remaining = Math.floor(remaining / 10);
                  }
                }
              }
            }

            const newOverflowDigits = overflowArray.length;
            if (newOverflowDigits !== overflowDigits) {
              setOverflowDigits(newOverflowDigits);
            }

            return { totals: totals, overflowArray: overflowArray };
          };

          const calcResult = calculateTotalsAndOverflow();
          const totals = calcResult.totals;
          const overflowArray = calcResult.overflowArray;

          // 合計行
          const totalRow = (
            <TableRow style={{ backgroundColor: "#EEEEEE" }}>
              <TableCell
                style={{
                  width: "60px",
                  textAlign: "center",
                  fontWeight: "bold"
                }}
              >
                合計
              </TableCell>
              <TableCell style={{ width: "100px" }}></TableCell>
              <TableCell>
                <div style={{ display: "inline-flex", alignItems: "center" }}>
                  {overflowArray.map(function(digit, idx) {
                    return (
                      <React.Fragment key={"overflow-" + idx}>
                        <Typography
                          variant="h6"
                          style={{
                            width: "40px",
                            height: "50px",
                            lineHeight: "50px",
                            textAlign: "center",
                            border: "2px solid #999",
                            boxSizing: "border-box",
                            marginRight: "5px",
                            backgroundColor: "#f5f5f5",
                            color: "#666"
                          }}
                        >
                          {digit}
                        </Typography>
                        {((overflowArray.length - idx) % 3 === 0) &&
                          idx < overflowArray.length - 1 && (
                            <Typography
                              variant="h6"
                              style={{
                                fontSize: "24px",
                                userSelect: "none",
                                lineHeight: "50px"
                              }}
                            >
                              ,
                            </Typography>
                          )}
                      </React.Fragment>
                    );
                  })}
                  {totals.map(function(total, idx) {
                    return (
                      <React.Fragment key={"total-" + idx}>
                        <Typography
                          variant="h6"
                          style={{
                            width: "40px",
                            height: "50px",
                            lineHeight: "50px",
                            textAlign: "center",
                            border: "2px solid black",
                            boxSizing: "border-box",
                            marginRight:
                              (digitsPerRow - idx - 1) % 3 === 0 &&
                              idx !== digitsPerRow - 1
                                ? "5px"
                                : "0"
                          }}
                        >
                          {total}
                        </Typography>
                        {((digitsPerRow - idx - 1) % 3 === 0) &&
                          idx < digitsPerRow - 1 && (
                            <Typography
                              variant="h6"
                              style={{
                                fontSize: "24px",
                                userSelect: "none",
                                lineHeight: "50px"
                              }}
                            >
                              ,
                            </Typography>
                          )}
                      </React.Fragment>
                    );
                  })}
                </div>
              </TableCell>
            </TableRow>
          );

          // 行コンポーネント
          const rowComponents = [];
          for (let row = 0; row < rowCount; row++) {
            rowComponents.push(
              <SegmentedRow
                key={row}
                rowIndex={row}
                digitsPerRow={digitsPerRow}
                overflowDigits={overflowDigits}
                inputRefs={inputRefs.current}
                values={values}
                selectedRow={selectedRow}
                focusedCell={focusedCell}
                editingRow={editingRow}
                onRowClick={handleRowClick}
                onCellClick={handleCellClick}
                onRowReset={handleRowReset}
                handleInputChange={handleInputChange}
                handleKeyDown={handleKeyDown}
              />
            );
          }

          // 行数変更
          const handleRowCountChange = function(num) {
            if (isNaN(num) || num < 0) return;

            if (editingRow != null) {
              finalizeCurrentRow(editingRow);
            }

            const diff = num - rowCount;

            if (diff > 0) {
              setValues(function(prev) {
                const newVals = prev.slice();
                for (let i = 0; i < diff; i++) {
                  newVals.push(Array(digitsPerRow).fill(""));
                }
                return newVals;
              });
              setRowCount(num);
            } else if (diff < 0) {
              setValues(function(prev) { return prev.slice(0, num); });
              setRowCount(num);
              if (selectedRow >= num) {
                setSelectedRow(null);
                setEditingRow(null);
                setFocusedCell(null);
              }
            }
          };

          return (
            <div>
              <div style={{ display: "flex", gap: "20px", justifyContent: "center", marginTop: "20px" }}>
                <TextField
                  label="行数"
                  type="number"
                  variant="outlined"
                  size="small"
                  value={rowCount}
                  inputProps={{ min: 0 }}
                  onChange={function(e) {
                    const val = parseInt(e.target.value, 10);
                    handleRowCountChange(val);
                  }}
                  style={{ width: "80px" }}
                />
                <TextField
                  label="列数"
                  type="number"
                  variant="outlined"
                  size="small"
                  value={digitsPerRow}
                  onChange={function(e) {
                    const val = parseInt(e.target.value, 10);
                    if (!isNaN(val) && val > 0) {
                      setDigitsPerRow(val);
                    }
                  }}
                  style={{ width: "80px" }}
                />
                <Button
                  variant="contained"
                  color="error"
                  onClick={function() {
                    setValues(
                      Array.from({ length: rowCount }, function() {
                        return Array.from({ length: digitsPerRow }, function() { return ""; });
                      })
                    );
                    setSelectedRow(null);
                    setFocusedCell(null);
                    setEditingRow(null);
                  }}
                >
                  全初期化
                </Button>
              </div>

              <TableContainer component={Paper} style={{ maxWidth: 900, margin: "30px auto" }}>
                <Table>
                  <TableBody>
                    {totalRow}
                    {rowComponents}
                  </TableBody>
                </Table>
              </TableContainer>
            </div>
          );
        }

        const rootElement = document.getElementById("root");
        const root = createRoot(rootElement);

        root.render(<FullFeaturedTable />);
      `;

      const { code } = Babel.transform(appCode, {
        presets: ["react"],
      });

      const runApp = new Function(
        "React",
        "createRoot",
        "MaterialUI",
        code
      );

      runApp(React, createRoot, MaterialUI);
    </script>
  </body>
</html>
