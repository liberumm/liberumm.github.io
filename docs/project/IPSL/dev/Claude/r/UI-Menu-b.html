<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>MR & AI Chat – Resizable Drawer (Fit)</title>

  <!-- Fonts & MUI -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap"/>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap"/>
  <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
  <script src="https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.production.min.js" crossorigin></script>
  <script src="https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://cdn.jsdelivr.net/npm/@babel/standalone@7.23.8/babel.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@emotion/react@11.11.3/dist/emotion-react.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@emotion/styled@11.11.0/dist/emotion-styled.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mui/material@5.15.3/umd/material-ui.production.min.js" crossorigin></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper@11/swiper-bundle.min.css" />
  <script src="https://cdn.jsdelivr.net/npm/swiper@11/swiper-bundle.min.js"></script>

  <style>
    html, body {
      margin: 0; padding: 0; height: 100%;
      font-family: Roboto, system-ui, -apple-system, "Segoe UI", Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: linear-gradient(180deg, #eef1f7 0%, #f6f7fb 100%);
    }
    
    #root {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      position: relative;
    }
    
    .glass {
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      background: rgba(255,255,255,0.7);
      border: 1px solid rgba(255,255,255,0.6);
      box-shadow: 0 10px 30px rgba(76,87,125,.08);
      border-radius: 16px;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .glass:hover {
      box-shadow: 0 15px 40px rgba(76,87,125,.12);
      transform: translateY(-2px);
    }
    
    .bubble {
      display: inline-block;
      padding: 16px 20px;
      border-radius: 24px;
      max-width: min(85%, 680px);
      line-height: 1.6;
      margin-bottom: 12px;
      white-space: pre-wrap;
      word-wrap: break-word;
      position: relative;
      animation: slideIn 0.3s ease-out;
    }
    
    @keyframes slideIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    .bubble.user {
      background: #e8f0ff;
      border: 1px solid rgba(63,81,181,.25);
      color: #283593;
      align-self: flex-end;
      box-shadow: 0 4px 15px rgba(63,81,181,.15);
    }
    
    .bubble.agent {
      background: #fff;
      border: 1px solid rgba(0,0,0,.06);
      color: #333;
      align-self: flex-start;
      box-shadow: 0 4px 15px rgba(0,0,0,.08);
    }
    
    .typing {
      display: inline-flex;
      gap: 6px;
      align-items: center;
      padding: 8px;
    }
    
    .typing span {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: #9aa7c7;
      animation: blink 1.2s infinite ease-in-out;
    }
    
    .typing span:nth-child(2) { animation-delay: 0.2s; }
    .typing span:nth-child(3) { animation-delay: 0.4s; }
    
    @keyframes blink {
      0%, 80%, 100% { opacity: 0.2; }
      40% { opacity: 1; }
    }
    
    .mr-overlay {
      position: absolute;
      top: 12px;
      left: 12px;
      background: rgba(255,255,0,.85);
      padding: 6px 10px;
      border-radius: 6px;
      font-size: .9rem;
      pointer-events: none;
      z-index: 10;
    }
    
    .mr-agent {
      position: absolute;
      bottom: 12px;
      right: 12px;
      background: rgba(255,255,255,.75);
      padding: 8px 12px;
      border-radius: 12px;
      font-weight: bold;
      color: #444;
      pointer-events: none;
      z-index: 10;
    }
    
    .chat-drawer-body {
      display: flex;
      flex-direction: column;
      height: 100%;
      background: transparent;
    }
    
    .menu-icon {
      border-radius: 16px;
      width: 60px;
      height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      margin: 0 auto;
      transition: transform .25s ease, box-shadow .25s ease, filter .25s ease, opacity .2s ease;
      box-shadow: 0 8px 22px rgba(50,50,93,.12), 0 4px 12px rgba(0,0,0,.08);
      position: relative;
      overflow: hidden;
    }
    
    .menu-icon::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
      transition: left 0.5s;
    }
    
    .menu-icon:hover {
      transform: translateY(-3px) scale(1.02);
      filter: brightness(1.03);
    }
    
    .menu-icon:hover::before {
      left: 100%;
    }
    
    .menu-label {
      font-size: .85rem;
      margin-top: 8px;
      text-align: center;
      color: #556;
      font-weight: 500;
    }
    
    .menu-item.editing .menu-icon {
      outline: 2px dashed rgba(40,53,147,.45);
      outline-offset: 4px;
      cursor: grab;
    }
    
    .menu-item.dragging .menu-icon {
      opacity: 0.7;
      cursor: grabbing;
      transform: rotate(5deg) scale(1.1);
    }
    
    .drop-hint {
      border: 2px dashed rgba(0,0,0,.15);
      border-radius: 12px;
      height: 68px;
    }
    
    @media (max-width: 600px) {
      .menu-icon {
        width: 48px;
        height: 48px;
        border-radius: 12px;
      }
      .menu-icon .material-icons {
        font-size: 22px;
      }
      .menu-label {
        font-size: .72rem;
        margin-top: 4px;
      }
      .drop-hint {
        height: 56px;
      }
    }
    
    .resize-handle {
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: ns-resize;
      user-select: none;
      border-top: 1px dashed rgba(0,0,0,0.12);
      background: linear-gradient(180deg, rgba(255,255,255,.6), rgba(255,255,255,.8));
    }
    
    .resize-handle .material-icons {
      font-size: 18px;
      opacity: .6;
    }
    
    .inner-resize-handle {
      height: 12px;
      cursor: ns-resize;
      display: flex;
      align-items: center;
      justify-content: center;
      background: linear-gradient(180deg, rgba(0,0,0,.02), rgba(0,0,0,.04));
      border-top: 1px dashed rgba(0,0,0,.08);
      border-bottom: 1px dashed rgba(0,0,0,.06);
      user-select: none;
    }
    
    .inner-resize-handle .material-icons {
      font-size: 18px;
      opacity: .5;
    }
    
    /* スクロールバーのスタイリング */
    ::-webkit-scrollbar {
      width: 8px;
    }
    
    ::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.05);
      border-radius: 4px;
    }
    
    ::-webkit-scrollbar-thumb {
      background: rgba(0, 0, 0, 0.2);
      border-radius: 4px;
    }
    
    ::-webkit-scrollbar-thumb:hover {
      background: rgba(0, 0, 0, 0.3);
    }
    
    .swiper {
      width: 100%;
      height: 100%;
    }
    
    .swiper-slide {
      width: 300px;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .swiper-button-next,
    .swiper-button-prev {
      color: rgba(255,255,255,0.8);
      background: rgba(0,0,0,0.3);
      border-radius: 50%;
      width: 48px;
      height: 48px;
    }
    
    .swiper-button-next:after,
    .swiper-button-prev:after {
      font-size: 20px;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const {
      AppBar, Toolbar, Typography, Box, Grid, Paper, IconButton,
      TextField, Button, Switch, FormControlLabel, Container,
      CssBaseline, ThemeProvider, createTheme, Divider, Chip, SwipeableDrawer,
      Tooltip, Avatar, Stack, Alert, useMediaQuery, ButtonGroup, InputAdornment, Snackbar
    } = MaterialUI;

    // ====== 定数 ======
    const DEFAULT_MENU = [
      { key:"home", icon:"home", label:"ホーム", color:"#f44336" },
      { key:"person", icon:"person", label:"プロフィール", color:"#e91e63" },
      { key:"mail", icon:"mail", label:"メッセージ", color:"#9c27b0" },
      { key:"settings", icon:"settings", label:"設定", color:"#673ab7" },
      { key:"camera", icon:"photo_camera", label:"カメラ", color:"#3f51b5" },
      { key:"map", icon:"map", label:"マップ", color:"#2196f3" },
      { key:"event", icon:"event", label:"カレンダー", color:"#03a9f4" },
      { key:"shop", icon:"shopping_cart", label:"ショップ", color:"#00bcd4" },
      { key:"help", icon:"help", label:"ヘルプ", color:"#009688" },
      { key:"info", icon:"info", label:"情報", color:"#4caf50" },
      { key:"phone", icon:"phone", label:"連絡先", color:"#ff9800" },
      { key:"music", icon:"music_note", label:"音楽", color:"#795548" },
    ];
    const LS_KEY = "menuLayoutV1";

    const theme = createTheme({
      palette: { mode:'light', primary:{ main:'#283593' }, secondary:{ main:'#00bcd4' },
        background:{ default:'transparent', paper:'rgba(255,255,255,0.7)'} },
      shape:{ borderRadius:14 },
      typography:{ button:{ textTransform:'none', fontWeight:600 } }
    });

    // ====== Chat 状態 ======
    const ChatContext = React.createContext(null);
    const useChat = () => React.useContext(ChatContext);

    function ChatProvider({ children }) {
      const videoRef = React.useRef(null);
      const inputRef = React.useRef(null);
      const [messages, setMessages] = React.useState([
        { role:"agent", type:"text", text:"こんにちは、AIエージェントです。ご用件は何でしょうか？" },
      ]);
      const [input, setInput] = React.useState("");
      const [inputMode, setInputMode] = React.useState("text"); // text | audio | video
      const [overlayText, setOverlayText] = React.useState("MR Overlay");
      const [isMRMode, setIsMRMode] = React.useState(false);
      const [typing, setTyping] = React.useState(false);

      // 音声→テキスト認識
      const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
      const recogRef = React.useRef(null);
      React.useEffect(() => {
        if (SR) {
          const r = new SR(); r.lang="ja-JP"; r.continuous=false;
          r.onresult = e => setInput(e.results[0][0].transcript);
          r.onerror = e => console.error("音声認識エラー:", e.error);
          recogRef.current = r;
        }
      }, []);

      // MR カメラ
      React.useEffect(() => {
        if (isMRMode && navigator.mediaDevices?.getUserMedia) {
          navigator.mediaDevices.getUserMedia({ video:true })
            .then(stream => { if (videoRef.current) videoRef.current.srcObject = stream; })
            .catch(err => console.error("カメラエラー:", err));
        }
        return () => {
          if (videoRef.current?.srcObject) {
            for (const t of videoRef.current.srcObject.getTracks()) t.stop();
            videoRef.current.srcObject = null;
          }
        };
      }, [isMRMode]);

      // 模擬返信
      const reply = React.useCallback(() => {
        setTyping(true);
        setTimeout(() => {
          setTyping(false);
          setMessages(p => [...p, { role:"agent", type:"text", text:"はい、かしこまりました。続けてご質問ください。" }]);
        }, 700);
      }, []);

      // テキスト送信
      const sendText = React.useCallback(() => {
        const val = input.trim(); if (!val) return;
        setMessages(p => [...p, { role:"user", type:"text", text:val }]);
        setInput(""); reply();
      }, [input, reply]);

      const onKeyDown = e => { if ((e.ctrlKey||e.metaKey) && e.key==='Enter') { e.preventDefault(); sendText(); } };
      const voiceToText = () => { if (!recogRef.current) return alert("このブラウザでは音声認識が使えません。"); recogRef.current.start(); };

      // 録音/録画
      const recAudioRef = React.useRef(null), recVideoRef = React.useRef(null);
      const streamRef = React.useRef(null), chunksRef = React.useRef([]);
      const [recAudio, setRecAudio] = React.useState(false), [recVideo, setRecVideo] = React.useState(false);
      const stopStream = () => { streamRef.current?.getTracks().forEach(t=>t.stop()); streamRef.current = null; };

      const startAudio = async () => {
        try {
          const s = await navigator.mediaDevices.getUserMedia({ audio:true });
          streamRef.current = s; chunksRef.current = [];
          const r = new MediaRecorder(s); recAudioRef.current = r;
          r.ondataavailable = e => e.data.size && chunksRef.current.push(e.data);
          r.onstop = () => {
            const url = URL.createObjectURL(new Blob(chunksRef.current,{type:'audio/webm'}));
            setMessages(p => [...p, { role:"user", type:"audio", mediaUrl:url }]);
            stopStream(); reply();
          };
          r.start(); setRecAudio(true);
        } catch(e){ console.error(e); alert("マイクの使用を許可してください。"); }
      };
      const stopAudio = () => { if (recAudioRef.current && recAudio) { recAudioRef.current.stop(); setRecAudio(false); } };

      const startVideo = async () => {
        try {
          const s = await navigator.mediaDevices.getUserMedia({ audio:true, video:true });
          streamRef.current = s; chunksRef.current = [];
          const r = new MediaRecorder(s); recVideoRef.current = r;
          r.ondataavailable = e => e.data.size && chunksRef.current.push(e.data);
          r.onstop = () => {
            const url = URL.createObjectURL(new Blob(chunksRef.current,{type:'video/webm'}));
            setMessages(p => [...p, { role:"user", type:"video", mediaUrl:url }]);
            stopStream(); reply();
          };
          r.start(); setRecVideo(true);
        } catch(e){ console.error(e); alert("カメラ・マイクの使用を許可してください。"); }
      };
      const stopVideo = () => { if (recVideoRef.current && recVideo) { recVideoRef.current.stop(); setRecVideo(false); } };

      const value = {
        messages, input, inputMode, typing, isMRMode, overlayText,
        videoRef, inputRef,
        setInput, setInputMode, setIsMRMode, setOverlayText,
        onKeyDown, voiceToText, sendText,
        recAudio, recVideo, startAudio, stopAudio, startVideo, stopVideo,
      };
      return <ChatContext.Provider value={value}>{children}</ChatContext.Provider>;
    }

    // ====== チャット UI ======
    function ChatStream({ typing }) {
      const { messages } = useChat();
      return (
        <Box sx={{ display:'flex', flexDirection:'column', gap:1, p:1 }}>
          {messages.map((m,i)=>(
            <Box key={i} sx={{ display:'flex', justifyContent: m.role==='user' ? 'flex-end':'flex-start' }}>
              <div className={`bubble ${m.role}`}>
                {m.type==='text' && m.text}
                {m.type==='audio' && (<Box sx={{ display:'flex', alignItems:'center', gap:1 }}>
                  <span className="material-icons" aria-hidden>graphic_eq</span>
                  <audio controls src={m.mediaUrl} style={{ maxWidth: 260 }} />
                </Box>)}
                {m.type==='video' && (<video controls src={m.mediaUrl} style={{ maxWidth: 320, borderRadius:8 }} />)}
              </div>
            </Box>
          ))}
          {typing && (<Box sx={{ display:'flex', justifyContent:'flex-start' }}>
            <div className="bubble agent"><span className="typing"><span></span><span></span><span></span></span></div>
          </Box>)}
        </Box>
      );
    }

    function AIMRChat() {
      const {
        videoRef, inputRef, input, setInput, inputMode, setInputMode,
        isMRMode, setIsMRMode, overlayText, typing,
        onKeyDown, voiceToText, sendText,
        recAudio, recVideo, startAudio, stopAudio, startVideo, stopVideo
      } = useChat();

      React.useEffect(()=>{ inputRef.current?.focus(); },[inputRef]);

      // ▼ メッセージ領域の高さ（px）を内部ドラッグで変更
      const [msgHeight, setMsgHeight] = React.useState(260);
      const splitDraggingRef = React.useRef(false);
      const splitHRef = React.useRef(msgHeight);
      const splitRAF = React.useRef(0);

      const onSplitDown = (e) => {
        splitDraggingRef.current = true;
        document.body.style.userSelect = 'none';
        e.currentTarget.setPointerCapture?.(e.pointerId);
      };
      const onSplitMove = (e) => {
        if (!splitDraggingRef.current) return;
        const chatBox = e.currentTarget.closest('.chat-drawer-body');
        if (!chatBox) return;
        const rect = chatBox.getBoundingClientRect();
        const relativeY = e.clientY - rect.top;
        const minMsg = 120;
        const maxMsg = Math.max(180, Math.floor(rect.height * 0.8));
        const estimatedTopGaps = 120; // ツールバー/余白のざっくり見積り
        const next = Math.max(minMsg, Math.min(maxMsg, relativeY - estimatedTopGaps));
        splitHRef.current = next;
        if (splitRAF.current) return;
        splitRAF.current = requestAnimationFrame(() => {
          splitRAF.current = 0;
          setMsgHeight(Math.round(splitHRef.current));
        });
      };
      const onSplitUp = (e) => {
        splitDraggingRef.current = false;
        document.body.style.userSelect = '';
        e.currentTarget.releasePointerCapture?.(e.pointerId);
      };

      return (
        <Box sx={{ display:'flex', flexDirection:'column', flex:1, minHeight:0, gap:2, width:'100%' }}>
          {isMRMode && (
            <Box className="glass"
                 sx={{ position:'relative', width:'100%', aspectRatio:'16/9', overflow:'hidden', flex:'0 0 auto' }}>
              <video ref={videoRef} autoPlay muted playsInline
                     style={{ width:'100%', height:'100%', objectFit:'cover' }} />
              <div className="mr-overlay">{overlayText}</div>
              <div className="mr-agent">AI Agent</div>
            </Box>
          )}

          <Paper className="glass"
            sx={{ p:0, overflow:'hidden', display:'flex', flexDirection:'column', flex:1, minHeight:0 }}
            variant="outlined">

            {/* メッセージ領域（ドラッグで高さ変更） */}
            <Box sx={{ flex:'0 0 auto', height: `${msgHeight}px`, minHeight:120, overflowY:'auto', p:2 }}>
              <ChatStream typing={typing} />
            </Box>

            {/* 内部ハンドル */}
            <Box className="inner-resize-handle"
                 onPointerDown={onSplitDown}
                 onPointerMove={onSplitMove}
                 onPointerUp={onSplitUp}>
              <span className="material-icons">drag_handle</span>
            </Box>

            <Divider textAlign="left">
              <Chip size="small" color="primary" variant="outlined"
                icon={<span className="material-icons" style={{fontSize:16}}>chat</span>} label="チャット" />
            </Divider>

            {/* 入力エリア */}
            <Box sx={{ px:1.5, pt:1, display:'flex', justifyContent:'space-between', alignItems:'center', gap:1, flexWrap:'wrap' }}>
              <ButtonGroup variant="outlined" size="small" aria-label="入力モード切替">
                <Button startIcon={<span className="material-icons">keyboard</span>}
                  variant={inputMode==='text'?'contained':'outlined'} onClick={()=>setInputMode('text')}>テキスト</Button>
                <Button startIcon={<span className="material-icons">mic</span>}
                  variant={inputMode==='audio'?'contained':'outlined'} onClick={()=>setInputMode('audio')}>音声</Button>
                <Button startIcon={<span className="material-icons">videocam</span>}
                  variant={inputMode==='video'?'contained':'outlined'} onClick={()=>setInputMode('video')}>動画</Button>
              </ButtonGroup>
              <FormControlLabel control={<Switch checked={isMRMode} onChange={e=>setIsMRMode(e.target.checked)} color="primary" />} label="MRモード" />
            </Box>

            <Box sx={{ p:1.5, pt:1, display:'flex', flexDirection:'column', gap:1, minHeight:0 }}>
              {inputMode==='text' && (
                <>
                  <TextField
                    inputRef={inputRef}
                    variant="outlined"
                    multiline
                    minRows={3}
                    maxRows={Infinity}
                    size="small"
                    fullWidth
                    value={input}
                    onKeyDown={onKeyDown}
                    onChange={e=>setInput(e.target.value)}
                    placeholder="メッセージを入力…（Ctrl/⌘ + Enter で送信）"
                    aria-label="チャット入力"
                    sx={{
                      '& .MuiOutlinedInput-root textarea': {
                        resize: 'vertical',   // ← 縦リサイズ可
                        overflow: 'auto',
                      }
                    }}
                  />
                  <Box sx={{ display:'flex', justifyContent:'flex-end', gap:1 }}>
                    <Tooltip title="音声で入力（音声→テキスト認識）">
                      <IconButton onClick={voiceToText} color="primary" aria-label="音声入力（認識）">
                        <span className="material-icons">hearing</span>
                      </IconButton>
                    </Tooltip>
                    <Button variant="contained" onClick={sendText} startIcon={<span className="material-icons">send</span>}>送信</Button>
                  </Box>
                </>
              )}

              {inputMode==='audio' && (
                <Box sx={{ display:'flex', alignItems:'center', justifyContent:'space-between', gap:1, flexWrap:'wrap' }}>
                  <Box sx={{ display:'flex', alignItems:'center', gap:1 }}>
                    <span className="material-icons">{recAudio?'radio_button_checked':'radio_button_unchecked'}</span>
                    <Typography variant="body2" color="text.secondary">
                      {recAudio?'録音中…もう一度押すと停止して送信':'マイクで録音して送信'}
                    </Typography>
                  </Box>
                  {!recAudio
                    ? <Button color="primary" variant="contained" onClick={startAudio} startIcon={<span className="material-icons">mic</span>}>録音開始</Button>
                    : <Button color="error" variant="contained" onClick={stopAudio} startIcon={<span className="material-icons">stop</span>}>停止して送信</Button>}
                </Box>
              )}

              {inputMode==='video' && (
                <Box sx={{ display:'flex', alignItems:'center', justifyContent:'space-between', gap:1, flexWrap:'wrap' }}>
                  <Box sx={{ display:'flex', alignItems:'center', gap:1 }}>
                    <span className="material-icons">{recVideo?'fiber_manual_record':'videocam'}</span>
                    <Typography variant="body2" color="text.secondary">
                      {recVideo?'録画中…もう一度押すと停止して送信':'カメラで録画して送信'}
                    </Typography>
                  </Box>
                  {!recVideo
                    ? <Button color="primary" variant="contained" onClick={startVideo} startIcon={<span className="material-icons">videocam</span>}>録画開始</Button>
                    : <Button color="error" variant="contained" onClick={stopVideo} startIcon={<span className="material-icons">stop</span>}>停止して送信</Button>}
                </Box>
              )}
            </Box>
          </Paper>
        </Box>
      );
    }

    // ====== AppBar 中央クイック入力 ======
    function AppbarCenterQuickInput({ onFocusOpen, inputElRef, suppressAutoOpen }) {
      const { setInput } = useChat();
      const [draft, setDraft] = React.useState("");
      const handleFocus = () => { if (!suppressAutoOpen) onFocusOpen?.(); };
      const handleChange = e => { const v=e.target.value; setDraft(v); setInput(v); };
      const handleKeyDown = e => { if (e.key==='Enter') onFocusOpen?.(); };

      return (
        <Box sx={{
          position:'absolute', left:'50%', transform:'translateX(-50%)',
          width:{ xs:'20vw', sm:'60vw', md:'50vw' }, maxWidth:640, minWidth:100
        }}>
          <TextField
            inputRef={inputElRef} fullWidth size="small" variant="outlined"
            placeholder="いま何をお手伝いできますか？（フォーカスでチャット展開）"
            value={draft} onChange={handleChange} onFocus={handleFocus} onKeyDown={handleKeyDown}
            InputProps={{
              startAdornment:(
                <InputAdornment position="start">
                  <span className="material-icons" style={{ color:'#fff' }}>support_agent</span>
                </InputAdornment>
              )
            }}
            sx={{
              '& .MuiOutlinedInput-root': { backgroundColor:'rgba(255,255,255,0.18)', borderRadius:3 },
              '& .MuiOutlinedInput-notchedOutline': { borderColor:'rgba(255,255,255,0.35)' },
              '&:hover .MuiOutlinedInput-notchedOutline': { borderColor:'rgba(255,255,255,0.55)' },
              '& .MuiInputBase-input': { color:'#fff' },
              '& .MuiInputBase-input::placeholder': { color:'rgba(255,255,255,0.9)' }
            }}
            aria-label="クイック入力（フォーカスでAIチャットを展開）"
          />
        </Box>
      );
    }

    // ====== メニュー（簡潔版） ======
    function usePersistentMenu(){
      const [items, setItems] = React.useState(()=>{
        try{
          const raw = localStorage.getItem(LS_KEY);
          if(raw){
            const parsed = JSON.parse(raw);
            const map = new Map(parsed.map(x=>[x.key,x]));
            const merged = DEFAULT_MENU.map(d=>map.get(d.key)||d);
            parsed.forEach(x=>{ if(!merged.find(m=>m.key===x.key)) merged.push(x); });
            return merged;
          }
        }catch{}
        return DEFAULT_MENU;
      });
      const save = React.useCallback(n=>{ setItems(n); try{localStorage.setItem(LS_KEY, JSON.stringify(n));}catch{} },[]);
      return { items, setItems: save, reset: ()=>save(DEFAULT_MENU) };
    }
    const reorder=(list,a,b)=>{ const r=[...list]; const [m]=r.splice(a,1); r.splice(b,0,m); return r; };

    function MenuGrid({ setSelectedApp }){
      const { items, setItems, reset } = usePersistentMenu();
      const [edit, setEdit] = React.useState(false);
      const [drag, setDrag] = React.useState(null), [over, setOver] = React.useState(null);

      const onDragStart=(e,i)=>{ if(!edit) return e.preventDefault(); setDrag(i); e.dataTransfer.effectAllowed="move";
        e.dataTransfer.setData("text/plain",String(i)); e.currentTarget.classList.add("dragging"); };
      const onDragEnd=e=>{ e.currentTarget.classList.remove("dragging"); setDrag(null); setOver(null); };
      const onDragOver=(e,i)=>{ if(drag===null||!edit) return; e.preventDefault(); setOver(i); };
      const onDrop=(e,i)=>{ e.preventDefault(); const from = drag ?? Number(e.dataTransfer.getData("text/plain"));
        if(from===i||from==null) return; setItems(reorder(items, from, i)); setDrag(null); setOver(null); };

      return (
        <Paper className="glass" sx={{ py:2, px:1, mx:{ md:2 }, mb:{ xs:1.5, md:2 } }} elevation={0}>
          <Box sx={{ display:'flex', alignItems:'center', justifyContent:'space-between', px:1, pb:1 }}>
            <Typography variant="subtitle2" sx={{ color:'#556', fontWeight:700 }}>クイックメニュー</Typography>
            <Stack direction="row" spacing={1}>
              {edit && <Button size="small" variant="outlined" onClick={reset}
                        startIcon={<span className="material-icons">restart_alt</span>}>リセット</Button>}
              <Button size="small" variant={edit?"contained":"outlined"} color={edit?"primary":"inherit"}
                      onClick={()=>setEdit(v=>!v)}
                      startIcon={<span className="material-icons">{edit?"done":"edit"}</span>}>
                {edit?"完了":"編集"}
              </Button>
            </Stack>
          </Box>

          {edit && (
            <Box sx={{ px:1, pb:1 }}>
              <Alert severity="info" icon={<span className="material-icons">drag_indicator</span>}>
                アイコンをドラッグして並び替えできます。完了を押すと保存されます。
              </Alert>
            </Box>
          )}

          <Grid container spacing={2} justifyContent="center">
            {items.map((it, i)=>(
              <Grid item key={it.key} xs={3} sm={2} md={1} sx={{ textAlign:'center' }}>
                <div className={`menu-item ${edit?"editing":""}`} draggable={edit}
                  onDragStart={e=>onDragStart(e,i)} onDragEnd={onDragEnd}
                  onDragOver={e=>onDragOver(e,i)} onDrop={e=>onDrop(e,i)}
                  onClick={!edit && setSelectedApp ? ()=>setSelectedApp(it) : undefined}
                  style={{ cursor: !edit ? 'pointer' : 'grab' }}>
                  <div className="menu-icon" style={{ backgroundColor: it.color }}>
                    <span className="material-icons">{it.icon}</span>
                  </div>
                  <div className="menu-label">
                    {it.label}{edit && <span className="material-icons" style={{ fontSize:14, marginLeft:6, opacity:.6 }}>drag_indicator</span>}
                  </div>
                </div>
                {edit && over===i && drag!==null && drag!==i && (<div class="drop-hint" aria-hidden></div>)}
              </Grid>
            ))}
          </Grid>
        </Paper>
      );
    }

    // ====== アプリ本体（Swiper panorama対応） ======
    function App(){
      const [open, setOpen] = React.useState(false);
      const [suppress, setSuppress] = React.useState(false);
      const [selectedApps, setSelectedApps] = React.useState([]);
      const [isFullscreen, setIsFullscreen] = React.useState(false);
      const [showNotification, setShowNotification] = React.useState(false);
      const [showAIAssistant, setShowAIAssistant] = React.useState(true);
      const isMobile = useMediaQuery('(max-width:600px)');
      const { inputRef } = useChat();
      const appbarInputRef = React.useRef(null);
      const swiperRef = React.useRef(null);
      
      const addApp = (app) => {
        setSelectedApps(prev => {
          if (prev.find(a => a.key === app.key)) return prev;
          return [...prev, app];
        });
      };
      
      const removeApp = (index) => {
        setSelectedApps(prev => prev.filter((_, i) => i !== index));
      };
      
      React.useEffect(() => {
        if (selectedApps.length > 0 && window.Swiper) {
          setTimeout(() => {
            const swiperEl = document.querySelector('.swiper');
            if (swiperEl && !swiperRef.current) {
              swiperRef.current = new window.Swiper(swiperEl, {
                effect: 'coverflow',
                grabCursor: true,
                centeredSlides: true,
                slidesPerView: 'auto',
                coverflowEffect: {
                  rotate: 50,
                  stretch: 0,
                  depth: 100,
                  modifier: 1,
                  slideShadows: true,
                },
                navigation: {
                  nextEl: '.swiper-button-next',
                  prevEl: '.swiper-button-prev',
                },
              });
            }
          }, 100);
        }
        return () => {
          if (swiperRef.current && swiperRef.current.destroy) {
            swiperRef.current.destroy();
            swiperRef.current = null;
          }
        };
      }, [selectedApps.length]);

      // リサイズ：高さ（px）
      const [drawerHeight, setDrawerHeight] = React.useState(null); // 確定値のみ保持
      const resizingRef = React.useRef(false);

      const initialHeightPx = () => Math.round(window.innerHeight * (isMobile ? 0.95 : 0.8));
      const minHeightPx = () => Math.round(window.innerHeight * 0.35);
      const maxHeightPx = () => Math.round(window.innerHeight * 1.0);

      const openDrawer = () => {
        setOpen(true);
        appbarInputRef.current?.blur();
        const h = initialHeightPx();
        setDrawerHeight(h);
        setTimeout(()=>inputRef?.current?.focus(), 250);
      };
      const closeDrawer = () => {
        setOpen(false);
        setSuppress(true);
        appbarInputRef.current?.blur();
        setTimeout(()=>setSuppress(false), 400);
      };

      // rAF でドラッグ中は DOM 直書き
      const drawerPaperRef = React.useRef(null);
      const rAFRef = React.useRef(0);
      const dragHRef = React.useRef(null);

      const onHandleDown = (e) => {
        resizingRef.current = true;
        document.body.style.userSelect = 'none';
        e.currentTarget.setPointerCapture?.(e.pointerId);
      };
      const applyHeight = (px) => {
        dragHRef.current = Math.max(minHeightPx(), Math.min(maxHeightPx(), px));
        if (rAFRef.current) return;
        rAFRef.current = requestAnimationFrame(() => {
          rAFRef.current = 0;
          const paper = drawerPaperRef.current;
          if (paper && dragHRef.current != null) {
            paper.style.height = `${dragHRef.current}px`;
          }
        });
      };
      const onHandleMove = (e) => {
        if (!resizingRef.current) return;
        applyHeight(e.clientY);
      };
      const onHandleUp = (e) => {
        resizingRef.current = false;
        document.body.style.userSelect = '';
        e.currentTarget.releasePointerCapture?.(e.pointerId);
        if (dragHRef.current != null) {
          setDrawerHeight(Math.round(dragHRef.current)); // 確定値を state に
        }
        dragHRef.current = null;
      };

      return (
        <Box sx={{ minHeight:'100vh', display:'flex', flexDirection:'column' }}>
          <AppBar position="sticky" elevation={8}
            sx={{ background:'linear-gradient(90deg, #283593 0%, #3949ab 50%, #1e88e5 100%)' }}>
            <Toolbar sx={{ minHeight:{ xs:64, sm:72 }, position:'relative', gap:1 }}>
              <Typography variant="h6" sx={{ fontWeight:700, letterSpacing:.2 }}>Assistant</Typography>
              <AppbarCenterQuickInput onFocusOpen={openDrawer} inputElRef={appbarInputRef} suppressAutoOpen={suppress} />
              <Box sx={{ flex:1 }} />
              <Tooltip title="通知"><IconButton color="inherit" aria-label="通知">
                <span className="material-icons">notifications</span>
              </IconButton></Tooltip>
              <Tooltip title="アカウント"><IconButton color="inherit" aria-label="アカウント">
                <span className="material-icons">account_circle</span>
              </IconButton></Tooltip>
            </Toolbar>
          </AppBar>

          {selectedApps.length > 0 && (
            <Box sx={{ width:'100%', height: isFullscreen ? '100vh' : '60vh', position: isFullscreen ? 'fixed' : 'relative', top: isFullscreen ? 0 : 'auto', left: isFullscreen ? 0 : 'auto', zIndex: isFullscreen ? 9999 : 'auto', bgcolor: isFullscreen ? 'background.default' : 'transparent' }}>
              <div className="swiper" style={{ width:'100%', height:'100%' }}>
                <div className="swiper-wrapper">
                  {selectedApps.map((app, index) => (
                    <div key={app.key} className="swiper-slide">
                      <Paper className="glass" variant="outlined" sx={{ width:'100%', height:'100%', borderRadius:4 }}>
                        <Box sx={{ display:'flex', alignItems:'center', justifyContent:'space-between', p:2, borderBottom:'1px solid rgba(0,0,0,0.1)', bgcolor:'rgba(255,255,255,0.95)' }}>
                          <Box sx={{ display:'flex', alignItems:'center', gap:1.5 }}>
                            <Avatar sx={{ bgcolor: app.color }}>
                              <span className="material-icons">{app.icon}</span>
                            </Avatar>
                            <Typography variant="h6" sx={{ fontWeight:700 }}>{app.label}</Typography>
                          </Box>
                          <Stack direction="row" spacing={1}>
                            <Tooltip title={isFullscreen ? "ウィンドウモード" : "全画面モード"}>
                              <IconButton onClick={()=>setIsFullscreen(!isFullscreen)}>
                                <span className="material-icons">{isFullscreen ? 'fullscreen_exit' : 'fullscreen'}</span>
                              </IconButton>
                            </Tooltip>
                            <Tooltip title="閉じる">
                              <IconButton onClick={()=>removeApp(index)}>
                                <span className="material-icons">close</span>
                              </IconButton>
                            </Tooltip>
                          </Stack>
                        </Box>
                        <Box sx={{ p:3, height:'calc(100% - 80px)', display:'flex', alignItems:'center', justifyContent:'center' }}>
                          <Typography variant="h4" color="text.secondary">
                            {app.label} アプリケーション
                          </Typography>
                        </Box>
                      </Paper>
                    </div>
                  ))}
                </div>
                <div className="swiper-button-next"></div>
                <div className="swiper-button-prev"></div>
              </div>
            </Box>
          )}

          <Container maxWidth="md" sx={{ flex:1, py:{ xs:2, sm:3 } }}>
            {selectedApps.length === 0 ? showAIAssistant ? (
              <Paper className="glass" sx={{ p:3, position:'relative' }} variant="outlined">
                <Box sx={{ display:'flex', alignItems:'center', gap:1.5, mb:1 }}>
                  <Avatar sx={{ bgcolor:'primary.main' }}><span className="material-icons">smart_toy</span></Avatar>
                  <Typography variant="h6" sx={{ fontWeight:700 }}>AIアシスタント</Typography>
                  <Tooltip title="通知で閉じる">
                    <IconButton size="small" onClick={()=>{setShowNotification(true);setShowAIAssistant(false);}}>
                      <span className="material-icons">close</span>
                    </IconButton>
                  </Tooltip>
                </Box>
                <Typography variant="body2" color="text.secondary">
                  AppBar中央の入力にフォーカスでAIチャット展開。下端のハンドルで高さ変更可能。中のメッセージ領域はドラッグで高さ調整、テキスト欄は右下つまみで縦リサイズできます。
                </Typography>
              </Paper>
            ) : null : null}
          </Container>

          <MenuGrid setSelectedApp={addApp} />

          <Box component="footer" sx={{ textAlign:'center', p:2, color:'white',
            background:'linear-gradient(90deg, #283593 0%, #1e88e5 100%)', boxShadow:'0 -8px 24px rgba(0,0,0,0.08)' }}>
            <Typography variant="caption">&copy; 2025 My Company - All Rights Reserved.</Typography>
          </Box>

          <SwipeableDrawer
            anchor="top" open={open}
            onClose={closeDrawer} onOpen={()=>setOpen(true)} disableDiscovery
            PaperProps={{
              ref: drawerPaperRef,   // ← DOM を掴む
              sx:{
                height: drawerHeight ? `${drawerHeight}px` : undefined,
                maxHeight: '100vh',
                borderBottomLeftRadius:16, borderBottomRightRadius:16,
                backgroundImage:'linear-gradient(180deg,#ffffff 0%, #f7f9ff 100%)',
                alignSelf:'flex-start', display:'flex', flexDirection:'column',
                willChange:'height',     // ← ペイント最適化
                contain:'paint'          // ← レイアウト影響の封じ込め
              }
            }}
          >
            <Box className="chat-drawer-body" sx={{ height:'100%', display:'flex', flexDirection:'column' }}>
              <Toolbar sx={{ px:2 }}>
                <Typography variant="h6" sx={{ flexGrow:1, fontWeight:700 }}>AIチャット</Typography>
                <Tooltip title="閉じる (Esc)">
                  <IconButton onClick={closeDrawer} aria-label="閉じる"><span className="material-icons">close</span></IconButton>
                </Tooltip>
              </Toolbar>
              <Divider />

              <Box sx={{ px:{ xs:1.5, sm:2 }, pb:0, pt:1, flex:1, minHeight:0, display:'flex' }}>
                <AIMRChat />
              </Box>

              <Box className="resize-handle"
                   onPointerDown={onHandleDown}
                   onPointerMove={onHandleMove}
                   onPointerUp={onHandleUp}>
                <span className="material-icons">drag_handle</span>
              </Box>
            </Box>
          </SwipeableDrawer>

          <Snackbar
            open={showNotification}
            autoHideDuration={3000}
            onClose={()=>setShowNotification(false)}
            anchorOrigin={{ vertical: 'top', horizontal: 'center' }}
          >
            <Alert onClose={()=>setShowNotification(false)} severity="info" sx={{ width: '100%' }}>
              AIアシスタントを閉じました
            </Alert>
          </Snackbar>
        </Box>
      );
    }

    function Root(){
      return (
        <ThemeProvider theme={theme}>
          <CssBaseline />
          <ChatProvider>
            <App />
          </ChatProvider>
        </ThemeProvider>
      );
    }

    ReactDOM.createRoot(document.getElementById("root")).render(<Root/>);
  </script>
</body>
</html>