<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>商品ダッシュボード｜EOL中心ロジック + 提案UI（完全版）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Fonts / Icons -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap"/>
  <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons"/>
  <!-- React / Babel / MUI -->
  <script src="https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.production.min.js" crossorigin></script>
  <script src="https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://cdn.jsdelivr.net/npm/@babel/standalone@7.23.8/babel.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mui/material@5.15.3/umd/material-ui.production.min.js" crossorigin></script>
  <style>
    html,body,#root{height:100%}
    body{margin:0;background:#f7f7f8}
    .wrap{max-width:1400px;margin:0 auto;padding:16px}
    .mono{font-variant-numeric:tabular-nums;font-feature-settings:"tnum"}
    .mini{font-size:12px;color:#666}
    .pill{display:inline-flex;align-items:center;gap:6px;border:1px solid #eee;border-radius:999px;padding:2px 8px;background:#fff}
    .rowHover{cursor:pointer}
    .rowHover:hover{background:#fafafa}
    .crumb{display:flex;align-items:center;gap:6px;font-size:13px;color:#666}
    .crumb b{color:#111}
    .vh35{height:35vh; min-height:260px; max-height:520px}
    .cards{display:grid;gap:16px;grid-template-columns:repeat(4,minmax(180px,1fr))}
    @media (max-width:1000px){.cards{grid-template-columns:repeat(2,1fr)}}
    @media (max-width:600px){.cards{grid-template-columns:1fr}}
    .tableWrap{overflow:auto}
    table{width:100%;border-collapse:collapse}
    th,td{border:1px solid #eee;padding:8px}
    th{text-align:left;background:#fafafa}
  </style>
</head>
<body>
<div id="root"></div>

<script type="text/babel" data-presets="env,react">
const {
  AppBar, Toolbar, Typography, Paper, Box, Stack, Chip, Button,
  Card, CardContent, Divider, Grid, ToggleButton, ToggleButtonGroup,
  Dialog, DialogTitle, DialogContent, DialogActions, TextField, MenuItem,
  Snackbar, Alert, Checkbox, Autocomplete, Collapse
} = MaterialUI;

/* ====== ダミーマスター ====== */
const PRODUCTS=[
  {id:'P001',sku:'TSH-001',name:'ベーシックTシャツ',price:1990,dept:'アパレル', eol:'2025-10-15'},
  {id:'P002',sku:'SNE-101',name:'ライトスニーカー',price:5990,dept:'シューズ', eol:'2025-09-30'},
  {id:'P003',sku:'BAG-777',name:'デイリーバッグ',price:3990,dept:'バッグ', eol:'2025-11-10'}
];
const STORES=[
  {id:'S01',name:'新宿本店',channel:'店舗'},
  {id:'S02',name:'渋谷店',channel:'店舗'},
  {id:'S03',name:'名古屋店',channel:'店舗'},
  {id:'S04',name:'アウトレット木更津',channel:'アウトレット'},
  {id:'S05',name:'ECサイト',channel:'オンライン'}
];
const CHANNELS=[...new Set(STORES.map(s=>s.channel))];
const DEPTS=[...new Set(PRODUCTS.map(p=>p.dept))];

/* ====== 在庫・売上（ダミー生成） ====== */
let INVENTORY=[
  {productId:'P001',storeId:'S01',qty:120},{productId:'P001',storeId:'S02',qty:60},{productId:'P001',storeId:'S03',qty:40},{productId:'P001',storeId:'S04',qty:200},{productId:'P001',storeId:'S05',qty:150},
  {productId:'P002',storeId:'S01',qty:40},{productId:'P002',storeId:'S02',qty:20},{productId:'P002',storeId:'S03',qty:10},{productId:'P002',storeId:'S04',qty:120},{productId:'P002',storeId:'S05',qty:80},
  {productId:'P003',storeId:'S01',qty:25},{productId:'P003',storeId:'S02',qty:40},{productId:'P003',storeId:'S03',qty:35},{productId:'P003',storeId:'S04',qty:10},{productId:'P003',storeId:'S05',qty:90}
];
function generateSales(seed=42){
  let x=seed; const rand=()=> (x=(x*1664525+1013904223)%4294967296)/4294967296;
  const rows=[]; const today=new Date();
  for(let d=0; d<60; d++){
    const date=new Date(today); date.setDate(date.getDate()-d); const ds=date.toISOString().slice(0,10);
    PRODUCTS.forEach(p=>{
      STORES.forEach(s=>{
        const base=(s.channel==='オンライン'?10:s.channel==='アウトレット'?6:4)*(p.id==='P002'?0.9:p.id==='P003'?0.7:1);
        const w=(date.getDay()===0||date.getDay()===6)?1.3:1.0; const noise=(rand()*0.8+0.6);
        let units=Math.max(0,Math.round(base*w*noise-1));
        const inv=INVENTORY.find(i=>i.productId===p.id&&i.storeId===s.id)?.qty??0;
        if(inv<10) units=Math.min(units, Math.round(inv/5));
        rows.push({productId:p.id,storeId:s.id,date:ds,units,net:units*p.price});
      });
    });
  }
  return rows;
}
let SALES=generateSales();

/* ====== メモリ内の共有データ（永続化なし） ====== */
let REQUESTS=[];
let TODOS=[{id:1,title:'P001 渋谷店 10点 補充手配',owner:'商品部',due:new Date().toISOString().slice(0,10),done:false}];
let EVENTS=[{id:1,title:'棚卸し全店',date:new Date().toISOString().slice(0,10),owner:'システム管理運用'}];

/* ====== Utils ====== */
const fmtYen=n=>n.toLocaleString('ja-JP',{style:'currency',currency:'JPY',maximumFractionDigits:0});
const sum=(a,sel=x=>x)=>a.reduce((p,c)=>p+sel(c),0);
const byId=list=>Object.fromEntries(list.map(x=>[x.id,x]));
const toDate=s=>new Date(s+'T00:00:00');
const avgDaily=(u,d)=>d>0?u/d:0;
const daysOfSupply=(q,d)=>d>0?q/d:Infinity;
const daysBetween=(a,b)=> Math.max(0, Math.floor((toDate(b)-toDate(a))/86400000));
const storeById=byId(STORES);
const productById=byId(PRODUCTS);

/* ====== 集計関数 ====== */
function filterSales({productIds,from,to,channels,storeIds,deptSet}){
  const setP = productIds? new Set(productIds): null;
  const setS = storeIds? new Set(storeIds): null;
  const setC = channels? new Set(channels): null;
  const setD = deptSet? new Set(deptSet): null;
  return SALES.filter(r=>{
    if(setP && !setP.has(r.productId)) return false;
    if(setS && !setS.has(r.storeId)) return false;
    if(setC && !setC.has(storeById[r.storeId].channel)) return false;
    if(setD && !setD.has(productById[r.productId].dept)) return false;
    const d=toDate(r.date);
    return d>=toDate(from) && d<=toDate(to);
  });
}
function aggregateByStore(rows){
  const map=new Map();
  rows.forEach(r=>{
    const key=r.storeId;
    if(!map.has(key)) map.set(key,{storeId:r.storeId,store:storeById[r.storeId].name,channel:storeById[r.storeId].channel,units:0,net:0,days:new Set(),inv:0});
    const o=map.get(key); o.units+=r.units; o.net+=r.net; o.days.add(r.date);
  });
  const out=[...map.values()].map(x=>({...x,days:x.days.size}));
  out.forEach(o=>{
    o.inv = sum(INVENTORY.filter(i=>i.storeId===o.storeId), i=>i.qty);
  });
  return out;
}
function aggregateByChannel(rows){
  const map=new Map();
  rows.forEach(r=>{
    const ch=storeById[r.storeId].channel;
    if(!map.has(ch)) map.set(ch,{channel:ch,units:0,net:0,stores:new Set(),days:new Set()});
    const o=map.get(ch); o.units+=r.units; o.net+=r.net; o.stores.add(r.storeId); o.days.add(r.date);
  });
  return [...map.values()].map(x=>({...x,stores:x.stores.size,days:x.days.size||1}));
}
function calcTrendSeries(productIds,channels,storeIds,deptSet,toStr){
  const to=toDate(toStr);
  const day=n=>{const d=new Date(to); d.setDate(d.getDate()-n); return d.toISOString().slice(0,10);};
  const series=[]; for(let i=13;i>=0;i--){ const ds=day(i);
    const val=sum(SALES.filter(r=>{
      const okP = productIds? productIds.includes(r.productId): true;
      const okC = channels? channels.includes(storeById[r.storeId].channel): true;
      const okS = storeIds? storeIds.includes(r.storeId): true;
      const okD = deptSet? deptSet.includes(productById[r.productId].dept): true;
      return okP && okC && okS && okD && r.date===ds;
    }), r=>r.net);
    series.push(val);
  } return series;
}

/* ====== 需要・EOL中心ロジック ======
   軽量な近似：営業日は土日を除外（簡易）
*/
function businessDaysBetween(startStr,endStr){
  const start=toDate(startStr), end=toDate(endStr);
  if(end<start) return 0;
  let d=new Date(start), cnt=0;
  while(d<=end){
    const day=d.getDay();
    if(day!==0 && day!==6) cnt++;
    d.setDate(d.getDate()+1);
  }
  return cnt;
}
// 過去7/14/28の加重平均（期間が短い場合もロバスト）
function weightedAvgDaily(productId, storeId, refDateStr){
  const ref=toDate(refDateStr);
  const days=[7,14,28], weights=[0.5,0.3,0.2];
  let acc=0, wsum=0;
  days.forEach((win,idx)=>{
    const from=new Date(ref); from.setDate(from.getDate()-win+1);
    const to=ref;
    const rows = SALES.filter(r=>r.productId===productId && r.storeId===storeId && toDate(r.date)>=from && toDate(r.date)<=to);
    const units=sum(rows,x=>x.units);
    const daily=win>0? units/win : 0;
    acc += daily*weights[idx]; wsum+=weights[idx];
  });
  return wsum>0? acc/wsum : 0;
}
function computeGapsForProduct(productId, todayStr){
  const p=productById[productId];
  const h = Math.max(0, businessDaysBetween(todayStr, p.eol));
  const safetyDays=3; // 簡易
  const out=STORES.map(s=>{
    const onHand = sum(INVENTORY.filter(i=>i.productId===productId && i.storeId===s.id), i=>i.qty);
    const inbound = 0; // ダミー
    const reserved = 0; // ダミー
    const daily = weightedAvgDaily(productId, s.id, todayStr);
    const safety = daily * safetyDays;
    const demandToEOL = daily * h;
    const netAvail = onHand + inbound - reserved;
    const netNeed = demandToEOL + safety;
    const gap = netAvail - netNeed; // +過剰 / -不足
    return {storeId:s.id, store:s.name, channel:s.channel, daily, h, onHand, inbound, reserved, safety, demandToEOL, netAvail, netNeed, gap};
  });
  return out;
}
// 簡易コスト：店舗インデックス距離 + チャネル差ペナルティ
const storeIndex = Object.fromEntries(STORES.map((s,i)=>[s.id,i]));
function pairCost(srcId, dstId){
  const a = storeIndex[srcId], b = storeIndex[dstId];
  const base = Math.abs(a-b);
  const chA = storeById[srcId].channel, chB = storeById[dstId].channel;
  const chPenalty = (chA===chB)?0:2;
  return base + chPenalty;
}
// ケース入数丸め
const PACK_SIZE=5;
const roundPack = (q)=> Math.max(0, Math.floor(q/ PACK_SIZE)*PACK_SIZE);
// 貪欲移管
function planTransfers(productId, gaps){
  const surplus = gaps.filter(g=>g.gap>0).map(g=>({...g, remain:g.gap}));
  const deficit = gaps.filter(g=>g.gap<0).map(g=>({...g, need:-g.gap}));
  const transfers=[];
  if(surplus.length===0 || deficit.length===0) return {transfers, gapsAfter:gaps};

  // すべての候補組合せをコスト昇順で
  const pairs=[];
  surplus.forEach(s=>{
    deficit.forEach(d=>{
      pairs.push({from:s, to:d, cost:pairCost(s.storeId, d.storeId)});
    });
  });
  pairs.sort((a,b)=>a.cost-b.cost);

  const gapMap = Object.fromEntries(gaps.map(g=>[g.storeId, {...g}])); // mutable copy
  for(const pr of pairs){
    const s = gapMap[pr.from.storeId];
    const d = gapMap[pr.to.storeId];
    if(s.gap<=0 || d.gap>=0) continue;
    let qty = Math.min(s.gap, -d.gap);
    qty = roundPack(qty);
    if(qty<=0) continue;
    transfers.push({productId, from:s.storeId, to:d.storeId, qty});
    s.gap -= qty; d.gap += qty;
    s.onHand -= qty; d.onHand += qty; // 在庫の見なし移動
  }
  const gapsAfter = Object.values(gapMap);
  return {transfers, gapsAfter};
}
// 追加配分（残不足）
function planReplenishments(productId, gapsAfter){
  const deficits = gapsAfter.filter(g=>g.gap<0);
  if(deficits.length===0) return [];
  const totalNeed = sum(deficits, d=>-d.gap);
  // 重み：日販が高い店舗優先
  const totalDaily = sum(deficits, d=>Math.max(d.daily,0.1));
  return deficits.map(d=>{
    const share = totalDaily>0? (Math.max(d.daily,0.1)/totalDaily) : (1/deficits.length);
    let qty = roundPack( Math.ceil(share * totalNeed) );
    if(qty<=0) qty=PACK_SIZE;
    return {productId, storeId:d.storeId, qty};
  });
}
// 値下げプラン（残過剰）
const MD_TIERS=[0, -10, -20, -30]; // %
const SPEED={0:1.0, "-10":1.2, "-20":1.5, "-30":1.9};
function newPrice(base, pct){ return Math.round(base*(100+pct)/100); }
function floorPrice(p){ return Math.round(p.price*0.6); } // 簡易
function planMarkdowns(productId, gapsAfter, todayStr){
  const p=productById[productId];
  const h = Math.max(1, businessDaysBetween(todayStr, p.eol));
  const surpluses = gapsAfter.filter(g=>g.gap>0);
  const out=[];
  surpluses.forEach(s=>{
    for(const pct of MD_TIERS){
      const speed = SPEED[String(pct)];
      const effDaily = Math.max(s.daily*speed, 0.05);
      const canClear = (s.onHand / (effDaily * h)) <= 1.0;
      const candPrice = newPrice(p.price, pct);
      if(candPrice >= floorPrice(p) && canClear){
        out.push({productId, storeId:s.storeId, pct, newPrice:candPrice, reason:`在庫日数調整：${h}営業日で消化`});
        return;
      }
    }
    // どの段でも消化できない→最大割引を提案（★バグ修正：newPrice(p.price, ...)）
    const maxPct = MD_TIERS[MD_TIERS.length-1];
    out.push({productId, storeId:s.storeId, pct:maxPct, newPrice:newPrice(p.price, maxPct), reason:`最大値下でも売切れ難`});
  });
  return out;
}

/* ====== ミニチャート ====== */
const BarMini=({data})=>{
  const [width,height]=[800,240];
  const max=Math.max(...data,1), bw=width/data.length;
  return (<svg width="100%" viewBox={`0 0 ${width} ${height}`} preserveAspectRatio="none">
    {data.map((v,i)=>{ const h=(v/max)*height; const x=i*bw; const y=height-h; return <rect key={i} x={x+1} y={y} width={bw-2} height={h} fill="currentColor" opacity="0.85"/>; })}
  </svg>);
};

/* ====== KPI ====== */
const KPI=({icon,label,value,sub,right})=>(
  <Card elevation={0} variant="outlined"><CardContent>
    <Stack direction="row" justifyContent="space-between" alignItems="center">
      <Stack spacing={0.5}>
        <Stack direction="row" spacing={0.5} alignItems="center"><span className="material-icons">{icon}</span><span className="mini">{label}</span></Stack>
        <Typography variant="h5" className="mono">{value}</Typography>{sub && <span className="mini">{sub}</span>}
      </Stack>
      {right}
    </Stack>
  </CardContent></Card>
);

/* ====== 起票ダイアログ ====== */
function RequestDialog({open,onClose,onSubmit,product,defaultStore,defaultType,defaultQty}){
  const [type,setType]=React.useState(defaultType||'補充');
  const [storeId,setStoreId]=React.useState(defaultStore?.storeId||STORES[0].id);
  const [qty,setQty]=React.useState(defaultQty||0);
  const [neededBy,setNeededBy]=React.useState(()=>{ const t=new Date(); t.setDate(t.getDate()+7); return t.toISOString().slice(0,10); });
  const [reason,setReason]=React.useState(''); const [contact,setContact]=React.useState('');

  React.useEffect(()=>{ setType(defaultType||'補充'); setStoreId(defaultStore?.storeId||STORES[0].id); setQty(defaultQty??0); },[open,defaultType,defaultStore,defaultQty]);

  return (
    <Dialog open={open} onClose={onClose} fullWidth maxWidth="sm">
      <DialogTitle>商品リクエスト</DialogTitle>
      <DialogContent dividers>
        <Grid container spacing={2}>
          <Grid item xs={12} md={4}>
            <TextField select fullWidth size="small" label="種別" value={type} onChange={e=>setType(e.target.value)}>
              <MenuItem value="補充">補充（追加）</MenuItem>
              <MenuItem value="移管">移管</MenuItem>
              <MenuItem value="新規仕入">新規</MenuItem>
              <MenuItem value="値下げ希望">値下</MenuItem>
              <MenuItem value="廃棄">廃棄</MenuItem>
            </TextField>
          </Grid>
          <Grid item xs={12} md={8}>
            <TextField fullWidth size="small" label="商品" value={`${product.name}（${product.sku}）`} InputProps={{readOnly:true}}/>
          </Grid>
          <Grid item xs={12} md={6}>
            <TextField select fullWidth size="small" label="店舗" value={storeId} onChange={e=>setStoreId(e.target.value)}>
              {STORES.map(s=> <MenuItem key={s.id} value={s.id}>{s.name}（{s.channel}）</MenuItem>)}
            </TextField>
          </Grid>
          <Grid item xs={6} md={3}>
            <TextField type="number" size="small" label="数量" value={qty} onChange={e=>setQty(Number(e.target.value)||0)} />
          </Grid>
          <Grid item xs={6} md={3}>
            <TextField type="date" size="small" label="希望日" value={neededBy} onChange={e=>setNeededBy(e.target.value)} InputLabelProps={{shrink:true}}/>
          </Grid>
          <Grid item xs={12}><TextField fullWidth size="small" label="理由 / 備考" value={reason} onChange={e=>setReason(e.target.value)} placeholder="例）週末イベントのため在庫強化／移管元：渋谷店"/></Grid>
          <Grid item xs={12}><TextField fullWidth size="small" label="連絡先" value={contact} onChange={e=>setContact(e.target.value)} placeholder="担当メール/電話"/></Grid>
        </Grid>
      </DialogContent>
      <DialogActions>
        <Button onClick={onClose}>キャンセル</Button>
        <Button variant="contained" onClick={()=>{
          const st=STORES.find(s=>s.id===storeId);
          onSubmit({
            id:'REQ-'+Date.now(), createdAt:new Date().toISOString(), status:'未処理',
            type, productId:product.id, sku:product.sku, productName:product.name,
            storeId:st.id, store:st.name, channel:st.channel,
            qty, neededBy, reason, contact
          });
        }}>登録</Button>
      </DialogActions>
    </Dialog>
  );
}

/* ====== 検索UI ====== */
function ProductSearchPanel({onPick, openModal}){
  const options = PRODUCTS.map(p=> ({ label:`${p.name}｜${p.sku}｜${p.dept}`, value:p.id }));
  const [val,setVal]=React.useState(null);
  const [code,setCode]=React.useState('');

  const jumpByCode=()=>{
    const p = PRODUCTS.find(x=> x.sku.toLowerCase()===code.trim().toLowerCase() || x.id.toLowerCase()===code.trim().toLowerCase());
    if(p){ onPick(p); setVal({label:`${p.name}｜${p.sku}｜${p.dept}`, value:p.id}); }
  };

  return (
    <Paper variant="outlined" sx={{p:1.5}}>
      <Grid container spacing={1} alignItems="center">
        <Grid item xs={12} md={5}>
          <TextField size="small" fullWidth label="コード入力（SKU / ID）" placeholder="例：TSH-001 / P001"
            value={code} onChange={e=>setCode(e.target.value)}
            onKeyDown={e=>{ if(e.key==='Enter') jumpByCode(); }} />
        </Grid>
        <Grid item xs={12} md={5}>
          <Autocomplete
            options={options}
            value={val}
            onChange={(e,newVal)=>{ setVal(newVal); if(newVal) onPick(PRODUCTS.find(p=>p.id===newVal.value)); }}
            renderInput={(params)=><TextField {...params} size="small" label="商品検索（名前・SKU・部門）" />}
            fullWidth clearOnEscape blurOnSelect
          />
        </Grid>
        <Grid item xs={12} md={2}>
          <Button variant="outlined" fullWidth onClick={openModal} startIcon={<span className="material-icons">search</span>}>一覧から探す</Button>
        </Grid>
      </Grid>
    </Paper>
  );
}

/* ====== 商品検索モーダル ====== */
function ProductSearchModal({open,onClose,onPick,from,to,channels,stores,depts}){
  const [keyword,setKeyword]=React.useState('');
  const [dept,setDept]=React.useState('ALL');
  const [sortKey,setSortKey]=React.useState('net_desc');
  const periodDays = daysBetween(from,to);

  const rows = PRODUCTS
    .filter(p=> (dept==='ALL' || p.dept===dept))
    .filter(p=>{
      const k=keyword.trim().toLowerCase();
      if(!k) return true;
      return [p.name,p.sku,p.dept].some(s=> s.toLowerCase().includes(k));
    })
    .map(p=>{
      const r=filterSales({productIds:[p.id],from,to,channels,storeIds:stores,deptSet:depts});
      const net=sum(r,x=>x.net), units=sum(r,x=>x.units);
      const inv=sum(INVENTORY.filter(i=>i.productId===p.id && stores.includes(i.storeId) && channels.includes(storeById[i.storeId].channel)), i=>i.qty);
      const daily=units/(periodDays||1); const dos=daysOfSupply(inv,daily);
      return {p,net,inv,dos};
    })
    .sort((a,b)=>{
      if(sortKey==='net_desc') return b.net-a.net;
      if(sortKey==='dos_asc'){
        const ad=isFinite(a.dos)?a.dos:1e9, bd=isFinite(b.dos)?b.dos:1e9;
        return ad-bd;
      }
      if(sortKey==='name') return a.p.name.localeCompare(b.p.name,'ja');
      return 0;
    });

  const th = { textAlign:'left', padding:8, border:'1px solid #eee' };
  const td = { padding:8, border:'1px solid #eee' };

  return (
    <Dialog open={open} onClose={onClose} fullWidth maxWidth="md">
      <DialogTitle>商品検索</DialogTitle>
      <DialogContent dividers>
        <Grid container spacing={1} alignItems="center">
          <Grid item xs={12} md={5}><TextField size="small" fullWidth label="キーワード（名前 / SKU / 部門）" value={keyword} onChange={e=>setKeyword(e.target.value)}/></Grid>
          <Grid item xs={6} md={3}>
            <TextField select size="small" fullWidth label="部門" value={dept} onChange={e=>setDept(e.target.value)}>
              <MenuItem value="ALL">ALL</MenuItem>
              {DEPTS.map(d=><MenuItem key={d} value={d}>{d}</MenuItem>)}
            </TextField>
          </Grid>
          <Grid item xs={6} md={4}>
            <TextField select size="small" fullWidth label="並び替え" value={sortKey} onChange={e=>setSortKey(e.target.value)}>
              <MenuItem value="net_desc">売上（期間）降順</MenuItem>
              <MenuItem value="dos_asc">在庫日数 昇順</MenuItem>
              <MenuItem value="name">商品名（五十音）</MenuItem>
            </TextField>
          </Grid>
        </Grid>

        <Box mt={2} className="tableWrap">
          <table>
            <thead>
              <tr>
                <th style={th}>SKU</th><th style={th}>商品名</th><th style={th}>部門</th>
                <th style={{...th,textAlign:'right'}}>売上（期間）</th>
                <th style={{...th,textAlign:'right'}}>在庫</th>
                <th style={{...th,textAlign:'right'}}>在庫日数</th>
                <th style={th}>選択</th>
              </tr>
            </thead>
            <tbody>
              {rows.map(({p,net,inv,dos})=>(
                <tr key={p.id}>
                  <td style={td} className="mono">{p.sku}</td>
                  <td style={td}>{p.name}</td>
                  <td style={td}>{p.dept}</td>
                  <td style={{...td,textAlign:'right'}}>{fmtYen(net)}</td>
                  <td style={{...td,textAlign:'right'}}>{inv.toLocaleString()}</td>
                  <td style={{...td,textAlign:'right',color:dos<14?'#c62828':(dos>60?'#ef6c00':'#2e7d32')}}>{isFinite(dos)?Math.round(dos):'∞'}</td>
                  <td style={td}><Button size="small" variant="contained" onClick={()=>{ onPick(p); onClose(); }}>選択</Button></td>
                </tr>
              ))}
            </tbody>
          </table>
        </Box>
      </DialogContent>
      <DialogActions>
        <Button onClick={onClose}>閉じる</Button>
      </DialogActions>
    </Dialog>
  );
}

/* ====== 比較パネル ====== */
function ComparisonPanel({focusProduct, itemMetrics, totalNet, invTotal, dosOverall, markdownDos}){
  return (
    <Paper variant="outlined" sx={{p:1.5}}>
      <b>全体 vs 単品 比較</b>
      <Divider sx={{my:1}}/>
      <Grid container spacing={2}>
        <Grid item xs={12} md={6}>
          <Card variant="outlined"><CardContent>
            <div className="mini" style={{color:'#666'}}>全体（フィルタ適用）</div>
            <Typography variant="h5" className="mono" sx={{mt:0.5}}>{fmtYen(totalNet)}</Typography>
            <div className="mini">在庫 {invTotal.toLocaleString()} 点 ／ 在庫日数 {isFinite(dosOverall)? Math.round(dosOverall):'∞'} 日</div>
          </CardContent></Card>
        </Grid>
        <Grid item xs={12} md={6}>
          {focusProduct ? (
            <Card variant="outlined"><CardContent>
              <div className="mini" style={{color:'#666'}}>単品：{focusProduct.name}（{focusProduct.sku}）</div>
              <Typography variant="h5" className="mono" sx={{mt:0.5}}>{fmtYen(itemMetrics.net)}</Typography>
              <div className="mini">
                在庫 {itemMetrics.inv.toLocaleString()} 点 ／ 在庫日数
                {' '}<b style={{color:itemMetrics.dos<14?'#c62828':(itemMetrics.dos>markdownDos?'#ef6c00':'#2e7d32')}}>
                  {isFinite(itemMetrics.dos)?Math.round(itemMetrics.dos):'∞'}
                </b> 日
              </div>
            </CardContent></Card>
          ) : (
            <Card variant="outlined"><CardContent>
              <div className="mini" style={{color:'#666'}}>単品を検索（または一覧から選択）すると比較を表示します</div>
            </CardContent></Card>
          )}
        </Grid>
      </Grid>
    </Paper>
  );
}

/* ====== 根拠ダイアログ（共通） ====== */
function ReasonDialog({open,onClose,title,rows,notes}) {
  // rows: [{k:'指標', v:'値', sub?:'補足'}]
  const th = { textAlign:'left', padding:8, border:'1px solid #eee', background:'#fafafa' };
  const td = { padding:8, border:'1px solid #eee' };
  return (
    <Dialog open={open} onClose={onClose} fullWidth maxWidth="sm">
      <DialogTitle>{title}</DialogTitle>
      <DialogContent dividers>
        <div className="tableWrap">
          <table style={{width:'100%', borderCollapse:'collapse'}}>
            <thead><tr><th style={th}>指標</th><th style={th}>値</th></tr></thead>
            <tbody>
              {rows.map((r,i)=>(
                <tr key={i}>
                  <td style={td} className="mono">{r.k}</td>
                  <td style={td}>
                    <div>{r.v}</div>
                    {r.sub && <div className="mini" style={{color:'#666'}}>{r.sub}</div>}
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
        {notes && <Box sx={{mt:1}} className="mini" style={{color:'#666'}}>{notes}</Box>}
      </DialogContent>
      <DialogActions>
        <Button onClick={onClose}>閉じる</Button>
      </DialogActions>
    </Dialog>
  );
}

/* ====== アクション（個別展開 + 提案UX + 根拠UI） ====== */
function ActionsPanel({focusProduct, openDialogFromAction, minLot, targetDays, plan}){
  const [openSet,setOpenSet]=React.useState(new Set(['add']));
  const isOpen = (code)=> openSet.has(code);
  const toggleOpen = (code)=> setOpenSet(prev=>{const n=new Set(prev); n.has(code)?n.delete(code):n.add(code); return n;});

  // 各フォーム値（分離）
  const [qtyMap, setQtyMap] = React.useState({ new:10, add:10, move:10, dispose:10 });
  const [storeToMap, setStoreToMap] = React.useState({ new: STORES[0]?.id, add: STORES[0]?.id, markdown: STORES[0]?.id, dispose: STORES[0]?.id, move: STORES[1]?.id });
  const [storeFrom, setStoreFrom] = React.useState(STORES[0]?.id);
  const sel = (id)=> STORES.find(s=>s.id===id);

  const [warnOpen,setWarnOpen]=React.useState(false);
  const ensureProductOrWarn = ()=>{ if(focusProduct) return focusProduct; setWarnOpen(true); return null; };

  const launch = (type,{to,from,qty})=>{
    const product = ensureProductOrWarn(); if(!product) return;
    const preset = { kind:type, store: to? {storeId:to.id, store:to.name, channel:to.channel}: undefined, qty };
    openDialogFromAction(
      type==='移管'
        ? {...preset, kind:'移管', store:{storeId:to.id, store:to.name, channel:to.channel}, qty, note:`移管元：${from?.name}`}
        : preset,
      product
    );
  };

  const ActionHeader = ({code,label,icon,color,children})=>(
    <>
      <Button
        variant={isOpen(code)?'contained':'outlined'}
        color={color||'primary'}
        startIcon={<span className="material-icons">{icon}</span>}
        onClick={()=> toggleOpen(code)}
        sx={{mr:1, mb:1}}
      >
        {label}
      </Button>
      <Collapse in={isOpen(code)} timeout="auto" unmountOnExit>
        <Box sx={{border:'1px solid #eee', borderRadius:1, p:1.5, mb:1}}>
          {children}
        </Box>
      </Collapse>
    </>
  );

  // ===== 提案カード（根拠ボタン付き） =====
  const [reason, setReason] = React.useState({open:false, title:'', rows:[], notes:''});
  const SuggestCard = ({icon,text,cta,onApply,color,onReason})=>(
    <Box sx={{mb:1, p:1, bgcolor:"#f5f5f5", borderRadius:1}}>
      <Stack direction="row" alignItems="center" spacing={1} flexWrap="wrap">
        <span className="material-icons" style={{color:color||'#555'}}>{icon}</span>
        <span className="mini" style={{color:"#444"}} dangerouslySetInnerHTML={{__html:text}} />
        {cta && <Button size="small" sx={{ml:1}} onClick={onApply}>採用</Button>}
        <Button size="small" variant="outlined" onClick={onReason}>根拠を見る</Button>
      </Stack>
    </Box>
  );

  // ===== 提案の「採用」ショートカット =====
  const applyReplenishment = ()=>{
    const r = plan?.replenishments?.[0]; if(!r) return;
    setStoreToMap(prev=>({...prev, add:r.storeId}));
    setQtyMap(prev=>({...prev, add:r.qty}));
  };
  const applyTransfer = ()=>{
    const t = plan?.transfers?.[0]; if(!t) return;
    setStoreFrom(t.from);
    setStoreToMap(prev=>({...prev, move:t.to}));
    setQtyMap(prev=>({...prev, move:t.qty}));
  };
  const applyNew = ()=>{
    const r = plan?.newSuggest; if(!r) return;
    setStoreToMap(prev=>({...prev, new:r.storeId}));
    setQtyMap(prev=>({...prev, new:Math.max(PACK_SIZE, r.qty)}));
  };
  const applyMarkdown = ()=>{
    const m = plan?.markdowns?.[0]; if(!m) return;
    setStoreToMap(prev=>({...prev, markdown:m.storeId}));
  };

  // ===== 根拠の構築（plan と gap 情報から動的生成） =====
  const todayStr = new Date().toISOString().slice(0,10);
  const gaps = React.useMemo(()=>{
    if(!focusProduct) return [];
    return computeGapsForProduct(focusProduct.id, todayStr);
  },[focusProduct, todayStr]);

  const findGap = (storeId)=> gaps.find(g=>g.storeId===storeId);

  const showReplenishmentReason = ()=>{
    const r = plan?.replenishments?.[0]; if(!r) return;
    const g = findGap(r.storeId);
    const rows = [
      {k:'対象店舗', v:`${storeById[r.storeId].name}（${storeById[r.storeId].channel}）`},
      {k:'EOL', v:productById[focusProduct.id].eol},
      {k:'残営業日', v:g?.h ?? '-'},
      {k:'直近日販', v:g? g.daily.toFixed(2) : '-'},
      {k:'需要(EOLまで)', v:g? Math.round(g.demandToEOL).toLocaleString() : '-'},
      {k:'安全在庫(日数×日販)', v:g? Math.round(g.safety).toLocaleString() : '-', sub:'安全在庫=3日×日販（簡易）'},
      {k:'可用在庫', v:g? g.netAvail.toLocaleString() : '-'},
      {k:'ギャップ(可用-需要-安全)', v:g? Math.round(g.gap).toLocaleString() : '-', sub:'マイナスは不足、プラスは過剰'},
      {k:'提案数量', v:`${r.qty} 点`, sub:`ケース入数(${PACK_SIZE})に丸め`}
    ];
    setReason({open:true, title:'補充提案の根拠', rows, notes:'不足量を各店舗の日販に比例配分し、ケース入数で丸め（ダミー・簡易算出）'});
  };

  const showNewReason = ()=>{
    const r = plan?.newSuggest; if(!r) return;
    const g = findGap(r.storeId);
    const rows = [
      {k:'対象店舗', v:`${storeById[r.storeId].name}（${storeById[r.storeId].channel}）`},
      {k:'EOL', v:productById[focusProduct.id].eol},
      {k:'残営業日', v:g?.h ?? '-'},
      {k:'直近日販', v:g? g.daily.toFixed(2) : '-'},
      {k:'需要(EOLまで)+安全', v:g? Math.round(g.netNeed).toLocaleString() : '-'},
      {k:'可用在庫', v:g? g.netAvail.toLocaleString() : '-'},
      {k:'ギャップ', v:g? Math.round(g.gap).toLocaleString() : '-'},
      {k:'提案数量', v:`${r.qty} 点`, sub:`不足最大店舗に対しケース丸め（簡易）`}
    ];
    setReason({open:true, title:'新規仕入提案の根拠', rows, notes:'在庫ネットワークで不足が残る場合の新規手当て（ダミー）'});
  };

  const showTransferReason = ()=>{
    const t = plan?.transfers?.[0]; if(!t) return;
    const gs = findGap(t.from), gd = findGap(t.to);
    const rows = [
      {k:'経路', v:`${storeById[t.from].name} → ${storeById[t.to].name}`},
      {k:'コスト指標', v:`${pairCost(t.from, t.to)}（距離+チャネル差ペナルティ）`},
      {k:'移管数量', v:`${t.qty} 点`, sub:`ケース入数(${PACK_SIZE})に丸め`},
      {k:'移管元ギャップ(前)', v: gs? Math.round(gs.gap + t.qty).toLocaleString() : '-', sub:'過剰(+)／不足(-)'},
      {k:'移管先ギャップ(前)', v: gd? Math.round(gd.gap - t.qty).toLocaleString() : '-'},
      {k:'EOL/残営業日', v:`${productById[focusProduct.id].eol} / ${gd?.h ?? '-'}`},
      {k:'日販(元/先)', v:`${gs? gs.daily.toFixed(2):'-'} / ${gd? gd.daily.toFixed(2):'-'}`},
    ];
    setReason({open:true, title:'移管提案の根拠', rows, notes:'過剰→不足を優先し、簡易コスト昇順で貪欲割当（ダミー）'});
  };

  const showMarkdownReason = ()=>{
    const m = plan?.markdowns?.[0]; if(!m) return;
    const g = findGap(m.storeId);
    const p = productById[focusProduct.id];
    const h = g?.h ?? '-';
    const speed = SPEED[String(m.pct)];
    const effDaily = g? (g.daily*speed).toFixed(2) : '-';
    const canClear = g? (g.onHand/(Math.max(g.daily*speed,0.05)*Math.max(h,1))<=1) : false;
    const rows = [
      {k:'対象店舗', v:`${storeById[m.storeId].name}（${storeById[m.storeId].channel}）`},
      {k:'EOL/残営業日', v:`${p.eol} / ${h}`},
      {k:'現状日販', v:g? g.daily.toFixed(2) : '-'},
      {k:'割引率', v:`${m.pct}%`, sub:`速度倍率=${speed}`},
      {k:'想定日販(値下後)', v:`${effDaily}`},
      {k:'在庫 / (想定日販×残営業日)', v: g? `${g.onHand} / (${effDaily}×${h}) = ${(g.onHand/(Math.max(g.daily*speed,0.05)*Math.max(h,1))).toFixed(2)}`:'-',
        sub: '≤ 1 なら売り切れる見込み'},
      {k:'新価格(参考)', v: `${fmtYen(Math.round(p.price*(100+m.pct)/100))}`, sub:`フロア=${fmtYen(Math.round(p.price*0.6))}`},
      {k:'判定', v: canClear? 'この割引で消化見込み' : '最大割引でも難'}
    ];
    setReason({open:true, title:'値下提案の根拠', rows, notes:'速度倍率はダミー表（0%:1.0, -10%:1.2, -20%:1.5, -30%:1.9）で試算'});
  };

  return (
    <Paper variant="outlined" sx={{p:1.5}}>
      <Stack direction="row" justifyContent="space-between" alignItems="center">
        <b>アクション</b>
        <span className="mini" style={{color:'#666'}}>提案はEOL・日販ベースの簡易ロジック（ダミー）。根拠で計算内訳を確認できます。</span>
      </Stack>
      <Divider sx={{my:1}}/>

      {/* 新規 */}
      <ActionHeader code="new" label="新規" icon="fiber_new">
        <SuggestCard
          icon="lightbulb"
          color="#6a1b9a"
          text={`需要予測・発注支援：<b>${plan?.newSuggest?.qty ?? '-'}点 推奨</b>（${plan?.newSuggest? `店舗 ${storeById[plan.newSuggest.storeId].name}`:'-' }）`}
          cta onApply={applyNew}
          onReason={showNewReason}
        />
        <Grid container spacing={1} alignItems="center">
          <Grid item xs={12} md={5}>
            <TextField select size="small" fullWidth label="納入先店舗"
              value={storeToMap.new}
              onChange={e=>setStoreToMap(prev=>({...prev, new:e.target.value}))}>
              {STORES.map(s=> <MenuItem key={s.id} value={s.id}>{s.name}（{s.channel}）</MenuItem>)}
            </TextField>
          </Grid>
          <Grid item xs={8} md={3}>
            <TextField size="small" label="数量" type="number" fullWidth
              value={qtyMap.new}
              onChange={e=>setQtyMap(prev=>({...prev, new:Number(e.target.value)||0}))}/>
          </Grid>
          <Grid item xs={4} md={2}>
            <Button variant="contained" fullWidth
              onClick={()=>launch('新規仕入',{to:sel(storeToMap.new),qty:qtyMap.new})}>起票</Button>
          </Grid>
        </Grid>
      </ActionHeader>

      {/* 追加（補充） */}
      <ActionHeader code="add" label="追加（補充）" icon="add_shopping_cart">
        <SuggestCard
          icon="auto_fix_high"
          color="#1565c0"
          text={`自動補充提案：<b>${plan?.replenishments?.[0]?.qty ?? '-'}点</b>（店舗：${plan?.replenishments?.[0]? storeById[plan.replenishments[0].storeId].name : '-'}）`}
          cta onApply={applyReplenishment}
          onReason={showReplenishmentReason}
        />
        <Grid container spacing={1} alignItems="center">
          <Grid item xs={12} md={5}>
            <TextField select size="small" fullWidth label="対象店舗"
              value={storeToMap.add}
              onChange={e=>setStoreToMap(prev=>({...prev, add:e.target.value}))}>
              {STORES.map(s=> <MenuItem key={s.id} value={s.id}>{s.name}（{s.channel}）</MenuItem>)}
            </TextField>
          </Grid>
          <Grid item xs={8} md={3}>
            <TextField size="small" label="数量" type="number" fullWidth
              value={qtyMap.add}
              onChange={e=>setQtyMap(prev=>({...prev, add:Number(e.target.value)||0}))}/>
          </Grid>
          <Grid item xs={4} md={2}>
            <Button variant="contained" fullWidth
              onClick={()=>launch('補充',{to:sel(storeToMap.add),qty:qtyMap.add})}>起票</Button>
          </Grid>
        </Grid>
      </ActionHeader>

      {/* 移管 */}
      <ActionHeader code="move" label="移管" icon="swap_horiz">
        <SuggestCard
          icon="moving"
          color="#2e7d32"
          text={`自動移管提案：<b>${plan?.transfers?.[0]?.qty ?? '-'}点</b>（${plan?.transfers?.[0]? `${storeById[plan.transfers[0].from].name} → ${storeById[plan.transfers[0].to].name}`:'-' }）`}
          cta onApply={applyTransfer}
          onReason={showTransferReason}
        />
        <Grid container spacing={1} alignItems="center">
          <Grid item xs={12} md={4}>
            <TextField select size="small" fullWidth label="移管元"
              value={storeFrom}
              onChange={e=>setStoreFrom(e.target.value)}>
              {STORES.map(s=> <MenuItem key={s.id} value={s.id}>{s.name}（{s.channel}）</MenuItem>)}
            </TextField>
          </Grid>
          <Grid item xs={12} md={4}>
            <TextField select size="small" fullWidth label="移管先"
              value={storeToMap.move}
              onChange={e=>setStoreToMap(prev=>({...prev, move:e.target.value}))}>
              {STORES.map(s=> <MenuItem key={s.id} value={s.id}>{s.name}（{s.channel}）</MenuItem>)}
            </TextField>
          </Grid>
          <Grid item xs={8} md={2}>
            <TextField size="small" label="数量" type="number" fullWidth
              value={qtyMap.move}
              onChange={e=>setQtyMap(prev=>({...prev, move:Number(e.target.value)||0}))}/>
          </Grid>
          <Grid item xs={4} md={2}>
            <Button variant="contained" fullWidth
              onClick={()=>launch('移管',{to:sel(storeToMap.move),from:sel(storeFrom),qty:qtyMap.move})}>起票</Button>
          </Grid>
        </Grid>
      </ActionHeader>

      {/* 値下 */}
      <ActionHeader code="markdown" label="値下" icon="sell" color="secondary">
        <SuggestCard
          icon="price_change"
          color="#8e24aa"
          text={`自動値下提案：<b>${plan?.markdowns?.[0]? plan.markdowns[0].pct : '-'}%</b>（店舗：${plan?.markdowns?.[0]? storeById[plan.markdowns[0].storeId].name : '-'}）`}
          cta onApply={applyMarkdown}
          onReason={showMarkdownReason}
        />
        <Grid container spacing={1} alignItems="center">
          <Grid item xs={12} md={6}>
            <TextField select size="small" fullWidth label="対象店舗"
              value={storeToMap.markdown}
              onChange={e=>setStoreToMap(prev=>({...prev, markdown:e.target.value}))}>
              {STORES.map(s=> <MenuItem key={s.id} value={s.id}>{s.name}（{s.channel}）</MenuItem>)}
            </TextField>
          </Grid>
          <Grid item xs={12} md={3}>
            <TextField size="small" fullWidth label="目安（%や金額はダイアログで記入）" value="" placeholder="例：20%など" InputProps={{readOnly:true}}/>
          </Grid>
          <Grid item xs={12} md={2}>
            <Button variant="outlined" fullWidth
              onClick={()=>launch('値下げ希望',{to:sel(storeToMap.markdown)})}>起票</Button>
          </Grid>
        </Grid>
      </ActionHeader>

      {/* 根拠ダイアログ */}
      <ReasonDialog
        open={reason.open}
        onClose={()=>setReason(prev=>({...prev, open:false}))}
        title={reason.title}
        rows={reason.rows}
        notes={reason.notes}
      />

      {/* 未選択注意 */}
      <Snackbar open={warnOpen} autoHideDuration={1600} onClose={()=>setWarnOpen(false)} anchorOrigin={{vertical:'bottom',horizontal:'center'}}>
        <Alert severity="warning" variant="filled">商品を選択してください（上部の検索/一覧から選べます）</Alert>
      </Snackbar>
    </Paper>
  );
}

/* ====== CSV / Todo / Event（簡略：そのまま） ====== */
function TodoPanel(){
  const [rows,setRows]=React.useState(TODOS);
  const [title,setTitle]=React.useState('');
  const add=()=>{ if(!title.trim()) return; const next=[...rows,{id:Date.now(),title,owner:'商品部',due:new Date().toISOString().slice(0,10),done:false}]; setRows(next); TODOS=next; setTitle(''); };
  const toggle=(id)=>{ const next=rows.map(r=> r.id===id? {...r,done:!r.done}:r); setRows(next); TODOS=next; };
  const del=(id)=>{ const next=rows.filter(r=>r.id!==id); setRows(next); TODOS=next; };
  return (
    <Paper variant="outlined" sx={{p:1.5}}>
      <b>やることリスト</b>
      <Divider sx={{my:1}}/>
      <Stack spacing={1}>
        {rows.map(r=>(
          <Paper key={r.id} variant="outlined" sx={{p:1}}>
            <Stack direction="row" alignItems="center" justifyContent="space-between">
              <Stack direction="row" spacing={1} alignItems="center">
                <Checkbox size="small" checked={r.done} onChange={()=>toggle(r.id)}/>
                <div>{r.title}</div>
              </Stack>
              <span className="mini" style={{color:'#666'}}>{r.owner}｜期限 {r.due}</span>
            </Stack>
            <Box textAlign="right"><Button size="small" onClick={()=>del(r.id)}>削除</Button></Box>
          </Paper>
        ))}
        <Stack direction="row" spacing={1}>
          <TextField size="small" fullWidth placeholder="タスク追加（例：P002 ECサイト 値下げ判断）" value={title} onChange={e=>setTitle(e.target.value)}/>
          <Button variant="contained" onClick={add}>追加</Button>
        </Stack>
      </Stack>
    </Paper>
  );
}
function EventPanel(){
  const [rows,setRows]=React.useState(EVENTS);
  const [title,setTitle]=React.useState('');
  const [date,setDate]=React.useState(()=>new Date().toISOString().slice(0,10));
  const add=()=>{ if(!title.trim()) return; const next=[...rows,{id:Date.now(),title,date,owner:'システム管理運用'}]; setRows(next); EVENTS=next; setTitle(''); };
  const del=(id)=>{ const next=rows.filter(r=>r.id!==id); setRows(next); EVENTS=next; };
  return (
    <Paper variant="outlined" sx={{p:1.5}}>
      <b>イベントリスト</b>
      <Divider sx={{my:1}}/>
      <Stack spacing={1}>
        {rows.map(r=>(
          <Paper key={r.id} variant="outlined" sx={{p:1}}>
            <Stack direction="row" justifyContent="space-between" alignItems="center">
              <div>{r.title}</div>
              <span className="mini" style={{color:'#666'}}>{r.date}｜{r.owner}</span>
            </Stack>
            <Box textAlign="right"><Button size="small" onClick={()=>del(r.id)}>削除</Button></Box>
          </Paper>
        ))}
        <Stack direction="row" spacing={1} alignItems="center">
          <TextField size="small" fullWidth placeholder="イベント名（例：販促キャンペーン開始）" value={title} onChange={e=>setTitle(e.target.value)}/>
          <TextField size="small" type="date" value={date} onChange={e=>setDate(e.target.value)}/>
          <Button variant="contained" onClick={add}>追加</Button>
        </Stack>
      </Stack>
    </Paper>
  );
}
function CSVPanel({onSales,onInv}){
  return (
    <Paper variant="outlined" sx={{p:1.5}}>
      <b>CSV読み込み</b><Divider sx={{my:1}}/>
      <Stack direction="row" spacing={1} flexWrap="wrap" alignItems="center">
        <Button variant="outlined" component="label" startIcon={<span className="material-icons">file_upload</span>}>
          売上CSV<input type="file" hidden accept=".csv" onChange={(e)=>e.target.files[0] && onSales(e.target.files[0])}/>
        </Button>
        <Button variant="outlined" component="label" startIcon={<span className="material-icons">inventory_2</span>}>
          在庫CSV<input type="file" hidden accept=".csv" onChange={(e)=>e.target.files[0] && onInv(e.target.files[0])}/>
        </Button>
        <span className="mini" style={{color:'#666'}}>売上CSV: productId,storeId,date,units,net / 在庫CSV: productId,storeId,qty</span>
      </Stack>
    </Paper>
  );
}

/* ====== メイン ====== */
function App(){
  const today=new Date(); const d=n=>{const t=new Date(today); t.setDate(t.getDate()-n); return t.toISOString().slice(0,10);};

  const [mode,setMode]=React.useState('infographic');
  const [focusProduct,setFocusProduct]=React.useState(null);

  /* 条件フィルタ */
  const [from,setFrom]=React.useState(d(28));
  const [to,setTo]=React.useState(d(0));
  const [channels,setChannels]=React.useState(CHANNELS);
  const [stores,setStores]=React.useState(STORES.map(s=>s.id));
  const [depts,setDepts]=React.useState(DEPTS);

  /* 閾値 */
  const [targetDays,setTargetDays]=React.useState(21);
  const [markdownDos,setMarkdownDos]=React.useState(60);
  const [minLot,setMinLot]=React.useState(5);

  /* 集計（既存） */
  const productScope = focusProduct? [focusProduct.id] : null;
  const rowsAll = React.useMemo(()=> filterSales({ productIds: productScope, from,to,channels,storeIds:stores,deptSet:depts }), [focusProduct,from,to,channels,stores,depts]);
  const byStore=React.useMemo(()=> aggregateByStore(rowsAll),[rowsAll]);
  const byCh=React.useMemo(()=> aggregateByChannel(rowsAll),[rowsAll]);
  const totalUnits=sum(rowsAll,r=>r.units), totalNet=sum(rowsAll,r=>r.net);
  const invTotal = focusProduct
    ? sum(INVENTORY.filter(i=>i.productId===focusProduct.id && stores.includes(i.storeId) && channels.includes(storeById[i.storeId].channel)), i=>i.qty)
    : sum(INVENTORY.filter(i=> stores.includes(i.storeId) && channels.includes(storeById[i.storeId].channel) && depts.includes(productById[i.productId].dept)), i=>i.qty);
  const dailyTotal = sum(aggregateByStore(rowsAll), s=>avgDaily(s.units,s.days||1));
  const dosOverall = dailyTotal>0 ? invTotal/dailyTotal : Infinity;
  const trendSeriesMoney = React.useMemo(()=> calcTrendSeries(productScope,channels,stores,depts,to), [productScope,channels,stores,depts,to]);
  const periodDays = daysBetween(from,to);

  const itemMetrics = React.useMemo(()=> {
    if(!focusProduct) return {units:0,net:0,inv:0,daily:0,dos:Infinity};
    const r=filterSales({productIds:[focusProduct.id],from,to,channels,storeIds:stores,deptSet:depts});
    const units=sum(r,x=>x.units), net=sum(r,x=>x.net);
    const inv = sum(INVENTORY.filter(i=>i.productId===focusProduct.id && stores.includes(i.storeId) && channels.includes(storeById[i.storeId].channel)), i=>i.qty);
    const daily = units/(periodDays||1); const dos=daysOfSupply(inv,daily);
    return {units,net,inv,daily,dos};
  },[focusProduct,from,to,channels,stores,depts,periodDays]);

  /* ====== EOLロジックに基づく計画生成 ====== */
  const [plan,setPlan]=React.useState(null);
  const recomputePlan = React.useCallback(()=>{
    if(!focusProduct){ setPlan(null); return; }
    const todayStr = new Date().toISOString().slice(0,10);
    // 1) ギャップ
    let gaps = computeGapsForProduct(focusProduct.id, todayStr);
    // 2) 移管
    const {transfers, gapsAfter} = planTransfers(focusProduct.id, gaps);
    // 3) 追加
    const replenishments = planReplenishments(focusProduct.id, gapsAfter);
    // 4) 値下
    const markdowns = planMarkdowns(focusProduct.id, gapsAfter, todayStr);
    // 5) 新規（簡易：不足の最大店舗へ同じロジックで）
    const def = gapsAfter.filter(g=>g.gap<0).sort((a,b)=>a.gap-b.gap)[0];
    const newSuggest = def ? {storeId:def.storeId, qty: roundPack(Math.ceil(-def.gap))} : null;
    setPlan({gaps, transfers, replenishments, markdowns, newSuggest});
  },[focusProduct]);

  React.useEffect(()=>{ recomputePlan(); },[recomputePlan, focusProduct, from, to, channels, stores, depts]);

  /* 起票 */
  const [snack,setSnack]=React.useState(false);
  const addRequest=(payload)=>{ REQUESTS=[payload,...REQUESTS]; setSnack(true); };

  /* CSV */
  const loadSalesCSV=f=>{ const r=new FileReader(); r.onload=()=>{ const lines=r.result.split(/\r?\n/).filter(Boolean);
    SALES=lines.slice(1).map(l=>{ const [productId,storeId,date,units,net]=l.split(','); return {productId,storeId,date,units:Number(units),net:Number(net)};}); alert('売上CSVを読み込みました'); recomputePlan(); };
    r.readAsText(f,'utf-8'); };
  const loadInvCSV=f=>{ const r=new FileReader(); r.onload=()=>{ const lines=r.result.split(/\r?\n/).filter(Boolean);
    INVENTORY=lines.slice(1).map(l=>{ const [productId,storeId,qty]=l.split(','); return {productId,storeId,qty:Number(qty)};}); alert('在庫CSVを読み込みました'); recomputePlan(); };
    r.readAsText(f,'utf-8'); };

  /* ダイアログ */
  const [dlgOpen,setDlgOpen]=React.useState(false);
  const [dlgPreset,setDlgPreset]=React.useState({});
  const openDialogFromAction=(a, product)=>{
    setDlgPreset({ defaultType:a.kind, defaultStore:a.store||a.to||a.from, defaultQty:a.qty, productOverride: product });
    setDlgOpen(true);
  };

  /* 検索モーダル */
  const [searchOpen,setSearchOpen]=React.useState(false);

  /* テーブル共通スタイル */
  const th = { textAlign:'left', padding:8, border:'1px solid #eee' };
  const td = { padding:8, border:'1px solid #eee' };

  /* パンくず（商品一覧の直前に配置） */
  const Breadcrumbs = (
    <Box className="crumb" sx={{mt:2, mb:1}}>
      <span className="material-icons" style={{fontSize:16}}>home</span> サマリー
      {focusProduct && (<>
        <span className="material-icons" style={{fontSize:16}}>chevron_right</span>
        <b>{focusProduct.name}</b>
        <Button size="small" onClick={()=>setFocusProduct(null)}>戻る</Button>
      </>)}
      {focusProduct && (
        <Button size="small" variant="outlined" sx={{ml:1}} startIcon={<span className="material-icons">refresh</span>} onClick={recomputePlan}>
          計画を再計算
        </Button>
      )}
    </Box>
  );

  /* 単品詳細（店舗別） */
  const ItemStoreBlock = focusProduct ? (()=>{
    const todayStr = new Date().toISOString().slice(0,10);
    const gaps = computeGapsForProduct(focusProduct.id, todayStr);
    return (
      <Paper variant="outlined" sx={{p:1.5}}>
        <Stack direction="row" justifyContent="space-between" alignItems="center">
          <b>単品詳細（店舗別）：{focusProduct.name}（{focusProduct.sku}）｜EOL {productById[focusProduct.id].eol}</b>
          <span className="mini" style={{color:'#666'}}>ギャップ=可用在庫 - (EOLまでの需要+安全)</span>
        </Stack>
        <Divider sx={{my:1}}/>
        <div className="tableWrap">
          <table>
            <thead><tr>
              <th style={th}>店舗</th><th style={th}>チャネル</th>
              <th style={{...th,textAlign:'right'}}>日販</th><th style={{...th,textAlign:'right'}}>残営業日</th>
              <th style={{...th,textAlign:'right'}}>可用在庫</th><th style={{...th,textAlign:'right'}}>需要(EOL)</th><th style={{...th,textAlign:'right'}}>安全在庫</th>
              <th style={{...th,textAlign:'right'}}>ギャップ</th>
            </tr></thead>
            <tbody>
              {gaps.map(s=>(
                <tr key={s.storeId}>
                  <td style={td}>{s.store}</td><td style={td}>{s.channel}</td>
                  <td style={{...td,textAlign:'right'}}>{s.daily.toFixed(2)}</td>
                  <td style={{...td,textAlign:'right'}}>{s.h}</td>
                  <td style={{...td,textAlign:'right'}}>{s.netAvail.toLocaleString()}</td>
                  <td style={{...td,textAlign:'right'}}>{Math.round(s.demandToEOL).toLocaleString()}</td>
                  <td style={{...td,textAlign:'right'}}>{Math.round(s.safety).toLocaleString()}</td>
                  <td style={{...td,textAlign:'right', color: s.gap<0?'#c62828':'#2e7d32'}}>{Math.round(s.gap).toLocaleString()}</td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      </Paper>
    );
  })() : null;

  /* 商品一覧 */
  const ProductListBlock = (
    <Paper variant="outlined" sx={{p:1.5}}>
      <Stack direction="row" gap={1} alignItems="center"><span className="material-icons">list_alt</span><b>商品一覧（フィルタ適用）</b></Stack>
      <Divider sx={{my:1}}/>
      <div className="tableWrap">
        <table>
          <thead>
            <tr>
              <th style={th}>SKU</th><th style={th}>商品名</th><th style={th}>部門</th>
              <th style={{...th,textAlign:'right'}}>売上</th><th style={{...th,textAlign:'right'}}>在庫</th><th style={{...th,textAlign:'right'}}>EOL</th>
            </tr>
          </thead>
          <tbody>
            {PRODUCTS.filter(p=>depts.includes(p.dept)).map(p=>{
              const r=filterSales({productIds:[p.id],from,to,channels,storeIds:stores,deptSet:depts});
              const net=sum(r,x=>x.net);
              const inv=sum(INVENTORY.filter(i=>i.productId===p.id && stores.includes(i.storeId) && channels.includes(storeById[i.storeId].channel)), i=>i.qty);
              return (
                <tr key={p.id} className="rowHover" onClick={()=>setFocusProduct(p)}>
                  <td style={td} className="mono">{p.sku}</td>
                  <td style={td}>{p.name}</td>
                  <td style={td}>{p.dept}</td>
                  <td style={{...td,textAlign:'right'}}>{fmtYen(net)}</td>
                  <td style={{...td,textAlign:'right'}}>{inv.toLocaleString()}</td>
                  <td style={{...td,textAlign:'right'}}>{p.eol}</td>
                </tr>
              );
            })}
          </tbody>
        </table>
      </div>
    </Paper>
  );

  /* チャネル別/店舗別（詳細モード） */
  const ChannelBlock = (
    <Paper variant="outlined" sx={{p:1.5}}>
      <b>チャネル別</b><Divider sx={{my:1}}/>
      <div className="tableWrap">
        <table>
          <thead><tr><th style={th}>チャネル</th><th style={{...th,textAlign:'right'}}>販売数</th><th style={{...th,textAlign:'right'}}>売上</th><th style={{...th,textAlign:'right'}}>店舗数</th></tr></thead>
          <tbody>{byCh.map(r=>(
            <tr key={r.channel}><td style={td}>{r.channel}</td><td style={{...td,textAlign:'right'}}>{r.units.toLocaleString()}</td><td style={{...td,textAlign:'right'}}>{fmtYen(r.net)}</td><td style={{...td,textAlign:'right'}}>{r.stores}</td></tr>
          ))}</tbody>
        </table>
      </div>
    </Paper>
  );
  const StoreBlock = (
    <Paper variant="outlined" sx={{p:1.5}}>
      <b>店舗別</b><Divider sx={{my:1}}/>
      <div className="tableWrap">
        <table>
          <thead><tr>
            <th style={th}>店舗</th><th style={th}>チャネル</th>
            <th style={{...th,textAlign:'right'}}>販売数</th><th style={{...th,textAlign:'right'}}>売上</th>
            <th style={{...th,textAlign:'right'}}>在庫</th><th style={{...th,textAlign:'right'}}>日販</th><th style={{...th,textAlign:'right'}}>在庫日数</th>
          </tr></thead>
          <tbody>
            {aggregateByStore(rowsAll).map(s=>{
              const daily=avgDaily(s.units,s.days||1), dos=daysOfSupply(s.inv,daily);
              return (
                <tr key={s.storeId}>
                  <td style={td}>{s.store}</td><td style={td}>{s.channel}</td>
                  <td style={{...td,textAlign:'right'}}>{s.units.toLocaleString()}</td>
                  <td style={{...td,textAlign:'right'}}>{fmtYen(s.net)}</td>
                  <td style={{...td,textAlign:'right'}}>{s.inv.toLocaleString()}</td>
                  <td style={{...td,textAlign:'right'}}>{daily.toFixed(2)}</td>
                  <td style={{...td,textAlign:'right'}}>{isFinite(dos)?Math.round(dos):'∞'}</td>
                </tr>
              );
            })}
          </tbody>
        </table>
      </div>
    </Paper>
  );

  return (
    <>
      {/* ヘッダー */}
      <AppBar position="static" color="inherit" elevation={0}>
        <Toolbar className="wrap">
          <span className="material-icons" style={{marginRight:8}}>insights</span>
          <Typography variant="h6" sx={{flexGrow:1}}>商品ダッシュボード</Typography>
          <ToggleButtonGroup exclusive size="small" value={mode} onChange={(e,v)=> v && setMode(v)}>
            <ToggleButton value="infographic"><span className="material-icons" style={{fontSize:16,marginRight:4}}>dashboard</span>Infographic</ToggleButton>
            <ToggleButton value="detail"><span className="material-icons" style={{fontSize:16,marginRight:4}}>table_view</span>Detail</ToggleButton>
          </ToggleButtonGroup>
        </Toolbar>
      </AppBar>

      <div className="wrap">
        {/* 条件パネル */}
        <Paper variant="outlined" sx={{p:1.5, mb:2}}>
          <Stack direction="row" gap={1} alignItems="center" flexWrap="wrap">
            <span className="pill"><span className="material-icons" style={{fontSize:16}}>event</span>
              <input type="date" value={from} onChange={e=>setFrom(e.target.value)}/>〜
              <input type="date" value={to} onChange={e=>setTo(e.target.value)}/>
            </span>
            <span className="pill">
              {CHANNELS.map(ch=>{
                const on=channels.includes(ch);
                return <Chip key={ch} label={ch} variant={on?'filled':'outlined'} size="small"
                  onClick={()=> setChannels(prev=> on? prev.filter(x=>x!==ch): [...prev, ch]) } sx={{mr:0.5}}/>;
              })}
            </span>
            <span className="pill">
              <span className="mini">部門</span>
              {DEPTS.map(dp=>{
                const on=depts.includes(dp);
                return <Chip key={dp} label={dp} variant={on?'filled':'outlined'} size="small"
                  onClick={()=> setDepts(prev=> on? prev.filter(x=>x!==dp): [...prev, dp]) } sx={{mr:0.5}}/>;
              })}
            </span>
            <span className="pill">
              <span className="mini">店舗</span>
              {STORES.map(s=>{
                const on=stores.includes(s.id);
                return <Chip key={s.id} label={s.name} variant={on?'filled':'outlined'} size="small"
                  onClick={()=> setStores(prev=> on? prev.filter(x=>x!==s.id): [...prev, s.id]) } sx={{mr:0.5}}/>;
              })}
            </span>
          </Stack>
        </Paper>

        {/* 検索 */}
        <ProductSearchPanel onPick={p=>setFocusProduct(p)} openModal={()=>setSearchOpen(true)}/>
        <ProductSearchModal
          open={searchOpen} onClose={()=>setSearchOpen(false)} onPick={p=>setFocusProduct(p)}
          from={from} to={to} channels={channels} stores={stores} depts={depts}
        />

        {/* KPI */}
        <div className="cards" style={{marginBottom:16}}>
          <KPI icon="sell" label="売上（期間）" value={fmtYen(totalNet)} sub={`${totalUnits.toLocaleString()} 点`}/>
          <KPI icon="inventory_2" label="在庫合計" value={`${invTotal.toLocaleString()} 点`}/>
          <KPI icon="speed" label="在庫日数（全体）" value={isFinite(dosOverall)?`${Math.round(dosOverall)} 日`:'∞'}/>
          <KPI icon="flag" label="基準" value={`在庫日数 目標 ${targetDays}日`} sub={`値下げ判定 ${markdownDos}日／最小ロット ${minLot}`}/>
        </div>

        {/* グラフ */}
        <Paper variant="outlined" className="vh35" sx={{p:1.5, mb:2}}>
          <Stack direction="row" justifyContent="space-between" alignItems="center">
            <Stack direction="row" gap={1} alignItems="center">
              <span className="material-icons">query_stats</span><b>売上推移（14日）</b>
            </Stack>
            <span className="mini" style={{color:'#666'}}>{from} 〜 {to}</span>
          </Stack>
          <Divider sx={{my:1}}/>
          <BarMini data={trendSeriesMoney}/>
        </Paper>

        {/* 比較 */}
        <ComparisonPanel
          focusProduct={focusProduct}
          itemMetrics={itemMetrics}
          totalNet={totalNet}
          invTotal={invTotal}
          dosOverall={dosOverall}
          markdownDos={markdownDos}
        />

        {/* ★ パンくず（商品一覧直前） */}
        {Breadcrumbs}

        {/* 商品一覧 */}
        {ProductListBlock}

        {/* 単品（店舗別ギャップ） */}
        {ItemStoreBlock}

        {/* アクション：EOL計画に基づく提案付き＋根拠ダイアログ */}
        <ActionsPanel
          focusProduct={focusProduct}
          openDialogFromAction={(a,product)=>{ setDlgPreset({ defaultType:a.kind, defaultStore:a.store||a.to||a.from, defaultQty:a.qty, productOverride: product }); setDlgOpen(true); }}
          minLot={minLot}
          targetDays={targetDays}
          plan={plan}
        />

        {/* コラボ */}
        <TodoPanel/>
        <EventPanel/>

        {/* CSV */}
        <CSVPanel onSales={loadSalesCSV} onInv={loadInvCSV}/>

        {/* 詳細モード（イベントリストの下に配置） */}
        {mode==='detail' && (
          <Box sx={{mt:2}}>
            {ChannelBlock}
            {StoreBlock}
          </Box>
        )}


      </div>

      {/* 起票ダイアログ / 通知 */}
      <RequestDialog
        open={dlgOpen}
        onClose={()=>setDlgOpen(false)}
        onSubmit={(req)=>{ REQUESTS=[req,...REQUESTS]; setDlgOpen(false); setSnack(true); }}
        product={dlgPreset.productOverride || focusProduct || PRODUCTS[0]}
        defaultStore={dlgPreset.defaultStore}
        defaultType={dlgPreset.defaultType}
        defaultQty={dlgPreset.defaultQty}
      />
      <Snackbar open={snack} autoHideDuration={1200} onClose={()=>setSnack(false)} anchorOrigin={{vertical:'bottom',horizontal:'center'}}>
        <Alert severity="success" variant="filled">リクエストを登録しました（このセッション内のみ保存）</Alert>
      </Snackbar>
    </>
  );
}

const root=ReactDOM.createRoot(document.getElementById('root'));
root.render(<App/>);
</script>
</body>
</html>
