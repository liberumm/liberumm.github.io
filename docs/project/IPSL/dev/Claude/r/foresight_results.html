<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>å®Ÿç¸¾ãƒ†ãƒ¼ãƒ–ãƒ«ï¼ˆã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆé¢¨ã‚¹ã‚¿ã‚¤ãƒ«ï¼‰</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <!-- Roboto & MUI -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" />
  <!-- React, ReactDOM, Babel -->
  <script src="https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.production.min.js" crossorigin></script>
  <script src="https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://cdn.jsdelivr.net/npm/@babel/standalone@7.23.8/babel.min.js"></script>
  <!-- Emotion (MUIä¾å­˜) -->
  <script src="https://cdn.jsdelivr.net/npm/@emotion/react@11.11.3/dist/emotion-react.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@emotion/styled@11.11.0/dist/emotion-styled.umd.min.js"></script>
  <!-- MUI Core -->
  <script src="https://cdn.jsdelivr.net/npm/@mui/material@5.15.3/umd/material-ui.production.min.js" crossorigin></script>
  <style>
    /* ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œã®åŸºæœ¬ã‚¹ã‚¿ã‚¤ãƒ« */
    @media (max-width: 600px) {
      .MuiBox-root {
        padding: 8px !important;
      }
      .MuiTableContainer-root {
        max-width: 100vw;
      }
      .MuiTabs-root {
        max-width: 100%;
        overflow-x: auto;
      }
      .MuiToggleButtonGroup-root {
        flex-wrap: wrap;
      }
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useMemo, useEffect } = React;
    const {
      Box,
      Chip,
      Typography,
      TableContainer,
      Table,
      TableHead,
      TableBody,
      TableRow,
      TableCell,
      TextField,
      Tabs,
      Tab,
      ToggleButton,
      ToggleButtonGroup,
      Paper
    } = MaterialUI;

    // ---------- å®šç¾©ç³» ----------

    // å•†å“éšå±¤ãƒ¬ãƒ™ãƒ«å®šç¾©ï¼ˆå…¨éƒ¨é–€ã‚’è¿½åŠ ï¼‰
    const PRODUCT_LEVELS = ["å…¨éƒ¨é–€", "éƒ¨é–€", "ã‚³ãƒ¼ãƒŠãƒ¼", "ãƒ©ã‚¤ãƒ³", "ã‚«ãƒ†ã‚´ãƒª", "ã‚¢ã‚¤ãƒ†ãƒ ", "SKU"];
    // æ‹ ç‚¹éšå±¤ãƒ¬ãƒ™ãƒ«å®šç¾©ï¼ˆå…¨åº—èˆ—ã‚’è¿½åŠ ï¼‰
    const SITE_LEVELS = ["å…¨åº—èˆ—", "äº‹æ¥­", "ãƒ–ãƒ­ãƒƒã‚¯", "åº—èˆ—"];

    // è¡¨ç¤ºã™ã‚‹ãƒ¡ãƒˆãƒªãƒƒã‚¯ä¸€è¦§
    const METRICS = ["å£²ä¸Š", "å€¤ä¸‹", "å€¤ä¸Š", "ãƒ­ã‚¹", "å£²ä¸Šç·åˆ©ç›Š", "æœŸæœ«åœ¨åº«"];

    // é›†è¨ˆå˜ä½ã®é¸æŠè‚¢ï¼ˆ"ã‚«ã‚¹ã‚¿ãƒ "å«ã‚€ï¼‰
    const AGGREGATION_UNITS = ["å¹´", "æœˆ", "é€±", "æ—¥", "æ™‚é–“", "åŠæœŸ", "å››åŠæœŸ", "ã‚«ã‚¹ã‚¿ãƒ "];

    // ---------- æœŸé–“ãƒ©ãƒ™ãƒ«ç”Ÿæˆ ----------
    function generatePeriodLabels(startDateStr, endDateStr, unit) {
      const labels = [];
      const start = new Date(startDateStr);
      const end = new Date(endDateStr);

      if (isNaN(start) || isNaN(end) || start > end) {
        return { labels, periodCount: 0 };
      }

      switch (unit) {
        case "å¹´": {
          let year = start.getFullYear();
          const endYear = end.getFullYear();
          for (; year <= endYear; year++) {
            labels.push(String(year));
          }
          break;
        }
        case "æœˆ": {
          let current = new Date(start.getFullYear(), start.getMonth(), 1);
          while (current <= end) {
            labels.push(`${current.getFullYear()}/${current.getMonth() + 1}`);
            current.setMonth(current.getMonth() + 1);
          }
          break;
        }
        case "é€±": {
          let current = new Date(start);
          let w = 1;
          while (current <= end) {
            labels.push(`W${w}`);
            w++;
            current.setDate(current.getDate() + 7);
          }
          break;
        }
        case "æ—¥":
        case "ã‚«ã‚¹ã‚¿ãƒ ": {
          let current = new Date(start);
          while (current <= end) {
            labels.push(`${current.getMonth() + 1}/${current.getDate()}`);
            current.setDate(current.getDate() + 1);
          }
          break;
        }
        case "æ™‚é–“": {
          let current = new Date(start);
          while (current <= end) {
            labels.push(
              `${current.getMonth() + 1}/${current.getDate()} ${current.getHours()}æ™‚`
            );
            current.setHours(current.getHours() + 1);
          }
          break;
        }
        case "åŠæœŸ": {
          const startYear = start.getFullYear();
          const endYear = end.getFullYear();
          for (let y = startYear; y <= endYear; y++) {
            const h1Start = new Date(y, 0, 1);
            const h1End   = new Date(y, 5, 30);
            if (h1End >= start && h1Start <= end) {
              labels.push(`${y}ä¸ŠåŠæœŸ`);
            }
            const h2Start = new Date(y, 6, 1);
            const h2End   = new Date(y, 11, 31);
            if (h2End >= start && h2Start <= end) {
              labels.push(`${y}ä¸‹åŠæœŸ`);
            }
          }
          break;
        }
        case "å››åŠæœŸ": {
          const startYear = start.getFullYear();
          const endYear = end.getFullYear();
          for (let y = startYear; y <= endYear; y++) {
            // Q1
            const q1Start = new Date(y, 0, 1);
            const q1End   = new Date(y, 2, 31); // 3/31
            if (q1End >= start && q1Start <= end) {
              labels.push(`${y} Q1`);
            }
            // Q2
            const q2Start = new Date(y, 3, 1);
            const q2End   = new Date(y, 5, 30);
            if (q2End >= start && q2Start <= end) {
              labels.push(`${y} Q2`);
            }
            // Q3
            const q3Start = new Date(y, 6, 1);
            const q3End   = new Date(y, 8, 30);
            if (q3End >= start && q3Start <= end) {
              labels.push(`${y} Q3`);
            }
            // Q4
            const q4Start = new Date(y, 9, 1);
            const q4End   = new Date(y, 11, 31);
            if (q4End >= start && q4Start <= end) {
              labels.push(`${y} Q4`);
            }
          }
          break;
        }
        default:
          break;
      }

      return { labels, periodCount: labels.length };
    }

    // ---------- ãƒ¡ãƒˆãƒªãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ & é›†è¨ˆ ----------

    function generateRandomMetricsData(periodCount) {
      const data = {};
      METRICS.forEach(metric => {
        data[metric] = Array.from({ length: periodCount }, () => Math.floor(Math.random() * 100));
      });
      return data;
    }

    function createEmptyMetricsData(periodCount) {
      const emptyData = {};
      METRICS.forEach(metric => {
        emptyData[metric] = new Array(periodCount).fill(0);
      });
      return emptyData;
    }

    function aggregateNode(node, periodCount) {
      // å¿…ãšç©ºãƒ‡ãƒ¼ã‚¿ã‚’åˆæœŸåŒ–
      if (!node.data) {
        node.data = createEmptyMetricsData(periodCount);
      }

      if (!node.children || node.children.length === 0) {
        // æœ«ç«¯ãƒãƒ¼ãƒ‰
        return node.data;
      }

      // å­ãƒãƒ¼ãƒ‰ã‚’åˆè¨ˆ
      let sumData = createEmptyMetricsData(periodCount);
      node.children.forEach(child => {
        const childData = aggregateNode(child, periodCount);
        for (const metric of METRICS) {
          for (let i = 0; i < periodCount; i++) {
            sumData[metric][i] += childData[metric][i];
          }
        }
      });
      node.data = sumData;

      // åˆè¨ˆãƒãƒ¼ãƒ‰ãªã‚‰ã€siblings ã‚‚åŠ ç®—
      if (node.isTotal && node.parent) {
        const siblings = node.parent.children.filter(n => !n.isTotal);
        siblings.forEach(sibling => {
          if (!sibling.data) {
            sibling.data = createEmptyMetricsData(periodCount);
          }
          for (const metric of METRICS) {
            for (let i = 0; i < periodCount; i++) {
              node.data[metric][i] += sibling.data[metric][i];
            }
          }
        });
      }
      return node.data;
    }

    // ---------- éšå±¤ãƒ„ãƒªãƒ¼ç”Ÿæˆ ----------

    function createProductHierarchy(periodCount) {
      const depts = [];
      for (let d = 1; d <= 3; d++) {
        const dept = { name: `éƒ¨é–€${d}`, level: "éƒ¨é–€", children: [] };
        for (let c = 1; c <= 3; c++) {
          const corner = { name: `éƒ¨é–€${d} ã‚³ãƒ¼ãƒŠãƒ¼${c}`, level: "ã‚³ãƒ¼ãƒŠãƒ¼", children: [] };
          for (let l = 1; l <= 4; l++) {
            const line = { name: `éƒ¨é–€${d} ã‚³ãƒ¼ãƒŠãƒ¼${c} ãƒ©ã‚¤ãƒ³${l}`, level: "ãƒ©ã‚¤ãƒ³", children: [] };
            for (let cat = 1; cat <= 3; cat++) {
              const category = {
                name: `éƒ¨é–€${d} ã‚³ãƒ¼ãƒŠãƒ¼${c} ãƒ©ã‚¤ãƒ³${l} ã‚«ãƒ†ã‚´ãƒª${cat}`,
                level: "ã‚«ãƒ†ã‚´ãƒª",
                children: []
              };
              for (let i = 1; i <= 3; i++) {
                const item = {
                  name: `éƒ¨é–€${d} ã‚³ãƒ¼ãƒŠãƒ¼${c} ãƒ©ã‚¤ãƒ³${l} ã‚«ãƒ†ã‚´ãƒª${cat} ã‚¢ã‚¤ãƒ†ãƒ ${i}`,
                  level: "ã‚¢ã‚¤ãƒ†ãƒ ",
                  children: []
                };
                for (let s = 1; s <= 2; s++) {
                  const sku = {
                    name: `éƒ¨é–€${d} ã‚³ãƒ¼ãƒŠãƒ¼${c} ãƒ©ã‚¤ãƒ³${l} ã‚«ãƒ†ã‚´ãƒª${cat} ã‚¢ã‚¤ãƒ†ãƒ ${i} SKU${s}`,
                    level: "SKU",
                    children: [],
                    data: generateRandomMetricsData(periodCount)
                  };
                  item.children.push(sku);
                }
                category.children.push(item);
              }
              line.children.push(category);
            }
            corner.children.push(line);
          }
          dept.children.push(corner);
        }
        depts.push(dept);
      }
      // åˆè¨ˆãƒãƒ¼ãƒ‰
      const totalDept = {
        name: "å…¨éƒ¨é–€åˆè¨ˆ",
        level: "éƒ¨é–€",
        children: [],
        isTotal: true
      };
      depts.push(totalDept);
      return depts;
    }

    function createSiteHierarchy(periodCount) {
      const businesses = [];
      for (let b = 1; b <= 2; b++) {
        const biz = { name: `äº‹æ¥­${b}`, level: "äº‹æ¥­", children: [] };
        for (let bl = 1; bl <= 3; bl++) {
          const block = { name: `äº‹æ¥­${b} ãƒ–ãƒ­ãƒƒã‚¯${bl}`, level: "ãƒ–ãƒ­ãƒƒã‚¯", children: [] };
          for (let s = 1; s <= 3; s++) {
            const store = {
              name: `äº‹æ¥­${b} ãƒ–ãƒ­ãƒƒã‚¯${bl} åº—èˆ—${s}`,
              level: "åº—èˆ—",
              children: [],
              data: generateRandomMetricsData(periodCount)
            };
            block.children.push(store);
          }
          biz.children.push(block);
        }
        businesses.push(biz);
      }
      // åˆè¨ˆãƒãƒ¼ãƒ‰
      const totalBiz = {
        name: "å…¨åº—èˆ—åˆè¨ˆ",
        level: "äº‹æ¥­",
        children: [],
        isTotal: true
      };
      businesses.push(totalBiz);

      return businesses;
    }

    function attachParentReference(nodes, parent) {
      nodes.forEach(node => {
        node.parent = parent;
        if (node.children) {
          attachParentReference(node.children, node);
        }
      });
    }

    // ---------- ãƒ¡ã‚¤ãƒ³ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ ----------

    const App = () => {
      const [startDate, setStartDate] = useState("2023-01-01");
      const [endDate, setEndDate] = useState("2025-12-31");
      const [aggregationUnit, setAggregationUnit] = useState("å¹´");

      // æœŸé–“ãƒ©ãƒ™ãƒ«
      const { labels, periodCount } = useMemo(() => {
        return generatePeriodLabels(startDate, endDate, aggregationUnit);
      }, [startDate, endDate, aggregationUnit]);

      // å•†å“éšå±¤ãƒ„ãƒªãƒ¼
      const productHierarchy = useMemo(() => {
        const tree = createProductHierarchy(periodCount);
        attachParentReference(tree, null);
        tree.forEach(node => aggregateNode(node, periodCount));
        return tree;
      }, [periodCount]);

      // æ‹ ç‚¹éšå±¤ãƒ„ãƒªãƒ¼
      const siteHierarchy = useMemo(() => {
        const tree = createSiteHierarchy(periodCount);
        attachParentReference(tree, null);
        tree.forEach(node => aggregateNode(node, periodCount));
        return tree;
      }, [periodCount]);

      const [productLevel, setProductLevel] = useState("éƒ¨é–€");
      const [siteLevel, setSiteLevel] = useState("äº‹æ¥­");
      const [selectedProductNodes, setSelectedProductNodes] = useState([]);
      const [selectedSiteNodes, setSelectedSiteNodes] = useState([]);
      const [selectedMetrics, setSelectedMetrics] = useState(METRICS);

      // åˆæœŸåŒ–
      useEffect(() => {
        if (productHierarchy.length > 0) {
          const initialNodes = findNodesByLevel(productHierarchy, productLevel);
          setSelectedProductNodes(initialNodes);
        }
      }, [productHierarchy]);

      useEffect(() => {
        if (siteHierarchy.length > 0) {
          const initialNodes = findNodesByLevel(siteHierarchy, siteLevel);
          setSelectedSiteNodes(initialNodes);
        }
      }, [siteHierarchy]);

      function findNodesByLevel(nodes, level, parentNodes = null) {
        const result = [];
        const traverse = (node) => {
          if (node.level === level) {
            result.push(node);
          } else if (node.children) {
            node.children.forEach(traverse);
          }
        };
        if (parentNodes && parentNodes.length > 0) {
          parentNodes.forEach(parent => traverse(parent));
        } else {
          nodes.forEach(traverse);
        }
        return result;
      }

      const handleProductLevelChange = (newLevel) => {
        setProductLevel(newLevel);
        const newLevelIdx = PRODUCT_LEVELS.indexOf(newLevel);
        // ä¸‹éšå±¤ã‚’ã‚¯ãƒªã‚¢
        setSelectedProductNodes(prev =>
          prev.filter(node => PRODUCT_LEVELS.indexOf(node.level) <= newLevelIdx)
        );
      };

      const handleSiteLevelChange = (newLevel) => {
        setSiteLevel(newLevel);
        const newLevelIdx = SITE_LEVELS.indexOf(newLevel);
        // ä¸‹éšå±¤ã‚’ã‚¯ãƒªã‚¢
        setSelectedSiteNodes(prev =>
          prev.filter(node => SITE_LEVELS.indexOf(node.level) <= newLevelIdx)
        );
      };

      // é¸æŠå¯èƒ½ãƒãƒ¼ãƒ‰
      const availableProductNodes = useMemo(() => {
        const currentLevelIdx = PRODUCT_LEVELS.indexOf(productLevel);
        // å…¨éƒ¨é–€ã‚¿ãƒ–ã®å ´åˆã¯å…¨éƒ¨é–€åˆè¨ˆã®ã¿ã‚’è¡¨ç¤º
        if (productLevel === "å…¨éƒ¨é–€") {
          return productHierarchy.filter(node => node.isTotal);
        }
        if (currentLevelIdx <= 0) {
          return findNodesByLevel(productHierarchy, productLevel).filter(node => !node.isTotal);
        }
        const parentLevel = PRODUCT_LEVELS[currentLevelIdx - 1];
        const parentNodes = selectedProductNodes.filter(n => n.level === parentLevel);
        return findNodesByLevel(productHierarchy, productLevel, parentNodes).filter(node => !node.isTotal);
      }, [productHierarchy, productLevel, selectedProductNodes]);

      const availableSiteNodes = useMemo(() => {
        const currentLevelIdx = SITE_LEVELS.indexOf(siteLevel);
        // å…¨åº—èˆ—ã‚¿ãƒ–ã®å ´åˆã¯å…¨åº—èˆ—åˆè¨ˆã®ã¿ã‚’è¡¨ç¤º
        if (siteLevel === "å…¨åº—èˆ—") {
          return siteHierarchy.filter(node => node.isTotal);
        }
        if (currentLevelIdx <= 0) {
          return findNodesByLevel(siteHierarchy, siteLevel).filter(node => !node.isTotal);
        }
        const parentLevel = SITE_LEVELS[currentLevelIdx - 1];
        const parentNodes = selectedSiteNodes.filter(n => n.level === parentLevel);
        return findNodesByLevel(siteHierarchy, siteLevel, parentNodes).filter(node => !node.isTotal);
      }, [siteHierarchy, siteLevel, selectedSiteNodes]);

      // ãƒ†ãƒ¼ãƒ–ãƒ«æ–¹å‘
      const [periodOnXAxis, setPeriodOnXAxis] = useState(true);
      // æ‹ ç‚¹ãƒ»å•†å“ã®åˆ—é †åºï¼ˆtrue: æ‹ ç‚¹â†’å•†å“, false: å•†å“â†’æ‹ ç‚¹ï¼‰
      const [siteFirstOrder, setSiteFirstOrder] = useState(true);

      // ãƒ”ãƒœãƒƒãƒˆè¨­å®š
      const [pivotConfig, setPivotConfig] = useState({
        rows: ['site'],           // è¡Œé…ç½®: site, product, period ã‹ã‚‰é¸æŠ
        columns: ['period'],      // åˆ—é…ç½®: site, product, period ã‹ã‚‰é¸æŠ
        measures: selectedMetrics, // é›†è¨ˆé …ç›®
        sort: {
          site: 'asc',           // asc, desc
          product: 'asc',
          period: 'asc'
        }
      });

      // é †åºå¤‰æ›´ã®ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
      const handleOrderChange = (type, oldIndex, newIndex) => {
        setPivotConfig(prev => {
          const list = type === 'rows' ? prev.rows : prev.columns;
          const result = [...list];
          const [removed] = result.splice(oldIndex, 1);
          result.splice(newIndex, 0, removed);
          return {
            ...prev,
            [type]: result
          };
        });
      };

      // ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ç”¨ã®ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
      const handleDragStart = (e, type, index) => {
        e.dataTransfer.setData('text/plain', JSON.stringify({ type, index }));
      };

      const handleDragOver = (e) => {
        e.preventDefault();
      };

      const handleDrop = (e, type, index) => {
        e.preventDefault();
        const data = JSON.parse(e.dataTransfer.getData('text/plain'));
        if (data.type === type) {
          handleOrderChange(type, data.index, index);
        }
      };

      // ãƒ”ãƒœãƒƒãƒˆUIç”¨ã®è¨­å®šé …ç›®
      const PIVOT_DIMENSIONS = [
        { id: 'site', label: 'æ‹ ç‚¹', icon: 'ğŸ¢' },
        { id: 'product', label: 'å•†å“', icon: 'ğŸ“¦' },
        { id: 'period', label: 'æœŸé–“', icon: 'ğŸ“…' }
      ];

      // ã‚¯ãƒ­ã‚¹ãƒ‡ãƒ¼ã‚¿
      const crossData = useMemo(() => {
        const actualProductLevel = (productLevel === "å…¨éƒ¨é–€") ? "éƒ¨é–€" : productLevel;
        const actualSiteLevel = (siteLevel === "å…¨åº—èˆ—") ? "äº‹æ¥­" : siteLevel;

        const currentProductNodes = selectedProductNodes.filter(
          node => node.level === actualProductLevel
        );
        const currentSiteNodes = selectedSiteNodes.filter(
          node => node.level === actualSiteLevel
        );
        if (currentProductNodes.length === 0 || currentSiteNodes.length === 0) {
          return [];
        }

        // ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆæ™‚ã«ã‚½ãƒ¼ãƒˆ
        const sortedProductNodes = [...currentProductNodes].sort((a, b) => a.name.localeCompare(b.name));
        const sortedSiteNodes = [...currentSiteNodes].sort((a, b) => a.name.localeCompare(b.name));

        const list = [];
        const primary = siteFirstOrder ? sortedSiteNodes : sortedProductNodes;
        const secondary = siteFirstOrder ? sortedProductNodes : sortedSiteNodes;

        primary.forEach(p => {
          secondary.forEach(s => {
            list.push({
              product: siteFirstOrder ? s : p,
              site: siteFirstOrder ? p : s,
              data: (siteFirstOrder ? s : p).data
            });
          });
        });

        return list;
      }, [selectedProductNodes, selectedSiteNodes, productLevel, siteLevel, siteFirstOrder]);

      // ã‚«ãƒ©ãƒ ï¼šæœŸé–“ã‚’Xè»¸
      const columnsWhenPeriodOnX = useMemo(() => {
        const cols = [];
        selectedMetrics.forEach(metric => {
          labels.forEach((_, idx) => {
            cols.push({ metric, periodIndex: idx });
          });
        });
        return cols;
      }, [labels, selectedMetrics]);

      // ã‚«ãƒ©ãƒ ï¼šæœŸé–“ã‚’Yè»¸
      const columnsWhenPeriodOnY = useMemo(() => {
        const cols = [];
        crossData.forEach((combo, cIdx) => {
          selectedMetrics.forEach(metric => {
            cols.push({ combinationIndex: cIdx, metric });
          });
        });
        return cols;
      }, [crossData, selectedMetrics]);

      // ãƒ†ãƒ¼ãƒ–ãƒ«æç”»ç”¨ã®ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
      const renderPivotTableCell = (content, isHeader = false) => (
        <TableCell
          component={isHeader ? "th" : "td"}
          sx={{
            whiteSpace: 'normal',
            wordBreak: 'break-word',
            minWidth: 120,
            backgroundColor: isHeader ? '#e3f2fd' : 'inherit',
            fontWeight: isHeader ? 'bold' : 'normal',
            color: isHeader ? '#1976d2' : 'inherit'
          }}
        >
          {content}
        </TableCell>
      );

      // ãƒ”ãƒœãƒƒãƒˆç”¨ãƒ‡ãƒ¼ã‚¿åŠ å·¥
      const pivotData = useMemo(() => {
        const items = {
          site: selectedSiteNodes,
          product: selectedProductNodes,
          period: labels.map((label, index) => ({ label, index }))
        };

        // è¡Œãƒ»åˆ—ã‚­ãƒ¼ã®ç”Ÿæˆ
        const rows = [];
        const generateRows = (current = [], depth = 0) => {
          if (depth === pivotConfig.rows.length) {
            rows.push(current);
            return;
          }
          const dim = pivotConfig.rows[depth];
          items[dim].forEach(item => {
            generateRows([...current, { type: dim, ...item }], depth + 1);
          });
        };
        generateRows();

        const columns = [];
        const generateColumns = (current = [], depth = 0) => {
          if (depth === pivotConfig.columns.length) {
            columns.push(current);
            return;
          }
          const dim = pivotConfig.columns[depth];
          items[dim].forEach(item => {
            generateColumns([...current, { type: dim, ...item }], depth + 1);
          });
        };
        generateColumns();

        // ã‚½ãƒ¼ãƒˆé–¢æ•°
        const sortItems = (a, b, type) => {
          const direction = pivotConfig.sort[type] === 'asc' ? 1 : -1;
          if (type === 'period') {
            return (a.index - b.index) * direction;
          }
          return a.name.localeCompare(b.name) * direction;
        };

        // ã‚­ãƒ¼ã®ã‚½ãƒ¼ãƒˆ
        rows.sort((a, b) => {
          for (let i = 0; i < a.length; i++) {
            const result = sortItems(a[i], b[i], a[i].type);
            if (result !== 0) return result;
          }
          return 0;
        });

        columns.sort((a, b) => {
          for (let i = 0; i < a.length; i++) {
            const result = sortItems(a[i], b[i], a[i].type);
            if (result !== 0) return result;
          }
          return 0;
        });

        return { rows, columns };
      }, [pivotConfig, selectedSiteNodes, selectedProductNodes, labels]);

      // ãƒ†ãƒ¼ãƒ–ãƒ«æç”»
      const renderPivotTable = () => {
        const getLabel = (item) => item.name || item.label;
        const getValue = (row, col, metric) => {
          const elements = [...row, ...col];
          const product = elements.find(e => e.type === 'product');
          const period = elements.find(e => e.type === 'period');
          if (product?.data?.[metric] && period) {
            return product.data[metric][period.index];
          }
          return '-';
        };

        return (
          <Table stickyHeader size="small" sx={{/* ...existing styles... */}}>
            <TableHead>
              <TableRow>
                {pivotConfig.rows.length > 0 && (
                  <TableCell
                    colSpan={pivotConfig.rows.length}
                    rowSpan={2}
                    sx={{
                      backgroundColor: '#e3f2fd',
                      fontWeight: 'bold',
                      color: '#1976d2'
                    }}
                  >
                    {pivotConfig.rows.map(dim => 
                      PIVOT_DIMENSIONS.find(d => d.id === dim)?.label
                    ).join(' / ')}
                  </TableCell>
                )}
                {pivotData.columns.map((col, idx) => (
                  <TableCell
                    key={idx}
                    colSpan={selectedMetrics.length}
                    align="center"
                    sx={{
                      backgroundColor: '#e3f2fd',
                      fontWeight: 'bold',
                      color: '#1976d2'
                    }}
                  >
                    {col.map(getLabel).join(' / ')}
                  </TableCell>
                ))}
              </TableRow>
              <TableRow>
                {pivotData.columns.map((col, colIdx) =>
                  selectedMetrics.map((metric, metricIdx) => 
                    renderPivotTableCell(metric, true)
                  )
                )}
              </TableRow>
            </TableHead>
            <TableBody>
              {pivotData.rows.map((row, rowIdx) => (
                <TableRow key={rowIdx}>
                  {row.map((item, i) => renderPivotTableCell(getLabel(item)))}
                  {pivotData.columns.map((col, colIdx) =>
                    selectedMetrics.map(metric => 
                      renderPivotTableCell(getValue(row, col, metric))
                    )
                  )}
                </TableRow>
              ))}
            </TableBody>
          </Table>
        );
      };

      // ---------- æç”» ----------
      return (
        <Box sx={{ 
          p: { xs: 1, sm: 2 },
          fontFamily: 'Roboto',
          '& .MuiTextField-root': {
            width: { xs: '100%', sm: 'auto' }
          },
          '& .MuiBox-root': {
            flexDirection: { xs: 'column', sm: 'row' }
          }
        }}>
          <Typography variant="h6" gutterBottom>
            å®Ÿç¸¾ãƒ†ãƒ¼ãƒ–ãƒ«ï¼ˆã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆé¢¨ï¼‰
          </Typography>

          {/* (1) å‚ç…§æœŸé–“ */}
          <Box sx={{ mb: 2 }}>
            <Typography variant="subtitle1">å‚ç…§æœŸé–“</Typography>
            <Box sx={{ display: 'flex', gap: 2, mt: 1 }}>
              <TextField
                label="é–‹å§‹æ—¥"
                type="date"
                InputLabelProps={{ shrink: true }}
                value={startDate}
                onChange={(e) => setStartDate(e.target.value)}
              />
              <TextField
                label="çµ‚äº†æ—¥"
                type="date"
                InputLabelProps={{ shrink: true }}
                value={endDate}
                onChange={(e) => setEndDate(e.target.value)}
              />
            </Box>
          </Box>

          {/* (2) é›†è¨ˆå˜ä½ */}
          <Box sx={{ mb: 2 }}>
            <Typography variant="subtitle1">é›†è¨ˆå˜ä½</Typography>
            <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1, mt: 1 }}>
              {AGGREGATION_UNITS.map(unit => (
                <Chip
                  key={unit}
                  label={unit}
                  color={aggregationUnit === unit ? "primary" : "default"}
                  onClick={() => setAggregationUnit(unit)}
                />
              ))}
            </Box>
          </Box>

          {/* (3) å•†å“åˆ†é¡è»¸ */}
          <Box sx={{ mb: 2 }}>
            <Typography variant="subtitle1">å•†å“åˆ†é¡è»¸</Typography>
            <Tabs
              value={productLevel}
              onChange={(_, newValue) => handleProductLevelChange(newValue)}
            >
              {PRODUCT_LEVELS.map(level => (
                <Tab key={level} value={level} label={level} />
              ))}
            </Tabs>
            <Box sx={{ mt: 1 }}>
              <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1, mt: 0.5 }}>
                {availableProductNodes.map(node => (
                  <Chip
                    key={node.name}
                    label={node.name}
                    color={selectedProductNodes.includes(node) ? "primary" : "default"}
                    onClick={() => {
                      setSelectedProductNodes(prev =>
                        prev.includes(node)
                          ? prev.filter(n => n !== node)
                          : [...prev, node]
                      );
                    }}
                  />
                ))}
              </Box>
            </Box>
          </Box>

          {/* (4) æ‹ ç‚¹åˆ†é¡è»¸ */}
          <Box sx={{ mb: 2 }}>
            <Typography variant="subtitle1">æ‹ ç‚¹åˆ†é¡è»¸</Typography>
            <Tabs
              value={siteLevel}
              onChange={(_, newValue) => handleSiteLevelChange(newValue)}
            >
              {SITE_LEVELS.map(level => (
                <Tab key={level} value={level} label={level} />
              ))}
            </Tabs>
            <Box sx={{ mt: 1 }}>
              <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1, mt: 0.5 }}>
                {availableSiteNodes.map(node => (
                  <Chip
                    key={node.name}
                    label={node.name}
                    color={selectedSiteNodes.includes(node) ? "primary" : "default"}
                    onClick={() => {
                      setSelectedSiteNodes(prev =>
                        prev.includes(node)
                          ? prev.filter(n => n !== node)
                          : [...prev, node]
                      );
                    }}
                  />
                ))}
              </Box>
            </Box>
          </Box>

          {/* (5) è¡¨ç¤ºãƒ¡ãƒˆãƒªãƒƒã‚¯ */}
          <Box sx={{ mb: 2 }}>
            <Typography variant="subtitle1">è¡¨ç¤ºãƒ¡ãƒˆãƒªãƒƒã‚¯</Typography>
            <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1, mt: 1 }}>
              {METRICS.map(metric => (
                <Chip
                  key={metric}
                  label={metric}
                  color={selectedMetrics.includes(metric) ? "primary" : "default"}
                  onClick={() => {
                    setSelectedMetrics(prev =>
                      prev.includes(metric)
                        ? prev.filter(m => m !== metric)
                        : [...prev, metric]
                    );
                  }}
                />
              ))}
            </Box>
          </Box>

          {/* ãƒ”ãƒœãƒƒãƒˆè¨­å®šUI */}
          <Box sx={{ mb: 2 }}>
            <Typography variant="subtitle1">ãƒ”ãƒœãƒƒãƒˆè¨­å®š</Typography>
            <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2, p: 2, border: '1px solid #ccc', borderRadius: 1 }}>
              {/* è¡Œè¨­å®š */}
              <Box>
                <Typography variant="subtitle2">è¡Œã®é…ç½®ï¼ˆãƒ‰ãƒ©ãƒƒã‚°ã§é †åºå¤‰æ›´å¯èƒ½ï¼‰</Typography>
                <Box sx={{ display: 'flex', gap: 1, mt: 1 }}>
                  {PIVOT_DIMENSIONS.map(dim => (
                    <Chip
                      key={dim.id}
                      label={`${dim.icon} ${dim.label}`}
                      color={pivotConfig.rows.includes(dim.id) ? "primary" : "default"}
                      onClick={() => {
                        setPivotConfig(prev => ({
                          ...prev,
                          rows: prev.rows.includes(dim.id)
                            ? prev.rows.filter(r => r !== dim.id)
                            : [...prev.rows, dim.id],
                          // è¡Œã«è¿½åŠ ã—ãŸæ¬¡å…ƒã‚’åˆ—ã‹ã‚‰å‰Šé™¤
                          columns: prev.columns.filter(c => c !== dim.id)
                        }));
                      }}
                    />
                  ))}
                </Box>
                <Box sx={{ 
                  display: 'flex', 
                  gap: 1, 
                  mt: 1,
                  p: 1,
                  border: '1px dashed #ccc',
                  borderRadius: 1,
                  minHeight: 40
                }}>
                  {pivotConfig.rows.map((dimId, index) => {
                    const dim = PIVOT_DIMENSIONS.find(d => d.id === dimId);
                    return (
                      <Chip
                        key={dimId}
                        label={`${dim.icon} ${dim.label}`}
                        color="primary"
                        draggable
                        onDragStart={(e) => handleDragStart(e, 'rows', index)}
                        onDragOver={handleDragOver}
                        onDrop={(e) => handleDrop(e, 'rows', index)}
                        sx={{ cursor: 'move' }}
                      />
                    );
                  })}
                </Box>
              </Box>

              {/* åˆ—è¨­å®š */}
              <Box>
                <Typography variant="subtitle2">åˆ—ã®é…ç½®ï¼ˆãƒ‰ãƒ©ãƒƒã‚°ã§é †åºå¤‰æ›´å¯èƒ½ï¼‰</Typography>
                <Box sx={{ display: 'flex', gap: 1, mt: 1 }}>
                  {PIVOT_DIMENSIONS.map(dim => (
                    <Chip
                      key={dim.id}
                      label={`${dim.icon} ${dim.label}`}
                      color={pivotConfig.columns.includes(dim.id) ? "primary" : "default"}
                      onClick={() => {
                        setPivotConfig(prev => ({
                          ...prev,
                          columns: prev.columns.includes(dim.id)
                            ? prev.columns.filter(c => c !== dim.id)
                            : [...prev.columns, dim.id],
                          // åˆ—ã«è¿½åŠ ã—ãŸæ¬¡å…ƒã‚’è¡Œã‹ã‚‰å‰Šé™¤
                          rows: prev.rows.filter(r => r !== dim.id)
                        }));
                      }}
                    />
                  ))}
                </Box>
                <Box sx={{ 
                  display: 'flex', 
                  gap: 1, 
                  mt: 1,
                  p: 1,
                  border: '1px dashed #ccc',
                  borderRadius: 1,
                  minHeight: 40
                }}>
                  {pivotConfig.columns.map((dimId, index) => {
                    const dim = PIVOT_DIMENSIONS.find(d => d.id === dimId);
                    return (
                      <Chip
                        key={dimId}
                        label={`${dim.icon} ${dim.label}`}
                        color="primary"
                        draggable
                        onDragStart={(e) => handleDragStart(e, 'columns', index)}
                        onDragOver={handleDragOver}
                        onDrop={(e) => handleDrop(e, 'columns', index)}
                        sx={{ cursor: 'move' }}
                      />
                    );
                  })}
                </Box>
              </Box>

              {/* ä¸¦ã³é †è¨­å®š */}
              <Box>
                <Typography variant="subtitle2">ä¸¦ã³é †</Typography>
                <Box sx={{ display: 'flex', gap: 2, mt: 1 }}>
                  {PIVOT_DIMENSIONS.map(dim => (
                    <ToggleButtonGroup
                      key={dim.id}
                      size="small"
                      value={pivotConfig.sort[dim.id]}
                      exclusive
                      onChange={(_, value) => {
                        if (value) {
                          setPivotConfig(prev => ({
                            ...prev,
                            sort: { ...prev.sort, [dim.id]: value }
                          }));
                        }
                      }}
                    >
                      <ToggleButton value="asc" aria-label="æ˜‡é †">
                        {dim.icon} â†‘
                      </ToggleButton>
                      <ToggleButton value="desc" aria-label="é™é †">
                        {dim.icon} â†“
                      </ToggleButton>
                    </ToggleButtonGroup>
                  ))}
                </Box>
              </Box>
            </Box>
          </Box>

          {/* (7) ãƒ†ãƒ¼ãƒ–ãƒ«è¡¨ç¤ºï¼ˆã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆé¢¨ï¼‰ */}
          <TableContainer
            component={Paper}
            sx={{
              height: 'auto',
              minHeight: '200px',
              maxWidth: '100%',
              overflowX: 'auto',
              '& .MuiTable-root': {
                tableLayout: 'auto',
                '& .MuiTableCell-root': {
                  padding: '8px 16px',
                  minWidth: '120px',
                  whiteSpace: 'normal',
                  wordBreak: 'break-word'
                }
              }
            }}
          >
            {renderPivotTable()}
          </TableContainer>
        </Box>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById("root"));
    root.render(<App />);
  </script>
</body>
</html>
