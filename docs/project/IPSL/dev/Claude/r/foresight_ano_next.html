<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <title>在庫・売上データ表（列方向データ管理／フォーカス外時に状態更新）</title>
    <!-- 基本ライブラリ -->
    <script src="https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.production.min.js" crossorigin></script>
    <script src="https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.production.min.js" crossorigin></script>
    <script src="https://cdn.jsdelivr.net/npm/@babel/standalone@7.23.8/babel.min.js"></script>
    
    <!-- Emotion (MUI依存) -->
    <script src="https://cdn.jsdelivr.net/npm/@emotion/react@11.11.3/dist/emotion-react.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@emotion/styled@11.11.0/dist/emotion-styled.umd.min.js"></script>
    
    <!-- MUI Core -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" />
    <script src="https://cdn.jsdelivr.net/npm/@mui/material@5.15.3/umd/material-ui.production.min.js" crossorigin></script>
    
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    
    <!-- D3.js -->
    <script src="https://d3js.org/d3.v6.min.js"></script>
    
    <!-- Excelライブラリ -->
    <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js" defer></script>
    
    <!-- Material Icons -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons" />
    
    <!-- XLSX用スタイル -->
    <style>
      .data-buttons {
        display: flex;
        gap: 8px;
        margin: 8px auto;
        max-width: 800px;
        justify-content: flex-end;
      }
      .data-buttons button {
        padding: 6px 12px;
        background: #1976d2;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
      }
      .data-buttons button:hover {
        background: #1565c0;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <!-- React+BabelでJSX記述 -->
    <script type="text/babel">
      const { Table, TableHead, TableBody, TableRow, TableCell, Paper, TableContainer, TextField } = MaterialUI;
      
      // 入力時：半角数字・ドット・カンマのみ許可
      const allowOnlyNumbers = (e) => {
        if (!/[0-9.,]/.test(e.key)) {
          e.preventDefault();
        }
      };
      
      // 数値フォーマット関数（対象に応じた書式変換）
      const formatNumber = (value, type) => {
        if (!value) return value;
        const num = parseFloat(value.replace(/,/g, "").replace(/%/g, ""));
        if (isNaN(num)) return value;
        if (type === "loss_rate" || type === "rate") {
          return num.toFixed(1) + "%";
        } else if (type === "money") {
          const rounded = Math.round(num);
          const original = num.toFixed(1);
          return rounded === num ? rounded.toLocaleString() : rounded.toLocaleString() + " (" + original + ")";
        }
        return num.toLocaleString();
      };
      
      // 対象により値の種類を判定
      const getValueType = (item, target) => {
        if (item === "ロス" && target === "売価率") return "loss_rate";
        if (target.indexOf("率") !== -1) return "rate";
        if (target === "売価高" || target === "原価高" || target === "総利益高") return "money";
        return "normal";
      };
      
      /* 
         行ヘッダー（ラベル部分）の定義（行方向）
         rowHeaders の要素数は 37 行
      */
      const rowHeaders = [
        { item: "期初在庫", period: "当月", target: "売価高", unit: "千円" },
        { item: "期初在庫", period: "当月", target: "原価高", unit: "千円" },
        { item: "期初在庫", period: "当月", target: "原価率", unit: "%" },
        { item: "売上", period: "当月", target: "売価高", unit: "千円" },
        { item: "売上", period: "当月", target: "原価高", unit: "千円" },
        { item: "売上", period: "当月", target: "総利益高", unit: "千円" },
        { item: "売上", period: "当月", target: "総利益率", unit: "%" },
        { item: "値下", period: "当月", target: "売価高", unit: "千円" },
        { item: "値下", period: "当月", target: "値下げ率", unit: "%" },
        { item: "リベート", period: "当月", target: "原価高", unit: "千円" },
        { item: "リベート", period: "当月", target: "リベート率", unit: "%" },
        { item: "ロス", period: "当月", target: "売価高", unit: "千円" },
        { item: "ロス", period: "当月", target: "売価率", unit: "%" },
        { item: "期首在庫", period: "当月", target: "売価高", unit: "千円" },
        { item: "期首在庫", period: "当月", target: "原価高", unit: "千円" },
        { item: "期首在庫", period: "当月", target: "原価率", unit: "%" },
        { item: "期末在庫", period: "当月", target: "売価高", unit: "千円" },
        { item: "期末在庫", period: "当月", target: "原価高", unit: "千円" },
        { item: "期末在庫", period: "当月", target: "原価率", unit: "%" },
        { item: "在庫高変動", period: "当月", target: "売価高", unit: "千円" },
        { item: "仕入", period: "当月", target: "売価高", unit: "千円" },
        { item: "仕入", period: "当月", target: "原価高", unit: "千円" },
        { item: "仕入", period: "当月", target: "値入率", unit: "%" },
        { item: "仕入（リベート含）", period: "当月", target: "売価高", unit: "千円" },
        { item: "仕入（リベート含）", period: "当月", target: "原価高", unit: "千円" },
        { item: "仕入（リベート含）", period: "当月", target: "値入率", unit: "%" },
        { item: "累計売上", period: "前月", target: "売価高", unit: "千円" },
        { item: "累計原価", period: "前月", target: "原価高", unit: "千円" },
        { item: "累計期末在庫", period: "前月", target: "原価率", unit: "%" },
        { item: "累計売上", period: "当月", target: "売価高", unit: "千円" },
        { item: "累計売上", period: "当月", target: "原価高", unit: "千円" },
        { item: "累計仕入", period: "当月", target: "売価高", unit: "千円" },
        { item: "累計仕入", period: "当月", target: "原価高", unit: "千円" },
        { item: "累計期末在庫", period: "当月", target: "原価率", unit: "%" },

      ];
      
      /* 
         数値データを「列方向」で定義する
         - plans: 13列分の配列（各配列の要素数は rowHeaders の行数＝37）
           ※plan1 の配列は例として定義。以下の配列は plan1 のデータで、要素数が 37 になるように調整しています。
         - yoy: 1列分の配列
      */
      const numericDataColumns = {
        plans: [
          [
            "10000", "117432", "", "55745", "", "19745", "", "13549", "", "750",
            "", "500", "2", "188529", "122298", "", "186398", "", "", "",
            "68278", "34555", "", "68278", "35305", "", "419971", "277301", "",
            "475716", "", "", "311856", "", "", ""  // ※要素数を37に合わせています
          ],
          // plan2 ～ plan13 はすべて空文字列の配列（37要素に合わせる）
          ...Array.from({ length: 12 }, () => Array(rowHeaders.length).fill(""))
        ],
        yoy: Array(rowHeaders.length).fill("")
      };
      
      // sum 列は、各行の plans の値の合計を計算して各行ごとに算出する
      const recalcNumericData = (data) => {
        const numRows = data.yoy.length;
        const sum = [];
        for (let i = 0; i < numRows; i++) {
          let s = 0;
          data.plans.forEach(planCol => {
            const cellValue = planCol[i];
            if (cellValue !== undefined) {
              const num = parseFloat(cellValue.replace(/,/g, "").replace(/%/g, ""));
              if (!isNaN(num)) {
                s += num;
              }
            }
          });
          sum.push(s ? s.toLocaleString() : "");
        }
        return { ...data, sum };
      };
      
      function App() {
        // focusedCell: { row, col } を管理（フォーカス中のセルの位置）
        const [focusedCell, setFocusedCell] = React.useState(null);
        
        // 数値データは列方向のオブジェクトとして state で管理
        const [numericData, setNumericData] = React.useState(numericDataColumns);
        
        // マウント後、初期数値データに sum 列を追加して反映
        React.useEffect(() => {
          setNumericData(recalcNumericData(numericDataColumns));
        }, []);
        
        // 計画値の変更：入力値をそのまま反映
        const handlePlanChange = (rowIndex, planIndex, newValue) => {
          if (/^[0-9.,]*$/.test(newValue)) {
            setNumericData(prev => {
              const newPlans = prev.plans.map((col, idx) => {
                if (idx === planIndex) {
                  const newCol = [...col];
                  newCol[rowIndex] = newValue;
                  return newCol;
                }
                return col;
              });
              return recalcNumericData({ ...prev, plans: newPlans });
            });
          }
        };
        
        // 前年比の変更：入力値をそのまま反映
        const handleYearOnYearChange = (rowIndex, newValue) => {
          if (/^[0-9.,]*$/.test(newValue)) {
            setNumericData(prev => {
              const newYoy = [...prev.yoy];
              newYoy[rowIndex] = newValue;
              return recalcNumericData({ ...prev, yoy: newYoy });
            });
          }
        };
        
        // キー入力処理 - フォーカス時の確定処理を追加
        const handleKeyPress = (e, rowIndex, fieldType, planIndex, currentValue, header, colIndex) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            e.target.blur();
          }
        };
        
        // フォーカス解除時の処理を更新
        const handleFieldBlur = (rowIndex, fieldType, planIndex, currentValue, header) => {
          if (fieldType === 'plan') {
            const type = getValueType(header.item, header.target);
            const formatted = formatNumber(currentValue, type);
            setNumericData(prev => {
              const newPlans = prev.plans.map((col, idx) => {
                if (idx === planIndex) {
                  const newCol = [...col];
                  newCol[rowIndex] = formatted;
                  return newCol;
                }
                return col;
              });
              return recalcNumericData({ ...prev, plans: newPlans });
            });
          } else {
            const formatted = formatNumber(currentValue);
            setNumericData(prev => {
              const newYoy = [...prev.yoy];
              newYoy[rowIndex] = formatted;
              return recalcNumericData({ ...prev, yoy: newYoy });
            });
          }
          setFocusedCell(null);
        };
        
        // テキストフィールドの onFocus/onBlur により focusedCell 状態を更新
        const handleFieldFocus = (rowIndex, colIndex) => {
          setFocusedCell({ row: rowIndex, col: colIndex });
        };
        
        // focusedCell に基づいて、該当する行または列の背景色を変更する関数
        const getCellBg = (rowIndex, colIndex) => {
          if (focusedCell) {
            if (focusedCell.row === rowIndex || focusedCell.col === colIndex) {
              return "#ffe0b2";
            }
          }
          return "inherit";
        };
        
        // 行スタイル（境界線など）
        const getRowStyle = (rowIndex) => {
          const style = { height: "26px" };
          if (rowIndex === rowHeaders.length - 1) {
            style.borderBottom = "2px solid black";
          } else if (rowHeaders[rowIndex].item !== rowHeaders[rowIndex + 1].item) {
            style.borderBottom = "2px solid black";
          }
          return style;
        };
        
        // テーブルヘッダー用：全体で20列（No, 項目, 期間, 対象, 単位, 合計, 計画1～13, 前年比）
        const headerTexts = [
          "No.", "項目", "期間", "対象", "単位", "合計",
          ...Array.from({ length: 13 }, (_, i) => "計画" + (i + 1)),
          "前年比"
        ];
        
        return (
          <>
            <div className="data-buttons">
              <input type="file" accept=".xlsx" onChange={(e) => {
                const file = e.target.files[0];
                const reader = new FileReader();
                reader.onload = (event) => {
                  const wb = XLSX.read(event.target.result, { type: 'binary' });
                  const wsname = wb.SheetNames[0];
                  const ws = wb.Sheets[wsname];
                  const data = XLSX.utils.sheet_to_json(ws, { header: 1 });
                  // ヘッダー行をスキップし、行ごとのオブジェクトに変換後、列方向に再変換
                  const rows = data.slice(1).map(row => ({
                    plans: [row[3] || "", ...Array(12).fill("")],
                    yoy: row[4] || ""
                  }));
                  const convertRowsToColumns = (rows) => {
                    const numPlanCols = rows[0].plans.length;
                    const plans = [];
                    for (let j = 0; j < numPlanCols; j++) {
                      plans.push(rows.map(row => row.plans[j]));
                    }
                    const yoy = rows.map(row => row.yoy);
                    return { plans, yoy };
                  };
                  const newDataCols = convertRowsToColumns(rows);
                  setNumericData(recalcNumericData(newDataCols));
                };
                reader.readAsBinaryString(file);
                e.target.value = null;
              }} style={{ display: 'none' }} id="import-button" />
              <label htmlFor="import-button">
                <button onClick={() => document.getElementById('import-button').click()}>
                  データインポート
                </button>
              </label>
              <button onClick={() => {
                const exportRows = [];
                for (let i = 0; i < rowHeaders.length; i++) {
                  const rowData = {
                    plans: numericData.plans.map(col => col[i]),
                    yoy: numericData.yoy[i],
                    sum: numericData.sum[i]
                  };
                  exportRows.push([ rowHeaders[i].item, rowHeaders[i].period, rowHeaders[i].target, rowData.sum, rowData.yoy ]);
                }
                const ws = XLSX.utils.aoa_to_sheet([
                  ["項目", "期間", "対象", "計画", "前年比"],
                  ...exportRows
                ]);
                const wb = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(wb, ws, "Data");
                XLSX.writeFile(wb, "data.xlsx");
              }}>データエクスポート</button>
              <button onClick={() => {
                const template = [
                  ["項目", "期間", "対象", "計画", "前年比"],
                  ...rowHeaders.map(header => [header.item, header.period, header.target, "", ""])
                ];
                const ws = XLSX.utils.aoa_to_sheet(template);
                const wb = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(wb, ws, "Template");
                XLSX.writeFile(wb, "template.xlsx");
              }}>テンプレート取得</button>
            </div>
            <TableContainer component={Paper} style={{ width: "100%", margin: "4px auto", padding: "2px", overflowX: "auto" }}>
              <Table size="small">
                <TableHead>
                  <TableRow>
                    {headerTexts.map((text, colIndex) => (
                      <TableCell
                        key={colIndex}
                        sx={{
                          whiteSpace: "nowrap",
                          padding: "2px 4px",
                          fontWeight: "bold",
                          textAlign: "center",
                          backgroundColor: focusedCell && focusedCell.col === colIndex ? "#ffe0b2" : "inherit"
                        }}
                      >
                        {text}
                      </TableCell>
                    ))}
                  </TableRow>
                </TableHead>
                <TableBody>
                  {rowHeaders.map((header, rowIndex) => (
                    <TableRow 
                      key={rowIndex} 
                      sx={{
                        ...getRowStyle(rowIndex),
                        backgroundColor: focusedCell && focusedCell.row === rowIndex ? "#ffe0b2" : "inherit"
                      }}
                    >
                      {/* No.列（列0） */}
                      <TableCell 
                        sx={{
                          whiteSpace: "nowrap",
                          padding: "2px 4px",
                          textAlign:"center",
                          backgroundColor: getCellBg(rowIndex, 0)
                        }}
                      >
                        {rowIndex + 1}
                      </TableCell>
                      {/* 固定ラベル部分：項目, 期間, 対象, 単位 → 列1～4 */}
                      {["item", "period", "target", "unit"].map((field, i) => {
                        const colIndex = i + 1;
                        return (
                          <TableCell
                            key={i}
                            sx={{
                              whiteSpace: "nowrap",
                              padding: "2px 4px",
                              textAlign: field === "item" ? "left" : "center",
                              backgroundColor: getCellBg(rowIndex, colIndex)
                            }}
                          >
                            {header[field]}
                          </TableCell>
                        );
                      })}
                      {/* 合計 → 列5 */}
                      <TableCell 
                        sx={{
                          whiteSpace: "nowrap",
                          padding: "2px 4px",
                          textAlign:"center",
                          backgroundColor: getCellBg(rowIndex, 5)
                        }}
                      >
                        {numericData.sum ? numericData.sum[rowIndex] : ""}
                      </TableCell>
                      {/* 計画値（plans）→ 列6～18 */}
                      {numericData.plans.map((col, j) => {
                        const colIndex = 6 + j;
                        return (
                          <TableCell
                            key={`plan-${rowIndex}-${j}`}
                            sx={{
                              whiteSpace: "nowrap",
                              padding: "2px 4px",
                              backgroundColor: getCellBg(rowIndex, colIndex)
                            }}
                          >
                            <TextField
                              variant="outlined"
                              size="small"
                              value={col[rowIndex]}
                              onChange={(e) => handlePlanChange(rowIndex, j, e.target.value)}
                              onBlur={(e) => handleFieldBlur(rowIndex, 'plan', j, e.target.value, header)}
                              onFocus={() => handleFieldFocus(rowIndex, colIndex)}
                              onKeyPress={(e) => handleKeyPress(e, rowIndex, 'plan', j, e.target.value, header, colIndex)}
                              fullWidth
                              inputProps={{
                                style: { whiteSpace: "nowrap", textAlign: "right", padding: "2px" },
                                inputMode: "decimal",
                                pattern: "[0-9.,]*",
                                onKeyPress: allowOnlyNumbers
                              }}
                            />
                          </TableCell>
                        );
                      })}
                      {/* 前年比 → 最終列（列19） */}
                      <TableCell 
                        sx={{
                          whiteSpace: "nowrap",
                          padding: "2px 4px",
                          backgroundColor: getCellBg(rowIndex, 19)
                        }}
                      >
                        <TextField
                          variant="outlined"
                          size="small"
                          value={numericData.yoy ? numericData.yoy[rowIndex] : ""}
                          onChange={(e) => handleYearOnYearChange(rowIndex, e.target.value)}
                          onBlur={(e) => handleFieldBlur(rowIndex, 'yearOnYear', null, e.target.value, header)}
                          onFocus={() => handleFieldFocus(rowIndex, 19)}
                          onKeyPress={(e) => handleKeyPress(e, rowIndex, 'yearOnYear', null, e.target.value, header, 19)}
                          fullWidth
                          inputProps={{
                            style: { whiteSpace: "nowrap", textAlign: "right", padding: "2px" },
                            inputMode: "decimal",
                            pattern: "[0-9.,]*",
                            onKeyPress: allowOnlyNumbers
                          }}
                        />
                      </TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </TableContainer>
          </>
        );
      }
      
      ReactDOM.render(<App />, document.getElementById("root"));
    </script>
  </body>
</html>
