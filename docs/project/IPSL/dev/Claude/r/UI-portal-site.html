<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>統合ドメインダッシュボード（STOREID＝施設共有／半透明スティッキー＋ナビチップ／nowrap表）</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap"/>
  <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons"/>
  <script src="https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mui/material@5.15.14/umd/material-ui.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@babel/standalone@7.25.6/babel.min.js"></script>
  <style>
    html,body {
      height: 100%;
      margin: 0;
      font-family: Roboto, system-ui;
      background: #fafafa;
    }

    /* ✅ パネル群はレスポンシブに */
    .grid {
      display: grid;
      gap: 12px;
      grid-template-columns: repeat(auto-fit, minmax(50%, 1fr));
      width: 100%;
      box-sizing: border-box;
    }

    /* ✅ テーブルは横スクロール */
    table td, table th {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .mono{font-variant-numeric:tabular-nums}
    .kpi{display:grid;grid-template-columns:repeat(5,1fr);gap:8px;margin-bottom:10px}
    @media(max-width:900px){.kpi{grid-template-columns:repeat(2,1fr)}}
  </style>
  
</head>
<body>
  <div id="app"></div>

  <script type="text/babel">
const {
  Box, Card, CardContent, Typography, Stack, Table, TableHead, TableBody, TableRow, TableCell,
  TableContainer, Paper, TextField, Button, Chip, ThemeProvider, createTheme,
  MenuItem, Select, FormControl, InputLabel, OutlinedInput, Checkbox, ListItemText, Divider
} = MaterialUI;

/* ========= ユーティリティ ========= */
function mulberry32(a){return function(){let t=a+=0x6D2B79F5;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return ((t^t>>>14)>>>0)/4294967296;};}
function hashStrToSeed(str){let h=2166136261;for(let i=0;i<str.length;i++){h^=str.charCodeAt(i);h=Math.imul(h,16777619);}return (h>>>0)||1;}
const makeRng=(seedStr)=>mulberry32(hashStrToSeed(seedStr));
const pick=(rnd,arr)=>arr[Math.floor(rnd()*arr.length)];
function useDebounced(value, delay=300){
  const [v, setV] = React.useState(value);
  React.useEffect(()=>{ const t=setTimeout(()=>setV(value),delay); return ()=>clearTimeout(t); },[value,delay]);
  return v;
}

/* ========= 小コンポーネント ========= */
function Info({label, value, mono}) {
  return (
    <Stack spacing={0}>
      <Typography variant="caption" color="text.secondary">{label}</Typography>
      <Typography className={mono?'mono':''}>{(value??'—')===''?'—':value}</Typography>
    </Stack>
  );
}

/* ========= レスポンシブ・ナビチップ（常に折返し） ========= */
function ResponsiveChips({ items, onJump }) {
  return (
    <Box sx={{ mt: 1 }}>
      <Stack
        direction="row"
        useFlexGap
        flexWrap="wrap"
        gap={0.5}
        alignItems="center"
        sx={{ minHeight: 40 }}
      >
        <Typography variant="body2" color="text.secondary" sx={{ mr: 0.5 }}>
          パネルへ移動:
        </Typography>
        {items.map((it) => (
          <Chip
            key={it.id}
            label={it.title}
            variant="outlined"
            size="small"
            onClick={() => onJump(it.id)}
          />
        ))}
        <Chip
          label="トップ"
          size="small"
          onClick={() => window.scrollTo({ top: 0, behavior: 'smooth' })}
        />
      </Stack>
    </Box>
  );
}

/* ========= 半透明スティッキーヘッダー ========= */
function StickyHeader({
  facilities, facSel, setFacSel,
  sts, setSts,
  qInput, setQInput,
  navItems, onJump
}) {
  const ALL_STATUS = ['稼働','有効','点検中','未対応','期限切れ','停止','閉店','完了','未完','遵守','無効','退去'];

  return (
    <Box
      sx={{
        position: 'sticky',
        top: 0,
        zIndex: 1200,
        background: 'rgba(250,250,250,0.85)',
        backdropFilter: 'saturate(180%) blur(8px)',
        borderBottom: '1px solid',
        borderColor: 'divider',
      }}
    >
      <Box sx={{ px: { xs: 1, md: 2 }, py: 1 }}>
        <Typography variant="h5" gutterBottom sx={{ mb: 1 }}>
          統合ドメインダッシュボード（STOREID＝施設共有／ナビチップ）
        </Typography>

        {/* 統合フィルタ */}
        <Stack direction={{ xs: 'column', md: 'row' }} gap={1} alignItems={{ xs: 'stretch', md: 'center' }}>
          <FormControl fullWidth size="small">
            <InputLabel>施設（店舗/複数選択）</InputLabel>
            <Select
              multiple
              value={facSel}
              onChange={(e) => setFacSel(e.target.value)}
              input={<OutlinedInput label="施設（店舗）" />}
              renderValue={(sel) =>
                sel.map((id) => facilities.find((f) => f.id === id)?.name || id).join(', ')
              }
            >
              {facilities.map((f) => (
                <MenuItem key={f.id} value={f.id}>
                  <Checkbox checked={facSel.indexOf(f.id) > -1} />
                  <ListItemText primary={`${f.name}（${f.id}）`} />
                </MenuItem>
              ))}
            </Select>
          </FormControl>

          <FormControl fullWidth size="small">
            <InputLabel>状態</InputLabel>
            <Select
              multiple
              value={sts}
              onChange={(e) => setSts(e.target.value)}
              input={<OutlinedInput label="状態" />}
              renderValue={(sel) => sel.join(', ')}
            >
              {ALL_STATUS.map((s) => (
                <MenuItem key={s} value={s}>
                  <Checkbox checked={sts.indexOf(s) > -1} />
                  <ListItemText primary={s} />
                </MenuItem>
              ))}
            </Select>
          </FormControl>

          <TextField
            fullWidth
            size="small"
            label="全体検索"
            value={qInput}
            onChange={(e) => setQInput(e.target.value)}
            placeholder="STOREID / テナント / 契約ID / 住所 / 電話 など"
          />
        </Stack>

        <Typography variant="caption" color="text.secondary" sx={{ mt: 1, display: 'block' }}>
          ※ 施設は STOREID を使用。全パネルで共有フィルタとして機能します。
        </Typography>

        {/* ナビチップ（常に折返し） */}
        <ResponsiveChips items={navItems} onJump={onJump} />
      </Box>
    </Box>
  );
}

/* ========= 汎用パネル（各パネル主導で単票切替可） ========= */
function GenericPanel({ title, list, columns, kpiFactory, filters, renderCard, cardWhen }) {
  const [page,setPage]=React.useState(0);
  const perPage=15;

  // 統合フィルタ
  const filtered=React.useMemo(()=>{
    const q = (filters.q||'').toLowerCase();
    const keys = [
      'id','store_id','store_id_key','store_id_numeric','tenant_id','contract_id',
      'name','store_name','brand_name','manager_id','owner_id_key',
      'type','category','business_category','business_type','partner','item','content',
      'block','phone_number_business','phone_number_internal','after_hours_phone_number','fax_number',
      'address','location','status','contract_type','utilities_charges','renewal_conditions'
    ];
    return list.filter(r=>{
      const matchFacility = !filters.facilities.length || filters.facilities.includes(r.facility); // facility＝STOREID
      const matchStatus = !filters.statuses.length ||
        (typeof r.status==='string' ? filters.statuses.includes(r.status) : true);
      const matchQuery = !q || keys.some(k => String(r[k]??'').toLowerCase().includes(q));
      return matchFacility && matchStatus && matchQuery;
    });
  },[list,filters.facilities,filters.statuses,filters.q]);

  React.useEffect(()=>{ setPage(0); },[filters.facilities,filters.statuses,filters.q]);

  const total=filtered.length, pages=Math.max(1, Math.ceil(total/perPage));
  const curPage=Math.min(page, pages-1);
  const pageRows=filtered.slice(curPage*perPage,curPage*perPage+perPage);
  const start=total?curPage*perPage+1:0,end=Math.min(total,(curPage+1)*perPage);
  const kpis=(kpiFactory||((rs)=>[{label:'件数',value:rs.length}]))(filtered);

  const isFiltered = filtered.length !== list.length;
  const ctx = { isFiltered, filters, total, pageRows, filtered };
  const useCards = typeof renderCard==='function' && typeof cardWhen==='function' ? !!cardWhen(ctx) : false;

  {/* ---------- セクション用の簡易エラーバウンダリ ---------- */}
  class SectionBoundary extends React.Component {
    constructor(props) {
      super(props);
      this.state = { hasError: false, err: null };
    }
    static getDerivedStateFromError(err) { return { hasError: true, err }; }
    componentDidCatch(err, info) { console.error('[Panel section error]', err, info); }
    render() {
      if (this.state.hasError) {
        return (
          <Card variant="outlined" style={{ borderColor: '#f44336' }}>
            <CardContent>
              <Typography color="error">このセクションの描画に失敗しました。</Typography>
              <Typography variant="caption" color="text.secondary">
                {String(this.state.err?.message || this.state.err || 'Unknown error')}
              </Typography>
            </CardContent>
          </Card>
        );
      }
      return this.props.children;
    }
  }


  return(
    <Card>
      <CardContent>
        <Typography variant="h6" sx={{mb:1}}>{title}</Typography>

        {/* KPI */}
        <Box className="kpi">
          {kpis.map(k=>(
            <Card key={k.label} variant="outlined" sx={{p:1}}>
              <Typography color="text.secondary" variant="body2">{k.label}</Typography>
              <Typography variant="h6" className="mono">{k.value}</Typography>
              {k.sub && <Typography color="text.secondary" variant="caption">{k.sub}</Typography>}
            </Card>
          ))}
        </Box>

        {/* 一覧（カード or テーブル） */}
        {useCards ? (
          <Box sx={{display:'grid', gap:1}}>
            {pageRows.map((r,i)=>(
              <Card key={r.id||i} variant="outlined">{renderCard(r)}</Card>
            ))}
            {pageRows.length===0 && (
              <Card variant="outlined"><CardContent>
                <Typography color="text.secondary">該当データがありません</Typography>
              </CardContent></Card>
            )}
          </Box>
        ) : (
          <TableContainer
            component={Paper}
            variant="outlined"
            sx={{ maxHeight: 420, overflowX:'auto' }}
          >
            <Table size="small" stickyHeader sx={{ tableLayout: 'auto', minWidth: 960 }}>
              <TableHead>
                <TableRow>
                  {columns.map(c=>(
                    <TableCell key={c.key} align={c.align||'left'} sx={{ whiteSpace:'nowrap' }}>
                      {c.label}
                    </TableCell>
                  ))}
                </TableRow>
              </TableHead>
              <TableBody>
                {pageRows.map((r,i)=>(
                  <TableRow key={r.id||i} hover>
                    {columns.map(c=>{
                      const v=typeof c.render==='function'?c.render(r):(r[c.key]??'');
                      return (
                        <TableCell
                          key={c.key}
                          align={c.align||'left'}
                          className={c.mono?'mono':''}
                          sx={{
                            whiteSpace:'nowrap',
                            overflow:'hidden',
                            textOverflow:'ellipsis',
                            maxWidth: 260
                          }}
                          title={typeof v === 'string' ? v : undefined}
                        >
                          {v}
                        </TableCell>
                      );
                    })}
                  </TableRow>
                ))}
                {pageRows.length===0 && (
                  <TableRow><TableCell colSpan={columns.length} align="center">
                    <Typography color="text.secondary" sx={{py:2}}>該当データがありません</Typography>
                  </TableCell></TableRow>
                )}
              </TableBody>
            </Table>
          </TableContainer>
        )}

        {/* ページネーション */}
        <Stack direction="row" justifyContent="space-between" alignItems="center" sx={{mt:1}}>
          <Typography variant="body2" color="text.secondary">表示 {start}-{end}/{total} 件</Typography>
          <Stack direction="row" gap={0.5} alignItems="center">
            <Button onClick={()=>setPage(0)} disabled={curPage===0}>⏮</Button>
            <Button onClick={()=>setPage(p=>Math.max(0,p-1))} disabled={curPage===0}>◀</Button>
            <Typography className="mono">Page {curPage+1}/{pages}</Typography>
            <Button onClick={()=>setPage(p=>Math.min(pages-1,p+1))} disabled={curPage>=pages-1}>▶</Button>
            <Button onClick={()=>setPage(pages-1)} disabled={curPage>=pages-1}>⏭</Button>
          </Stack>
        </Stack>
      </CardContent>
    </Card>
  );
}

/* ========= パネル定義（全ドメイン） ========= */
const panels = {
  /* --- 店舗（施設＝店舗／STOREIDが facility） --- */
  store:{
    title:"店舗管理（施設＝店舗）",
    columns:[
      {key:'store_id',label:'店舗ID',mono:true},
      {key:'store_name',label:'店舗名'},
      {key:'business',label:'業種/業態',render:r=><span>{r.business_category} / {r.business_type}</span>},
      {key:'area',label:'面積(㎡)',align:'right',mono:true,render:r=>(r.area??0).toLocaleString(undefined,{maximumFractionDigits:1,minimumFractionDigits:1})},
      {key:'floors',label:'階数',align:'right',mono:true},
      {key:'dates',label:'開店/閉店',render:r=>{
        const f = d=>d?new Date(d).toISOString().slice(0,10):'—';
        return <span className="mono">{f(r.opening_date)} / {f(r.closing_date)}</span>;
      }},
      {key:'status',label:'状態',render:r=>{
        const map = { '稼働':'success', '停止':'default', '閉店':'default' };
        return <Chip label={r.status} color={map[r.status]||'default'} size="small"/>;
      }},
      {key:'address',label:'住所',render:r=>r.address||'—'}
    ],
    list:(rnd)=>Array.from({length:60}).map((_,i)=>{
      const statusFlag = rnd()>.1 ? 1 : 0;
      const openedYear = 2012 + Math.floor(rnd()*10);
      const opening_date = new Date(openedYear, Math.floor(rnd()*12), 1+Math.floor(rnd()*27));
      const isClosed = rnd()<0.05;
      const closing_date = isClosed ? new Date(openedYear + Math.floor(1+rnd()*10), Math.floor(rnd()*12), 1+Math.floor(rnd()*27)) : null;
      const status = closing_date ? '閉店' : (statusFlag ? '稼働' : '停止');
      const addrCity = ['千代田区','中央区','港区','新宿区','渋谷区','豊島区','世田谷区'][Math.floor(rnd()*7)];
      const addrRest = `${Math.ceil(rnd()*3)}丁目${Math.ceil(rnd()*20)}-${Math.ceil(rnd()*30)}`;
      const store_id = `ST-${String(i+1).padStart(3,'0')}`;
      return {
        id:i+1, store_id, store_name:`店舗${i+1}`,
        business_category: pick(rnd,['物販','飲食','サービス']),
        business_type: pick(rnd,['直営','FC','委託']),
        area: +(500 + rnd()*3000).toFixed(1),
        floors: 1 + Math.floor(rnd()*8),
        opening_date, closing_date, status,
        address: `東京都${addrCity}${addrRest}`,
        facility: store_id
      };
    }),
    kpi:(r)=>{
      const total=r.length;
      const active=r.filter(x=>x.status==='稼働').length;
      const totalArea=r.reduce((s,x)=>s+(+x.area||0),0);
      const avgArea=total?totalArea/total:0;
      return [
        {label:'店舗数', value: total},
        {label:'稼働率', value: total?Math.round(active/total*100)+'%':'—', sub:`稼働 ${active} 店`},
        {label:'総面積(㎡)', value: totalArea.toLocaleString(undefined,{maximumFractionDigits:0})},
        {label:'平均面積(㎡)', value: avgArea.toLocaleString(undefined,{maximumFractionDigits:0})}
      ];
    },
    // フィルタ時のみ単票カードへ
    cardWhen: ({isFiltered}) => isFiltered,
    renderCard:(r)=>(
      <CardContent>
        <Stack direction="row" justifyContent="space-between" alignItems="center" sx={{mb:1}}>
          <Stack>
            <Typography variant="subtitle2" className="mono">{r.store_id}</Typography>
            <Typography variant="h6">{r.store_name}</Typography>
          </Stack>
          <Chip size="small" label={r.status} color={{'稼働':'success','停止':'default','閉店':'default'}[r.status]||'default'}/>
        </Stack>
        <Box sx={{display:'grid', gridTemplateColumns:{xs:'1fr', md:'1fr 1fr'}, gap:1}}>
          <Info label="業種/業態" value={`${r.business_category} / ${r.business_type}`}/>
          <Info label="住所" value={r.address}/>
          <Info label="面積(㎡)" value={(r.area??0).toLocaleString(undefined,{maximumFractionDigits:1,minimumFractionDigits:1})} mono/>
          <Info label="階数" value={r.floors} mono/>
          <Info label="開店日" value={r.opening_date?new Date(r.opening_date).toISOString().slice(0,10):'—'} mono/>
          <Info label="閉店日" value={r.closing_date?new Date(r.closing_date).toISOString().slice(0,10):'—'} mono/>
        </Box>
      </CardContent>
    )
  },

  /* --- テナント（常にテーブル） --- */
  tenant:{
    title:"テナント管理",
    columns:[
      {key:'tenant_id',label:'テナントID',mono:true},
      {key:'brand_name',label:'ブランド名'},
      {key:'name',label:'テナント名'},
      {key:'category',label:'区分'},
      {key:'business_type',label:'業態'},
      {key:'store_id_key',label:'店舗キー',align:'right',mono:true},
      {key:'status',label:'状態',render:r=>{
        const map = { '稼働':'success', '停止':'default' };
        return <Chip label={r.status} color={map[r.status]||'default'} size="small"/>;
      }},
      {key:'contract',label:'契約期間',render:r=>{
        const f=d=>d?new Date(d).toISOString().slice(0,10):'—';
        return <span className="mono">{f(r.contract_start_date)} ~ {f(r.contract_end_date)}</span>;
      }},
      {key:'fixed_rent',label:'固定賃料',align:'right',mono:true,render:r=>(Number(r.fixed_rent)||0).toLocaleString(undefined,{minimumFractionDigits:0,maximumFractionDigits:0})},
      {key:'deposit',label:'敷金',align:'right',mono:true,render:r=>(Number(r.deposit)||0).toLocaleString()},
      {key:'contract_type',label:'契約種別'},
      {key:'contract_id',label:'契約ID',mono:true},
      {key:'location',label:'区画位置'},
      {key:'manager_id',label:'管理者ID',mono:true},
      {key:'utilities_charges',label:'光熱費'},
      {key:'renewal_conditions',label:'更新条件',render:r=>{
        const s=r.renewal_conditions||'';return s.length>12?s.slice(0,12)+'…':s||'—';
      }},
      {key:'fire_manager',label:'防火管理者',render:r=>r.fire_manager||'—'},
      {key:'notes',label:'備考',render:r=>{
        const s=r.notes||'';return s.length>12?s.slice(0,12)+'…':s||'—';
      }}
    ],
    list:(rnd)=>Array.from({length:220}).map((_,i)=>{
      const statusFlag = rnd()>.18 ? 1 : 0;
      const status = statusFlag ? '稼働' : '停止';
      const startYear = 2016 + Math.floor(rnd()*8);
      const contract_start_date = new Date(startYear, Math.floor(rnd()*12), 1+Math.floor(rnd()*27));
      const contract_end_date = new Date(startYear + (1+Math.floor(rnd()*5)), Math.floor(rnd()*12), 1+Math.floor(rnd()*27));
      return {
        id: i+1,
        store_id_key: 1 + Math.floor(rnd()*120),
        tenant_id: `TN-${String(i+1).padStart(5,'0')}`,
        status,
        category: pick(rnd,['物販','飲食','サービス','その他']),
        name: `テナント${i+1}`,
        owner_id_key: 1 + Math.floor(rnd()*300),
        fire_manager: rnd()<0.7 ? `防火管${Math.ceil(rnd()*500)}` : '',
        pdf_construction_type: rnd()<0.3 ? 'RC造/防火区画有' : '',
        fixed_rent: +(100000 + rnd()*900000).toFixed(2),
        contract_type: pick(rnd,['定期','普通','サブリース']),
        contract_id: `CT-${String(10000+Math.floor(rnd()*90000))}`,
        contract_start_date,
        contract_end_date,
        renewal_conditions: rnd()<0.5 ? '自動更新/年1回見直し' : '',
        utilities_charges: rnd()<0.6 ? '実費精算' : '定額',
        deposit: +(500000 + rnd()*5000000).toFixed(2),
        pdf_key_handover: rnd()<0.25 ? '鍵受領書あり' : '',
        notes: rnd()<0.3 ? '夜間搬入あり／要連絡' : '',
        created_at: new Date(), created_by:'system',
        updated_at: new Date(), updated_by:'system',
        is_deleted: rnd()<0.02 ? 1 : 0,
        brand_name: rnd()<0.5 ? pick(rnd,['BRAVO','SUNNY','NOVA','PIANO','AROMA']) : '',
        business_type: pick(rnd,['直営','FC','委託']),
        location: `L-${Math.ceil(rnd()*9)}F-${Math.ceil(rnd()*50)}`,
        manager_id: `MG-${String(1000+Math.floor(rnd()*9000))}`,
        facility: null // App 側で STOREID を割当
      };
    }),
    kpi:(r)=>{
      const valid = r.filter(x=>!x.is_deleted);
      const running = valid.filter(x=>x.status==='稼働').length;
      const totalRent = valid.reduce((s,x)=>s+(Number(x.fixed_rent)||0),0);
      const avgRent = valid.length ? totalRent/valid.length : 0;
      const now = new Date(), y=now.getFullYear();
      const startThisYear = valid.filter(x=>x.contract_start_date && new Date(x.contract_start_date).getFullYear()===y).length;
      const endThisYear = valid.filter(x=>x.contract_end_date && new Date(x.contract_end_date).getFullYear()===y).length;
      return [
        {label:'テナント数', value: valid.length},
        {label:'稼働率', value: valid.length?Math.round(running/valid.length*100)+'%':'—', sub:`稼働 ${running} 件`},
        {label:'固定賃料 合計', value: totalRent.toLocaleString(undefined,{maximumFractionDigits:0})},
        {label:'固定賃料 平均', value: avgRent.toLocaleString(undefined,{maximumFractionDigits:0})},
        {label:`${y} 契約開始/終了`, value: `${startThisYear}/${endThisYear}`}
      ];
    }
  },

  /* --- 設備 --- */
  /* --- 設備（設備テーブル準拠 + 集計テーブル付き） --- */
  equip: {
    title: "設備管理",
    columns: [
      { key: 'id', label: 'ID', mono: true, align: 'right' },
      { key: 'store_id_key', label: '店舗Key', mono: true, align: 'right' },
      { key: 'facility_id', label: '施設ID' },
      {
        key: 'status',
        label: '状態',
        render: r => {
          const on = !!r.status;
          return <Chip size="small" label={on ? '有効' : '無効'} color={on ? 'success' : 'default'} />;
        }
      },
      { key: 'usage_status', label: '運用', render: r => {
          const color = r.usage_status === '稼働' ? 'success' :
                        r.usage_status === '点検中' ? 'warning' : 'default';
          return <Chip size="small" label={r.usage_status||'—'} color={color} />;
        }
      },
      // ▼ 集計で使う“カテゴリ（物理/情報）”を明示表示
      { key: 'category', label: 'カテゴリ' },

      { key: 'facilities_type_id', label: '設備種別ID', mono: true, align: 'right' },
      { key: 'facilities_name_id', label: '設備名称ID', mono: true, align: 'right' },
      { key: 'manufacturer', label: 'メーカー' },
      { key: 'model_number', label: '型番' },
      { key: 'asset_classification', label: '資産区分' },
      { key: 'location_info', label: '設置場所' },
      { key: 'capacity_or_size', label: '能力/サイズ' },
      { key: 'number_of_units', label: '台数', mono: true, align: 'right' },
      {
        key: 'installation_date',
        label: '設置日',
        render: r => r.installation_date
          ? <span className="mono">{new Date(r.installation_date).toISOString().slice(0,10)}</span>
          : '—'
      },
      { key: 'useful_life', label: '耐用年数', mono: true, align: 'right' },
      {
        key: 'last_maintenance_date',
        label: '最終点検日',
        render: r => r.last_maintenance_date
          ? <span className="mono">{new Date(r.last_maintenance_date).toISOString().slice(0,10)}</span>
          : '—'
      },
      {
        key: 'next_maintenance_date',
        label: '次回点検予定',
        render: r => r.next_maintenance_date
          ? <span className="mono">{new Date(r.next_maintenance_date).toISOString().slice(0,10)}</span>
          : '—'
      },
      { key: 'maintenance_interval', label: '点検間隔(月)', mono: true, align: 'right' },
      {
        key: 'purchase_cost',
        label: '購入金額',
        mono: true,
        align: 'right',
        render: r => (Number(r.purchase_cost)||0).toLocaleString(undefined, { maximumFractionDigits: 0 })
      },
      { key: 'purchase_destination', label: '購入先' },
      { key: 'maintenance_destination', label: '保守先' },
      {
        key: 'updated_at',
        label: '更新日',
        render: r => r.updated_at
          ? <span className="mono">{new Date(r.updated_at).toISOString().slice(0,10)}</span>
          : '—'
      },
      { key: 'notes', label: '備考', render: r => {
          const s = r.notes || '';
          const t = s || '—';
          const v = s.length > 18 ? s.slice(0,18) + '…' : t;
          return <span title={t}>{v}</span>;
        }
      }
    ],

    // ダミーデータ（実データ差替え前提）
    list: (rnd) => {
      const makers = ['Panasonic','Hitachi','Toshiba','Sharp','Mitsubishi','Daikin'];
      const classes = ['什器','設備','備品','建物付属設備'];
      const usage = ['稼働','点検中','停止'];

      // 日付ヘルパ
      const randDate = (y0=2016, y1=2025) => {
        const y = y0 + Math.floor(rnd() * (y1 - y0 + 1));
        const m = Math.floor(rnd()*12);
        const d = 1 + Math.floor(rnd()*27);
        return new Date(y, m, d);
      };

      return Array.from({ length: 180 }).map((_, i) => {
        const statusFlag = rnd() > 0.08 ? 1 : 0;              // 有効 ≒92%
        const install = randDate(2016, 2024);
        const interval = [6, 12, 24][Math.floor(rnd()*3)];    // 月
        const lastMt = rnd() < 0.8 ? randDate(2023, 2025) : null;
        const base = lastMt || install;
        const nextMt = new Date(base.getFullYear(), base.getMonth() + interval, base.getDate());
        const cost = +(50000 + rnd()*1500000).toFixed(2);

        // 物理/情報のカテゴリ割当（例：ID奇数→物理、偶数→情報）
        const cat = (i % 2 === 0) ? '物理' : '情報';

        return {
          id: i + 1,
          store_id_key: 1 + Math.floor(rnd()*400),
          facility_id: `ST-${String(1 + Math.floor(rnd()*120)).padStart(3,'0')}`,
          status: statusFlag,                                   // tinyint(1) → 有効/無効
          category: cat,                                        // ★ 物理/情報
          facilities_type_id: 100 + Math.floor(rnd()*50),
          facilities_name_id: 1000 + Math.floor(rnd()*9000),
          location_info: ['売場','バックヤード','機械室','屋上','外部ヤード'][Math.floor(rnd()*5)],
          capacity_or_size: rnd()<0.6 ? `${(2 + rnd()*48).toFixed(1)} kW` : `${(10 + rnd()*990).toFixed(0)} L`,
          manufacturer: makers[Math.floor(rnd()*makers.length)],
          model_number: `MD-${String(10000 + Math.floor(rnd()*90000))}`,
          asset_classification: classes[Math.floor(rnd()*classes.length)],
          number_of_units: 1 + Math.floor(rnd()*4),
          installation_date: install,
          useful_life: [5,7,10,12,15][Math.floor(rnd()*5)],
          update_date: randDate(2022, 2025),
          billing_contract_number: rnd()<0.6 ? `BCN-${String(100000 + Math.floor(rnd()*900000))}` : '',
          purchase_cost: cost,
          usage_status: usage[Math.floor(rnd()*usage.length)],  // 稼働/点検中/停止
          next_maintenance_date: nextMt,
          last_maintenance_date: lastMt,
          maintenance_interval: interval,
          scheduled_update_date: rnd()<0.3 ? randDate(2025, 2027) : null,
          photos: rnd()<0.3 ? 'photo_001.jpg' : '',
          json: '',
          created_at: new Date(),
          created_by: 'system',
          updated_at: new Date(),
          updated_by: 'system',
          is_deleted: rnd()<0.02 ? 1 : 0,
          purchase_destination: rnd()<0.5 ? '○○商事' : '△△テック',
          maintenance_destination: rnd()<0.5 ? '保守A社' : '保守B社',
          notes: rnd()<0.25 ? '夜間点検あり／要立会い' : '',
          // ★ STOREID 共有フィルタ向け（App 側で上書き）
          facility: null
        };
      });
    },

    // KPI：件数 / 稼働中 / 点検期限切れ / 今月点検予定 / 購入金額合計
    kpi: (rows) => {
      const valid = rows.filter(x => !x.is_deleted);
      const total = valid.length;
      const running = valid.filter(x => x.usage_status === '稼働').length;

      const today = new Date();
      const y = today.getFullYear();
      const m = today.getMonth();
      const startOfMonth = new Date(y, m, 1);
      const endOfMonth = new Date(y, m + 1, 0);

      const overdue = valid.filter(x => {
        const d = x.next_maintenance_date ? new Date(x.next_maintenance_date) : null;
        return d && d < startOfMonth;
      }).length;

      const dueThisMonth = valid.filter(x => {
        const d = x.next_maintenance_date ? new Date(x.next_maintenance_date) : null;
        return d && d >= startOfMonth && d <= endOfMonth;
      }).length;

      const sumCost = valid.reduce((s, x) => s + (Number(x.purchase_cost) || 0), 0);

      return [
        { label: '設備数', value: total },
        { label: '稼働中', value: running },
        { label: '点検期限切れ', value: overdue },
        { label: '今月点検予定', value: dueThisMonth },
        { label: '購入金額合計', value: sumCost.toLocaleString(undefined, { maximumFractionDigits: 0 }) }
      ];
    },

    // ★ 追加：カテゴリ×設備種別×設備名 集計テーブルつきの表示
    Custom: ({ title, list, columns, kpiFactory, filters }) => {
      // 1) 統合フィルタ適用
      const filtered = React.useMemo(() => {
        const q = (filters.q||'').toLowerCase();
        const keys = [
          'id','facility_id','category','usage_status','manufacturer','model_number',
          'asset_classification','location_info','capacity_or_size'
        ];
        return (list||[]).filter(r => {
          const st = r.status ? '有効' : '無効';
          const matchFacility = !filters.facilities.length || filters.facilities.includes(r.facility);
          const matchStatus   = !filters.statuses.length  || filters.statuses.includes(st);
          const matchQuery    = !q || keys.some(k => String(r[k]??'').toLowerCase().includes(q));
          return matchFacility && matchStatus && matchQuery && !r.is_deleted;
        });
      }, [list, filters]);

      // 2) KPI
      const kpis = (kpiFactory||((rs)=>[{label:'件数',value:rs.length}]))(filtered);

      // 3) 集計（カテゴリ × 設備種別ID × 設備名称ID）
      const agg = new Map();
      const keyOf = (r) => `${r.category||'—'}|${r.facilities_type_id||'—'}|${r.facilities_name_id||'—'}`;
      filtered.forEach(r => {
        const k = keyOf(r);
        if (!agg.has(k)) agg.set(k, { cnt:0, run:0, chk:0, stop:0 });
        const a = agg.get(k);
        a.cnt += 1;
        if (r.usage_status === '稼働') a.run += 1;
        else if (r.usage_status === '点検中') a.chk += 1;
        else a.stop += 1;
      });

      const rows = Array.from(agg.entries()).map(([k, v]) => {
        const [category, typeId, nameId] = k.split('|');
        return { category, typeId, nameId, ...v };
      }).sort((a,b)=>{
        // カテゴリ（物理→情報）、種別ID、名称IDで並べ替え
        const catRank = (x)=> x==='物理'?0: x==='情報'?1:2;
        return (catRank(a.category)-catRank(b.category))
            || (String(a.typeId).localeCompare(String(b.typeId)))
            || (String(a.nameId).localeCompare(String(b.nameId)));
      });

      // 4) レンダリング
      return (
        <Card>
          <CardContent>
            <Typography variant="h6" sx={{mb:1}}>{title}</Typography>

            {/* KPI */}
            <Box className="kpi" sx={{mb:1}}>
              {kpis.map(k=>(
                <Card key={k.label} variant="outlined" sx={{p:1}}>
                  <Typography color="text.secondary" variant="body2">{k.label}</Typography>
                  <Typography variant="h6" className="mono">{k.value}</Typography>
                  {k.sub && <Typography color="text.secondary" variant="caption">{k.sub}</Typography>}
                </Card>
              ))}
            </Box>

            {/* ★ 集計テーブル：カテゴリ×設備種別×設備名 */}
            <Box sx={{mb:1}}>
              <Typography variant="subtitle1" sx={{mb:0.5}}>
                カテゴリ × 設備種別ID × 設備名称ID 集計
              </Typography>
              <TableContainer component={Paper} variant="outlined" sx={{width:'100%', overflowX:'auto'}}>
                <Table size="small" stickyHeader sx={{width:'100%', minWidth: 960}}>
                  <TableHead>
                    <TableRow>
                      <TableCell>カテゴリ</TableCell>
                      <TableCell align="right">設備種別ID</TableCell>
                      <TableCell align="right">設備名称ID</TableCell>
                      <TableCell align="right">件数</TableCell>
                      <TableCell align="right">稼働</TableCell>
                      <TableCell align="right">点検中</TableCell>
                      <TableCell align="right">停止</TableCell>
                    </TableRow>
                  </TableHead>
                  <TableBody>
                    {rows.length ? rows.map((r,i)=>(
                      <TableRow key={i} hover>
                        <TableCell className="mono">{r.category}</TableCell>
                        <TableCell align="right" className="mono">{r.typeId}</TableCell>
                        <TableCell align="right" className="mono">{r.nameId}</TableCell>
                        <TableCell align="right" className="mono">{r.cnt}</TableCell>
                        <TableCell align="right" className="mono">{r.run}</TableCell>
                        <TableCell align="right" className="mono">{r.chk}</TableCell>
                        <TableCell align="right" className="mono">{r.stop}</TableCell>
                      </TableRow>
                    )) : (
                      <TableRow>
                        <TableCell colSpan={7} align="center">
                          <Typography color="text.secondary" sx={{py:1}}>該当データがありません</Typography>
                        </TableCell>
                      </TableRow>
                    )}
                  </TableBody>
                </Table>
              </TableContainer>
            </Box>

            {/* 元の明細テーブル（GenericPanel を内部で再利用） */}
            <GenericPanel
              title="設備明細"
              list={filtered}
              columns={columns}
              kpiFactory={()=>[]}        // KPIは上で出したので隠す
              filters={{...filters}}
            />
          </CardContent>
        </Card>
      );
    }
  },

  /* --- 店舗営業 --- */
ops:{
  title:"店舗営業管理",

  /* ====== 表の列 ====== */
  columns:[
    {key:'id',label:'ID',mono:true},
    {key:'category',label:'カテゴリ'},
    {key:'status',label:'状態',render:r=>{
      const on=!!r.status;
      return <Chip size="small" label={on?'有効':'無効'} color={on?'success':'default'} />;
    }},
    {key:'cycle_type',label:'サイクル'},
    {key:'rule',label:'繰り返しルール',render:r=>{
      const join=(a)=>a?.filter(Boolean).join(' / ');
      const weekly = r.weekday || r.day_of_week;
      const biwk  = r.biweekly_type; // 例: "第1・第3"
      const monthly = r.monthly_type ? `${r.monthly_type} ${r.monthly_nth||''}`.trim()
                     : (r.monthly_day?`${r.monthly_day}日`:'');
      const yearly = (r.yearly_month && r.yearly_day) ? `${r.yearly_month}月${r.yearly_day}日` : '';
      const repeat = r.repeat_unit ? `${r.repeat_unit}×${r.repeat_interval||1}` : '';
      const target = r.target_date || '';
      const map = {
        one_time: target || '単発',
        daily:    join([repeat]),
        weekly:   join([weekly, repeat]),
        biweekly: join([biwk, weekly, repeat]),
        monthly:  join([monthly, repeat]),
        yearly:   join([yearly, repeat]),
        adhoc:    target || '随時'
      };
      return map[r.cycle_type] || '—';
    }},
    {key:'time',label:'時間帯',render:r=> <span className="mono">{(r.start_time||'—')}~{(r.end_time||'—')}</span> },
    {key:'target_date',label:'対象日(単発/随時)',render:r=>r.target_date||'—'},
    {key:'is_holiday',label:'休日対応',render:r=> r.is_holiday ? <Chip size="small" label="祝/休日" /> : '—'},
    {key:'multi_mode',label:'同時実施',render:r=> r.multi_mode || '—'},
    {key:'count',label:'回数',align:'right',mono:true},
    {key:'terminate_condition',label:'終了条件',render:r=> r.terminate_condition || '—'},
    {key:'notes',label:'備考',render:r=>{
      const s=r.notes||''; const t=s||'—';
      const v=s.length>20?s.slice(0,20)+'…':t;
      return <span title={t}>{v}</span>;
    }},
    {key:'updated_at',label:'更新日',render:r=>{
      const f=(d)=>{ if(!d) return '—'; const dt=new Date(d); const y=dt.getFullYear(); const m=String(dt.getMonth()+1).padStart(2,'0'); const dd=String(dt.getDate()).padStart(2,'0'); return `${y}-${m}-${dd}`; };
      return <span className="mono">{f(r.updated_at)}</span>;
    }},
  ],

  /* ====== ダミー生成（既存のまま流用可） ====== */
  list:(rnd)=>Array.from({length:180}).map((_,i)=>{
    const id=i+1;
    const on = rnd() > 0.08 ? 1 : 0;
    const cats  = ['販促','時短営業','人員','イベント','安全対策','棚替え','価格改定'];
    const cycles= ['one_time','daily','weekly','biweekly','monthly','yearly','adhoc'];
    const cycle_type = cycles[Math.floor(rnd()*cycles.length)];

    const weekNames = ['月','火','水','木','金','土','日'];
    const weekday = weekNames.filter(()=>rnd()<0.35).join('・') || weekNames[Math.floor(rnd()*7)];
    const biweekly_type = rnd()<0.5 ? '第1・第3' : '第2・第4';
    const monthly_day = 1 + Math.floor(rnd()*28);
    const monthly_type = rnd()<0.5 ? '毎月' : '第';
    const monthly_nth = rnd()<0.5 ? '' : `${1+Math.floor(rnd()*4)} ${weekNames[Math.floor(rnd()*7)]}`;
    const yearly_month = 1 + Math.floor(rnd()*12);
    const yearly_day = 1 + Math.floor(rnd()*28);
    const repeat_unit = ['日','週','月','年'][Math.floor(rnd()*4)];
    const repeat_interval = 1 + Math.floor(rnd()*3);
    const hh=()=>String(8+Math.floor(rnd()*5)).padStart(2,'0');
    const mm=()=>['00','15','30','45'][Math.floor(rnd()*4)];
    const start_time = `${hh()}:${mm()}:00`;
    const end_time   = `${String(18+Math.floor(rnd()*3)).padStart(2,'0')}:${mm()}:00`;
    const target_date = rnd()<0.4 ? `2025-${String(1+Math.floor(rnd()*12)).padStart(2,'0')}-${String(1+Math.floor(rnd()*28)).padStart(2,'0')}` : '';
    const is_holiday = rnd()<0.2 ? 1 : 0;
    const multi_mode = rnd()<0.25 ? '並列' : '';
    const terminate_condition = rnd()<0.3 ? '回数到達' : (rnd()<0.5 ? '日付終了' : '');
    const count = rnd()<0.5 ? Math.floor(1 + rnd()*12) : null;
    const notes = rnd()<0.3 ? '夜間搬入あり／近隣注意' : '';

    const byCycle = {
      one_time:  { target_date: target_date || `2025-${String(1+Math.floor(rnd()*12)).padStart(2,'0')}-${String(1+Math.floor(rnd()*28)).padStart(2,'0')}`, repeat_unit:'', repeat_interval:null },
      daily:     { weekday:'', monthly_day:null, yearly_month:null, yearly_day:null, target_date:'' },
      weekly:    { weekday, target_date:'' },
      biweekly:  { weekday, biweekly_type, target_date:'' },
      monthly:   { monthly_type, monthly_day, monthly_nth, target_date:'' },
      yearly:    { yearly_month, yearly_day, target_date:'' },
      adhoc:     { target_date: target_date || '随時', repeat_unit:'', repeat_interval:null }
    }[cycle_type] || {};

    return {
      id,
      status: on,
      category: cats[Math.floor(rnd()*cats.length)],
      store_or_tenant_id_key: 1 + Math.floor(rnd()*500),
      cycle_type,
      day_of_week: undefined,
      target_date: byCycle.target_date ?? target_date,
      start_time, end_time,
      notes,
      created_at: new Date(), created_by: 'system',
      updated_at: new Date(), updated_by: 'system',
      is_deleted: rnd()<0.02 ? 1 : 0,
      is_holiday,
      multi_mode,
      biweekly_type: byCycle.biweekly_type || '',
      monthly_day: byCycle.monthly_day ?? null,
      monthly_nth: byCycle.monthly_nth || '',
      weekday: byCycle.weekday || weekday,
      yearly_month: byCycle.yearly_month ?? null,
      yearly_day: byCycle.yearly_day ?? null,
      count,
      terminate_condition,
      pattern: '',
      monthly_type: byCycle.monthly_type || '',
      repeat_unit: byCycle.repeat_unit ?? repeat_unit,
      repeat_interval: byCycle.repeat_interval ?? repeat_interval,
      end_date: rnd()<0.4 ? new Date(2026, Math.floor(rnd()*12), 1+Math.floor(rnd()*27)) : null,
      details: rnd()<0.2 ? '詳細手順: 什器移設→清掃→陳列' : '',

      // App 側で STOREID を割当
      facility: null
    };
  }),

  /* ====== KPI ====== */
  kpi:(rows)=>{
    const valid = rows.filter(x=>!x.is_deleted);
    const total = valid.length;
    const active = valid.filter(x=>x.status).length;
    const byCycle = (t)=> valid.filter(x=>x.cycle_type===t).length;
    const holidays = valid.filter(x=>x.is_holiday).length;

    const now = new Date();
    const ym = `${now.getFullYear()}-${String(now.getMonth()+1).padStart(2,'0')}-`;
    const oneOffThisMonth = valid.filter(x=>{
      if(!x.target_date) return false;
      return typeof x.target_date === 'string' && x.target_date.startsWith(ym);
    }).length;

    return [
      {label:'施策件数', value: total},
      {label:'有効率', value: total? Math.round(active/total*100)+'%':'—', sub:`有効 ${active} 件`},
      {label:'休日対応', value: holidays},
      {label:'単発/随時 (今月)', value: oneOffThisMonth},
      {label:'周期内訳', value: `日:${byCycle('daily')} 週:${byCycle('weekly')} 隔週:${byCycle('biweekly')} 月:${byCycle('monthly')} 年:${byCycle('yearly')}`}
    ];
  },

  /* ====== Custom: KPI + 店舗ごとの営業時間サマリ + 通常テーブル ====== */
  Custom: ({ title, list, columns, kpiFactory, filters })=>{
    // 1) 統合フィルタ適用（施設・状態・全文）
    const filtered = React.useMemo(()=>{
      const q = (filters.q||'').toLowerCase();
      const keys = ['id','category','cycle_type','weekday','target_date','notes','multi_mode'];
      return list.filter(r=>{
        const st = typeof r.status==='string' ? r.status : (r.status ? '有効' : '無効');
        const matchFacility = !filters.facilities.length || filters.facilities.includes(r.facility);
        const matchStatus   = !filters.statuses.length || filters.statuses.includes(st);
        const matchQuery    = !q || keys.some(k => String(r[k]??'').toLowerCase().includes(q));
        return matchFacility && matchStatus && matchQuery;
      });
    },[list,filters]);

    // 2) KPI（そのまま）
    const kpis = (kpiFactory||((rs)=>[{label:'件数',value:rs.length}]))(filtered);

    // 3) 営業時間サマリを構成
    const weekKeys = ['月','火','水','木','金','土','日'];
    function parseWeekdays(s){
      if(!s) return [];
      return weekKeys.filter(k=>s.includes(k));
    }
    // facility → { label, days:{月:"09:00~21:00",...}, holiday:"…"}
    const hourMap = new Map();
    filtered.forEach(r=>{
      if(!r.status || r.is_deleted) return; // 有効のみ
      if(!['daily','weekly','biweekly'].includes(r.cycle_type)) return; // 営業時間に採用する周期
      const fac = r.facility;
      if(!fac) return;
      if(!hourMap.has(fac)) hourMap.set(fac, { label: fac, days:{}, holiday:'' });
      const slot = `${(r.start_time||'').slice(0,5)}~${(r.end_time||'').slice(0,5)}`;

      const rec = hourMap.get(fac);
      const put = (d)=>{ // 最頻出の時間帯を採用
        const cur = rec.days[d] || {};
        const cnt = cur[slot] ? cur[slot]+1 : 1;
        cur[slot] = cnt;
        rec.days[d] = cur;
      };

      if(r.cycle_type==='daily'){
        weekKeys.forEach(put);
      }else{
        const days = parseWeekdays(r.weekday || r.day_of_week || '');
        (days.length?days:weekKeys).forEach(put);
      }

      if(r.is_holiday){
        rec.holiday = slot; // 祝日は最後に見たもの
      }
    });

    // 表示用に最頻出を選ぶ
    const hourRows = Array.from(hourMap.values()).map(rec=>{
      const daysDisp = {};
      weekKeys.forEach(d=>{
        const freq = rec.days[d];
        if(!freq){ daysDisp[d]='—'; return; }
        // 最大出現の時間帯
        const top = Object.entries(freq).sort((a,b)=>b[1]-a[1])[0]?.[0];
        daysDisp[d] = top || '—';
      });
      return { facility: rec.label, ...daysDisp, holiday: rec.holiday || '—' };
    }).sort((a,b)=>a.facility.localeCompare(b.facility));

    return (
      <Card>
        <CardContent>
          <Typography variant="h6" sx={{mb:1}}>{title}</Typography>

          {/* KPI */}
          <Box className="kpi" sx={{mb:1}}>
            {kpis.map(k=>(
              <Card key={k.label} variant="outlined" sx={{p:1}}>
                <Typography color="text.secondary" variant="body2">{k.label}</Typography>
                <Typography variant="h6" className="mono">{k.value}</Typography>
                {k.sub && <Typography color="text.secondary" variant="caption">{k.sub}</Typography>}
              </Card>
            ))}
          </Box>

          {/* 店舗ごとの営業時間（週次サマリ） */}
          <Box sx={{mb:1}}>
            <Typography variant="subtitle1" sx={{mb:0.5}}>店舗ごとの営業時間（週次サマリ）</Typography>
            <TableContainer component={Paper} variant="outlined" sx={{width:'100%', overflowX:'auto'}}>
              <Table size="small" stickyHeader sx={{width:'100%', minWidth: 960}}>
                <TableHead>
                  <TableRow>
                    <TableCell>STOREID</TableCell>
                    {weekKeys.map(d=><TableCell key={d} align="center">{d}</TableCell>)}
                    <TableCell align="center">祝/休日</TableCell>
                  </TableRow>
                </TableHead>
                <TableBody>
                  {hourRows.length? hourRows.map(r=>(
                    <TableRow key={r.facility} hover>
                      <TableCell className="mono">{r.facility}</TableCell>
                      {weekKeys.map(d=><TableCell key={d} align="center" className="mono">{r[d]}</TableCell>)}
                      <TableCell align="center" className="mono">{r.holiday}</TableCell>
                    </TableRow>
                  )):(
                    <TableRow><TableCell colSpan={weekKeys.length+2} align="center">
                      <Typography color="text.secondary" sx={{py:1}}>該当データがありません</Typography>
                    </TableCell></TableRow>
                  )}
                </TableBody>
              </Table>
            </TableContainer>
          </Box>

          {/* 通常のデータテーブル（GenericPanelを内部で利用） */}
          <GenericPanel
            title="登録明細"
            list={filtered}
            columns={columns}
            kpiFactory={()=>[]}    // 二重KPIは非表示
            filters={{...filters}} // そのまま
          />
        </CardContent>
      </Card>
    );
  }
}
,

  /* --- 契約 --- */
contract:{
  title:"契約管理",
  // （GenericPanel 側でテーブルは nowrap + ellipsis。横は自動スクロール）
  columns:[
    {key:'contract_id',label:'契約ID',mono:true},
    {key:'title',label:'タイトル'},
    {key:'contract_type',label:'契約種別'},
    {key:'status',label:'状態',render:r=>{
      const on=!!r.status;
      return <Chip size="small" label={on?'有効':'無効'} color={on?'success':'default'} />;
    }},
    {key:'holder',label:'契約者/オーナー',render:r=><span>{r.contract_holder||'—'} / {r.owner||`#${r.owner_id_key??'—'}`}</span>},
    {key:'period',label:'現在契約(開始~終了)',render:r=>{
      const f=d=>d?new Date(d).toISOString().slice(0,10):'—';
      return <span className="mono">{f(r.current_contract_start_date)} ~ {f(r.current_contract_end_date)}</span>;
    }},
    {key:'area',label:'面積(㎡/坪)',align:'right',mono:true,render:r=>{
      const m2=Number(r.area)||0, t=Number(r.area_tsubo)||0;
      return `${m2.toLocaleString(undefined,{maximumFractionDigits:2})} / ${t.toLocaleString(undefined,{maximumFractionDigits:2})}`;
    }},
    {key:'fixed_rent',label:'固定賃料',align:'right',mono:true,render:r=>(Number(r.fixed_rent)||0).toLocaleString()},
    {key:'variable_rent',label:'変動賃料',align:'right',mono:true,render:r=>(Number(r.variable_rent)||0).toLocaleString()},
    {key:'rent_per_tsubo',label:'坪賃料',align:'right',mono:true,render:r=>(Number(r.rent_per_tsubo)||0).toLocaleString()},
    {key:'fees',label:'共益/光熱/看板',align:'right',mono:true,render:r=>{
      const a=(n)=> (Number(n)||0).toLocaleString();
      return `${a(r.common_service_fee)}/${a(r.water_light_heat_fee)}/${a(r.signboard_fee)}`;
    }},
    {key:'deposit',label:'敷金/保証金',align:'right',mono:true,render:r=>{
      const a=(n)=> (Number(n)||0).toLocaleString();
      return `${a(r.deposit)} / ${a(r.guarantee_deposit)}`;
    }},
    {key:'commission_fee',label:'仲介手数料',align:'right',mono:true,render:r=>(Number(r.commission_fee)||0).toLocaleString()},
    {key:'support_penalty',label:'施主支援/違約金',align:'right',mono:true,render:r=>{
      const a=(n)=> (Number(n)||0).toLocaleString();
      return `${a(r.construction_support)} / ${a(r.penalty_fee)}`;
    }},
    {key:'early_termination',label:'途中解約',render:r=>r.early_termination? <Chip size="small" label="有" /> : '—'},
    {key:'cancellation_date',label:'解約日',render:r=>r.cancellation_date? <span className="mono">{new Date(r.cancellation_date).toISOString().slice(0,10)}</span>:'—'},
    {key:'renewal_conditions',label:'更新条件',render:r=>{
      const s=r.renewal_conditions||''; return s.length>14? s.slice(0,14)+'…':(s||'—');
    }},
    {key:'rent_adjustment_conditions',label:'賃料改定',render:r=>{
      const s=r.rent_adjustment_conditions||''; return s.length>14? s.slice(0,14)+'…':(s||'—');
    }},
    {key:'pdfs',label:'添付',render:r=>{
      const flags=[
        r.pdf_contract && '契約',
        r.pdf_previous_plan && '旧計画',
        r.pdf_store_plan && '現計画',
        r.pdf_construction_type && '工事仕様'
      ].filter(Boolean);
      return flags.length?flags.join('・'):'—';
    }},
    {key:'manager_id',label:'管理者ID',mono:true},
    {key:'updated_at',label:'更新日',render:r=>r.updated_at?<span className="mono">{new Date(r.updated_at).toISOString().slice(0,10)}</span>:'—'}
  ],

  // ダミーデータ生成（実データ差し替え前提）
  list:(rnd)=>Array.from({length:180}).map((_,i)=>{
    const id=i+1;
    const active = rnd()>0.08 ? 1 : 0;             // 92% 有効
    const ctTypes=['賃貸','転貸','保守','広告','施設利用'];
    const titles=['本契約','覚書','変更合意','更新契約','暫定'];
    const holders=['当社','テナントA','テナントB','デベロッパー','管理会社'];
    const owners=['物件オーナー','サブオーナー','地権者'];
    const y0 = 2016+Math.floor(rnd()*6);
    const origStart = new Date(y0, Math.floor(rnd()*12), 1+Math.floor(rnd()*27));
    const origEnd   = new Date(y0+3+Math.floor(rnd()*4), Math.floor(rnd()*12), 1+Math.floor(rnd()*27));
    const curStart  = new Date(origEnd.getFullYear()-1, Math.floor(rnd()*12), 1+Math.floor(rnd()*27));
    const curEnd    = new Date(curStart.getFullYear()+1+Math.floor(rnd()*3), Math.floor(rnd()*12), 1+Math.floor(rnd()*27));
    const cancel    = rnd()<0.1 ? new Date(curStart.getFullYear(), curStart.getMonth()+Math.floor(rnd()*6), curStart.getDate()+Math.floor(rnd()*20)) : null;

    const area = +(50 + rnd()*950).toFixed(2);         // 50〜1000 ㎡
    const tsubo = +(area/3.3058).toFixed(2);
    const base  = +(300 + rnd()*4700).toFixed(2);      // 固定賃料
    const varr  = +(rnd()*800).toFixed(2);
    const perT  = +(base / (tsubo || 1)).toFixed(2);
    const fee   = +(rnd()*200).toFixed(2);
    const whl   = +(rnd()*150).toFixed(2);
    const sign  = +(rnd()*100).toFixed(2);
    const comm  = +(rnd()*500).toFixed(2);
    const depo  = +(base * (1.5 + rnd()*3)).toFixed(2);
    const gdep  = +(base * (0.5 + rnd()*1.5)).toFixed(2);
    const support = +(rnd()*1000).toFixed(2);
    const penalty = +(rnd()*1200).toFixed(2);

    return {
      // スキーマ 1〜47
      id,                                                 // 1
      store_id_key: 1 + Math.floor(rnd()*200),            // 2
      contract_id: `CT-${String(100000+id).slice(-6)}`,   // 3
      status: active,                                     // 4 tinyint(1)
      contract_type: pick(rnd, ctTypes),                  // 5
      title: `${pick(rnd,titles)} ${id}`,                 // 6
      contract_holder: pick(rnd, holders),                // 7
      owner_id_key: 100 + Math.floor(rnd()*900),          // 8
      detail_content: rnd()<0.5 ? '原状回復特約あり・共益費見直し条項' : '', // 9
      manager_id: `MG-${String(1000+Math.floor(rnd()*9000))}`, // 10
      parent_contract_id: rnd()<0.4 ? `CT-${String(900000+Math.floor(rnd()*9000))}` : '', // 11
      issue_date: new Date(y0, 0, 1),                     // 12
      original_contract_start_date: origStart,            // 13
      original_contract_end_date: origEnd,                // 14
      original_contract_type: pick(rnd, ctTypes),         // 15
      current_contract_start_date: curStart,              // 16
      current_contract_end_date: curEnd,                  // 17
      cancellation_date: cancel,                          // 18
      area,                                               // 19
      area_tsubo: tsubo,                                  // 20
      fixed_rent: base,                                   // 21
      variable_rent: varr,                                // 22
      rent_per_tsubo: perT,                               // 23
      common_service_fee: fee,                            // 24
      water_light_heat_fee: whl,                          // 25
      signboard_fee: sign,                                // 26
      commission_fee: comm,                               // 27
      deposit: depo,                                      // 28
      guarantee_deposit: gdep,                            // 29
      construction_support: support,                      // 30
      penalty_fee: penalty,                               // 31
      early_termination: rnd()<0.06 ? 1 : 0,              // 32
      notice_period: Math.floor(1 + rnd()*12),            // 33 (ヶ月)
      renewal_conditions: rnd()<0.6 ? '自動更新/1年毎' : '協議更新', // 34
      rent_adjustment_conditions: rnd()<0.5 ? '指数連動/上限10%' : '据置/協議', // 35
      owner: pick(rnd, owners),                           // 36
      owner_contact: rnd()<0.5 ? 'owner@example.com' : '—', // 37
      pdf_contract: rnd()<0.5 ? 'contract.pdf' : '',      // 38
      pdf_previous_plan: rnd()<0.3 ? 'plan_prev.pdf' : '',// 39
      pdf_store_plan: rnd()<0.4 ? 'plan_store.pdf' : '',  // 40
      pdf_construction_type: rnd()<0.3 ? 'construction.txt': '', // 41
      notes: rnd()<0.25 ? '明渡し時期は要事前協議' : '', // 42
      created_at: new Date(),                             // 43
      created_by: 'system',                               // 44
      updated_at: new Date(),                             // 45
      updated_by: 'system',                               // 46
      is_deleted: rnd()<0.02 ? 1 : 0,                     // 47

      // 統合フィルタ（App 側で STOREID を割当）
      facility: null
    };
  }),

  // KPI：件数／有効率／固定賃料合計／坪賃料平均／180日以内満了／途中解約
  kpi:(rows)=>{
    const valid = rows.filter(x=>!x.is_deleted);
    const total = valid.length;
    const active = valid.filter(x=>x.status).length;
    const sumFixed = valid.reduce((s,x)=>s+(Number(x.fixed_rent)||0),0);
    const tsuboList = valid.map(x=>Number(x.rent_per_tsubo)).filter(v=>!isNaN(v)&&v>0);
    const avgRentTsubo = tsuboList.length ? tsuboList.reduce((a,b)=>a+b,0)/tsuboList.length : 0;

    const now = new Date();
    const in180 = new Date(now.getTime() + 180*24*60*60*1000);
    const expSoon = valid.filter(x=>{
      const d=x.current_contract_end_date? new Date(x.current_contract_end_date):null;
      return d && d>=now && d<=in180;
    }).length;

    const early = valid.filter(x=>x.early_termination).length;

    return [
      {label:'契約件数', value: total},
      {label:'有効率', value: total? Math.round(active/total*100)+'%' : '—', sub:`有効 ${active} 件`},
      {label:'固定賃料 合計', value: sumFixed.toLocaleString(undefined,{maximumFractionDigits:0})},
      {label:'坪賃料 平均', value: avgRentTsubo.toLocaleString(undefined,{maximumFractionDigits:0})},
      {label:'満了予定(～180日)', value: expSoon},
      {label:'途中解約', value: early}
    ];
  }
},

  /* --- 建物 --- */
building:{
  title:"建物情報管理",
  // テーブル列（GenericPanel 側で nowrap + ellipsis + 横スクロール）
  columns:[
    {key:'building_id',label:'建物ID',mono:true},
    {key:'building_name',label:'建物名'},
    {key:'building_type',label:'建物区分'},
    {key:'construction_type',label:'構造'},
    {key:'floors',label:'階数(地上/地下/使用)',render:r=><span className="mono">{r.floors_above}/{r.floors_below}/{r.occupied_floors}</span>},
    {key:'ceiling_height',label:'階高(天井高)'},
    {key:'ceiling_specification',label:'天井仕様'},
    {key:'building_area',label:'建築面積(㎡)',align:'right',mono:true,render:r=>{
      const v=Number(r.building_area)||0; return v.toLocaleString(undefined,{minimumFractionDigits:2,maximumFractionDigits:2});
    }},
    {key:'total_floor_area',label:'延床面積(㎡)',align:'right',mono:true,render:r=>{
      const v=Number(r.total_floor_area)||0; return v.toLocaleString(undefined,{minimumFractionDigits:2,maximumFractionDigits:2});
    }},
    {key:'universal_design_support',label:'UD対応',render:r=>r.universal_design_support? '対応':'—'},
    {key:'design_office',label:'設計事務所'},
    {key:'current_design_office',label:'現設計事務所'},
    {key:'designer',label:'設計者'},
    {key:'store_development_manager',label:'店舗開発担当'},
    {key:'contract_id_key',label:'契約Key',align:'right',mono:true},
    {key:'pdfs',label:'図書/書類',render:r=>{
      const flags=[
        r.pdf_key_number_list && '鍵No.',
        r.pdf_key_layout && '鍵レイアウト',
        r.pdf_fire_equipment_layout && '防災図',
        r.pdf_construction_company_list && '施工会社'
      ].filter(Boolean);
      return flags.length?flags.join('・'):'—';
    }},
    {key:'notes',label:'備考',render:r=>{
      const s=r.notes||''; return s.length>20? s.slice(0,20)+'…':(s||'—');
    }},
    {key:'status',label:'状態',render:r=>{
      const on=!!r.status; return <Chip size="small" label={on?'有効':'無効'} color={on?'success':'default'}/>;
    }},
    {key:'updated_at',label:'更新日',render:r=>r.updated_at?<span className="mono">{new Date(r.updated_at).toISOString().slice(0,10)}</span>:'—'}
  ],

  // ダミーデータ生成（実データ差し替え前提）
  list:(rnd)=>Array.from({length:90}).map((_,i)=>{
    const id=i+1;
    const statusFlag = rnd() > 0.06 ? 1 : 0; // ≒94% 有効
    const floorsAbove = 1 + Math.floor(rnd()*10);      // 1〜10F
    const floorsBelow = rnd()<0.25 ? Math.floor(1+rnd()*3) : 0; // 地下0〜3
    const occupied    = Math.min(floorsAbove + floorsBelow, Math.max(1, Math.floor(1+rnd()*(floorsAbove+floorsBelow))));
    const bArea  = +(200 + rnd()*1800).toFixed(2);     // 200〜2000㎡
    const tArea  = +(bArea * (occupied || 1) * (0.8 + rnd()*0.6)).toFixed(2); // 係数で延床
    const ceilH  = (2.6 + rnd()*1.0).toFixed(2);       // 2.60〜3.60m
    const ceilSpec = pick(rnd,['スケルトン','化粧吸音板','軽天PB','ジプトーン','木質意匠']);
    const bType  = pick(rnd,['店舗併用','商業ビル','複合','倉庫','研究']);
    const constType = pick(rnd,['S造','RC造','SRC造','木造']);
    const offices = ['アーク設計','ブランチ設計','クレスト計画','デルタデザイン','エコー建築'];
    const managers = ['田中','佐藤','鈴木','高橋','伊藤','渡辺'];
    return {
      // スキーマ準拠 1〜31
      id,                                           // 1
      store_id_key: 1 + Math.floor(rnd()*200),      // 2
      building_id: `BL-${String(10000+id)}`,        // 3
      status: statusFlag,                           // 4 tinyint(1)
      building_name: `建物${id}`,                   // 5
      building_type: bType,                         // 6
      construction_type: constType,                 // 7
      floors_above: String(floorsAbove),            // 8 (varchar仕様)
      floors_below: String(floorsBelow),            // 9
      occupied_floors: String(occupied),            // 10
      rooftop_waterproof_specification: pick(rnd,['アスファルト','シート防水','FRP','ウレタン']), // 11
      ceiling_height: `${ceilH} m`,                 // 12 (varchar)
      building_area: bArea,                         // 13
      total_floor_area: tArea,                      // 14
      universal_design_support: rnd()<0.7 ? 1 : 0,  // 15
      design_office: pick(rnd,offices),             // 16
      designer: `設計 ${Math.ceil(rnd()*200)}`,     // 17
      store_development_manager: `${pick(rnd,managers)}（開発）`, // 18
      contract_id_key: Math.floor(1000 + rnd()*9000), // 19
      pdf_key_number_list: rnd()<0.35 ? 'key_numbers.pdf': '', // 20
      pdf_key_layout: rnd()<0.3 ? 'key_layout.pdf': '',        // 21
      pdf_fire_equipment_layout: rnd()<0.4 ? 'fire_layout.pdf': '', // 22
      pdf_construction_company_list: rnd()<0.25 ? 'builders.csv': '', // 23
      notes: rnd()<0.25 ? '機械室増設計画あり／防水改修検討' : '', // 24
      created_at: new Date(),                        // 25
      created_by: 'system',                          // 26
      updated_at: new Date(),                        // 27
      updated_by: 'system',                          // 28
      is_deleted: rnd()<0.02 ? 1 : 0,                // 29
      ceiling_specification: ceilSpec,               // 30
      current_design_office: rnd()<0.5 ? pick(rnd,offices) : '', // 31

      // 統合フィルタ（App 側で STOREID を割当：facility は後段で上書き）
      facility: null
    };
  }),

  // KPI：件数 / 有効率 / 総延床面積 / 平均建築面積 / UD対応棟 / 図書あり
  kpi:(rows)=>{
    const valid = rows.filter(x=>!x.is_deleted);
    const total = valid.length;
    const active = valid.filter(x=>x.status).length;
    const sumTfa = valid.reduce((s,x)=>s+(Number(x.total_floor_area)||0),0);
    const avgBld = total ? valid.reduce((s,x)=>s+(Number(x.building_area)||0),0)/total : 0;
    const udCnt  = valid.filter(x=>x.universal_design_support).length;
    const files  = valid.filter(x=>x.pdf_key_number_list||x.pdf_key_layout||x.pdf_fire_equipment_layout||x.pdf_construction_company_list).length;

    return [
      {label:'建物数', value: total},
      {label:'有効率', value: total? Math.round(active/total*100)+'%':'—', sub:`有効 ${active} 棟`},
      {label:'総延床面積(㎡)', value: sumTfa.toLocaleString(undefined,{maximumFractionDigits:0})},
      {label:'平均建築面積(㎡)', value: avgBld.toLocaleString(undefined,{maximumFractionDigits:0})},
      {label:'UD対応', value: udCnt},
      {label:'図書あり', value: files}
    ];
  }
}
,

  /* --- 取引先 --- */
client:{
  title:"取引先管理",
  // テーブル列（GenericPanel 側で nowrap + ellipsis + 横スクロール）
  columns:[
    {key:'torihiki_id',label:'取引先ID',mono:true},
    {key:'torihiki_name',label:'取引先名'},
    {key:'torihiki_type',label:'区分'},
    {key:'category',label:'カテゴリ'},
    {key:'status',label:'状態',render:r=>{
      // tinyint(1) → 表示「有効/無効」
      const on = !!r.status;
      return <Chip size="small" label={on?'有効':'無効'} color={on?'success':'default'} />;
    }},
    {key:'responsible_area',label:'担当エリア'},
    {key:'responsible_name',label:'担当者'},
    {key:'phone',label:'電話(昼)',mono:true},
    {key:'phone_night',label:'電話(夜間)',mono:true},
    {key:'mobile_phone',label:'携帯',mono:true},
    {key:'email',label:'メール'},
    {key:'notes',label:'備考',render:r=>{
      const s=r.notes||''; return s.length>20? s.slice(0,20)+'…':(s||'—');
    }},
    {key:'updated_at',label:'更新日',render:r=>{
      return r.updated_at ? <span className="mono">{new Date(r.updated_at).toISOString().slice(0,10)}</span> : '—';
    }},
  ],

  // ダミーデータ生成（実データ差し替え前提）
  list:(rnd)=>Array.from({length:140}).map((_,i)=>{
    const id=i+1;
    const on = rnd() > 0.08 ? 1 : 0; // 92% 有効
    const types = ['仕入先','販売先','委託先','保守業者','清掃業者','設備業者'];
    const cats  = ['一次','二次','重要','一般'];
    const areas = ['関東','関西','中部','北海道・東北','中国・四国','九州'];
    const nameSeed = ['アルファ','ブリッジ','クリエイト','デルタ','エコー','フロンティア','グロース','ハーモニー'];
    const pickNum = ()=>String(Math.floor(1000 + rnd()*9000));
    const tel = (pfx)=>`${pfx}-${pickNum()}-${pickNum()}`;
    const maybe = (v)=> rnd()<0.15 ? '' : v; // 15% 欠損を混ぜる

    return {
      // スキーマ準拠
      id,                                   // 1
      torihiki_id: `TR-${String(10000+id)}`,// 2
      store_id_key: 1 + Math.floor(rnd()*200), // 3
      status: on,                           // 4 tinyint(1)
      torihiki_type: pick(rnd, types),      // 5
      torihiki_name: `${pick(rnd,nameSeed)}商事 ${id}`, // 6
      category: pick(rnd, cats),            // 7
      responsible_area: pick(rnd, areas),   // 8
      responsible_name: `担当${Math.ceil(rnd()*500)}`,  // 9
      email: maybe(`contact${id}@example.com`),         // 10
      phone: maybe(tel('03')),              // 11
      phone_night: maybe(tel('050')),       // 12
      mobile_phone: maybe(tel('090')),      // 13
      notes: rnd()<0.25 ? '夜間対応可／緊急時は携帯へ' : '', // 14
      created_at: new Date(),               // 15
      created_by: 'system',                 // 16
      updated_at: new Date(),               // 17
      updated_by: 'system',                 // 18
      is_deleted: rnd()<0.02 ? 1 : 0,       // 19

      // 統合フィルタ（App 側で STOREID を割当：facility は後段で上書き）
      facility: null
    };
  }),

  // KPI：件数／有効率／連絡先充足／夜間連絡先あり
  kpi:(rows)=>{
    const valid = rows.filter(x=>!x.is_deleted);
    const total = valid.length;
    const active = valid.filter(x=>x.status).length;
    const hasPhone = valid.filter(x=>x.phone || x.mobile_phone).length;
    const hasMail  = valid.filter(x=>x.email).length;
    const hasNight = valid.filter(x=>x.phone_night).length;

    return [
      {label:'取引先数', value: total},
      {label:'有効率', value: total? Math.round(active/total*100)+'%':'—', sub:`有効 ${active} 件`},
      {label:'電話/携帯 登録', value: `${hasPhone}/${total}`},
      {label:'メール 登録', value: `${hasMail}/${total}`},
      {label:'夜間連絡先 あり', value: hasNight}
    ];
  }
}
,

  /* --- 売上 --- */
sales:{
  title:"売上管理（計画/実績）",

  // ========= 明細テーブルの列 =========
  columns:[
    {key:'year',label:'年度',mono:true,align:'right'},
    {key:'type_sale',label:'区分(計画/実績)',render:r=>{
      const isPlan = r.type_sale==='計画';
      return <Chip size="small" label={r.type_sale} color={isPlan?'default':'primary'} />;
    }},
    {key:'annual_sales',label:'年間金額(千円)',align:'right',mono:true,
      render:r=>(Number(r.annual_sales)||0).toLocaleString()},
    {key:'status',label:'状態',render:r=>{
      const on = r.status==='有効';
      return <Chip size="small" label={on?'有効':'無効'} color={on?'success':'default'} />;
    }},
    {key:'notes',label:'備考',render:r=>{
      const s=r.notes||''; const t=s||'—';
      const v=s.length>24? s.slice(0,24)+'…' : t;
      return <span title={t}>{v}</span>;
    }},
    {key:'updated_at',label:'更新日',render:r=>{
      if(!r.updated_at) return '—';
      const d=new Date(r.updated_at), y=d.getFullYear(), m=String(d.getMonth()+1).padStart(2,'0'), dd=String(d.getDate()).padStart(2,'0');
      return <span className="mono">{`${y}-${m}-${dd}`}</span>;
    }},
  ],

  // ========= ダミーデータ（実データと差し替え可） =========
  list:(rnd)=>Array.from({length:260}).map((_,i)=>{
    const id=i+1;
    const year = 2018 + Math.floor(rnd()*8); // 2018〜2025
    const type_sale = rnd()<0.5 ? '計画' : '実績';
    const base = [5000,12000,30000,60000][Math.floor(rnd()*4)];
    const annual_sales = +( (type_sale==='計画'
      ? base*(0.8 + rnd()*0.6)   // 計画
      : base*(0.7 + rnd()*0.8))  // 実績
    ).toFixed(2);
    const deleted = rnd()<0.02 ? 1 : 0;

    return {
      id,
      store_id_key: 1 + Math.floor(rnd()*400),
      year,
      annual_sales,
      created_at: new Date(),
      updated_at: new Date(),
      created_by: 'system',
      updated_by: 'system',
      is_deleted: deleted,
      notes: rnd()<0.15 ? (type_sale==='計画'?'見直し中':'改装影響あり') : '',
      type_sale,                       // ← 計画 or 実績
      status: deleted ? '無効' : '有効', // 統合状態フィルタ対応
      facility: null                   // STOREID は App 側で付与
    };
  }),

  // ========= KPI（計画/実績/差分/達成率） =========
  kpi:(rows)=>{
    const valid = (Array.isArray(rows)? rows : []).filter(x=>!x.is_deleted);
    const keyOf = (r)=>`${r.facility||'NA'}|${r.year}`;
    const bucket = new Map(); // key -> {plan, actual}

    for (const r of valid) {
      const k = keyOf(r);
      if (!bucket.has(k)) bucket.set(k, { plan: 0, actual: 0 });
      const v = Number(r.annual_sales) || 0;

      // ❌ (cond ? bucket.get(k).plan : bucket.get(k).actual) += v;
      // ✅ 左辺を確定させてから加算
      if (r.type_sale === '計画') {
        bucket.get(k).plan += v;
      } else {
        bucket.get(k).actual += v;
      }
    }

    let sumPlan = 0, sumActual = 0;
    bucket.forEach(({plan, actual}) => { sumPlan += plan; sumActual += actual; });

    const diff = sumActual - sumPlan;
    const rate = sumPlan ? Math.round((sumActual / sumPlan - 1) * 100) : null;

    // 最新年度
    const years = Array.from(new Set(valid.map(r => Number(r.year)).filter(n=>!isNaN(n)))).sort((a,b)=>a-b);
    let latest='—', lp=0, la=0, lrate='—';
    if (years.length) {
      latest = years[years.length - 1];
      for (const [k, v] of bucket.entries()) {
        const y = Number(k.split('|')[1]);
        if (y === latest) { lp += v.plan; la += v.actual; }
      }
      const lr = lp ? Math.round((la / lp - 1) * 100) : null;
      lrate = lr == null ? '—' : (lr >= 0 ? `+${lr}%` : `${lr}%`);
    }

    return [
      {label:'計画 合計(千円)', value: sumPlan.toLocaleString()},
      {label:'実績 合計(千円)', value: sumActual.toLocaleString()},
      {label:'差分(実績-計画)', value: diff.toLocaleString(), sub: rate==null?'—':`達成率 ${rate>=0?'+':''}${rate}%`},
      {label:`最新年(${latest}) 計画/実績`, value: `${lp.toLocaleString()} / ${la.toLocaleString()}`, sub:`差分 ${(la-lp).toLocaleString()}（${lrate}）`}
    ];
  },

  // ========= Custom：KPI → 年度ピボット表 → 明細テーブル =========
  Custom: ({ title, list, columns, kpiFactory, filters })=>{
    // === 防御的デフォルト ===
    const safeFilters = React.useMemo(()=>({
      q: '',
      facilities: [],
      statuses: [],
      ...(filters||{})
    }),[filters]);
    const safeList = React.useMemo(()=>{
      if (Array.isArray(list)) return list;
      if (typeof list === 'function') {
        try { return list(Math.random); } catch { return []; }
      }
      return [];
    },[list]);

    // 1) 統合フィルタを適用
    const filtered = React.useMemo(()=>{
      const q=(safeFilters.q||'').toLowerCase();
      const keys=['year','type_sale','annual_sales','notes'];
      const facList = Array.isArray(safeFilters.facilities)? safeFilters.facilities : [];
      const stList  = Array.isArray(safeFilters.statuses)?   safeFilters.statuses   : [];
      return safeList.filter(r=>{
        const st = r.status; // '有効'/'無効'
        const facNorm = (r.facility ?? 'NA'); // ピボット側と同じ正規化
        const matchFacility = !facList.length || facList.includes(facNorm);
        const matchStatus   = !stList.length  || stList.includes(st);
        const matchQuery    = !q || keys.some(k=>String(r[k]??'').toLowerCase().includes(q));
        return matchFacility && matchStatus && matchQuery;
      });
    },[safeList,safeFilters]);

    // 2) KPI
    const kpis=(kpiFactory||((rs)=>[{label:'件数',value:rs.length}]))(filtered);

    // 3) 年度ピボット表データ作成
    const valid = filtered.filter(x=>!x.is_deleted);
    const years = Array.from(new Set(valid.map(r=>Number(r.year)).filter(n=>!isNaN(n)))).sort((a,b)=>a-b);
    const facMap = new Map(); // facility -> {plan: Map<year,num>, actual: Map<year,num>}
    for(const r of valid){
      const fac = r.facility || 'NA';
      if(!facMap.has(fac)) facMap.set(fac,{plan:new Map(),actual:new Map()});
      const map = r.type_sale==='計画'? facMap.get(fac).plan : facMap.get(fac).actual;
      const y=Number(r.year), v=Number(r.annual_sales)||0;
      map.set(y,(map.get(y)||0)+v);
    }
    const rows = [];
    const fmt = (v)=> (v||0).toLocaleString();
    Array.from(facMap.keys()).sort().forEach(fac=>{
      const {plan,actual}=facMap.get(fac);
      const sumPlan = years.reduce((s,y)=>s+(plan.get(y)||0),0);
      const sumAct  = years.reduce((s,y)=>s+(actual.get(y)||0),0);
      const diff    = sumAct - sumPlan;
      const rate    = sumPlan? Math.round((sumAct/sumPlan-1)*100) : null;

      // 計画行
      rows.push({
        facility:fac, kind:'計画',
        cells: years.map(y=>fmt(plan.get(y))),
        total: fmt(sumPlan),
        diff:'', rate:''
      });
      // 実績行
      rows.push({
        facility:fac, kind:'実績',
        cells: years.map(y=>fmt(actual.get(y))),
        total: fmt(sumAct),
        diff: fmt(diff),
        rate: rate==null?'—': `${rate>=0?'+':''}${rate}%`
      });
    });

    return (
      <Card>
        <CardContent>
          <Typography variant="h6" sx={{mb:1}}>{title}</Typography>

          {/* KPI */}
          <Box className="kpi" sx={{mb:1}}>
            {kpis.map(k=>(
              <Card key={k.label} variant="outlined" sx={{p:1}}>
                <Typography color="text.secondary" variant="body2">{k.label}</Typography>
                <Typography variant="h6" className="mono">{k.value}</Typography>
                {k.sub && <Typography color="text.secondary" variant="caption">{k.sub}</Typography>}
              </Card>
            ))}
          </Box>

          {/* 年度ピボット表（横軸=年度） */}
          <Box sx={{mb:1}}>
            <Typography variant="subtitle1" sx={{mb:0.5}}>年度サマリ（STOREID × 計画/実績）</Typography>
            <TableContainer component={Paper} variant="outlined" sx={{width:'100%', overflowX:'auto'}}>
              {/* 年度数に応じて広がるよう minWidth を動的に（1年あたり120px目安） */}
              <Table size="small" stickyHeader sx={{width:'100%', minWidth: Math.max(960, 360 + years.length*120)}}>
                <TableHead>
                  <TableRow>
                    <TableCell>STOREID</TableCell>
                    <TableCell>区分</TableCell>
                    {years.map(y=><TableCell key={y} align="right" className="mono">{y}</TableCell>)}
                    <TableCell align="right" className="mono">合計</TableCell>
                    <TableCell align="right" className="mono">差分</TableCell>
                    <TableCell align="right" className="mono">達成率</TableCell>
                  </TableRow>
                </TableHead>
                <TableBody>
                  {rows.length? rows.map((r,idx)=>(
                    <TableRow key={idx} hover>
                      <TableCell className="mono">{r.facility}</TableCell>
                      <TableCell>{r.kind}</TableCell>
                      {r.cells.map((v,i)=><TableCell key={i} align="right" className="mono">{v||'—'}</TableCell>)}
                      <TableCell align="right" className="mono">{r.total}</TableCell>
                      <TableCell align="right" className="mono">{r.diff||'—'}</TableCell>
                      <TableCell align="right" className="mono">{r.rate||'—'}</TableCell>
                    </TableRow>
                  )):(
                    <TableRow>
                      <TableCell colSpan={years.length+5} align="center">
                        <Typography color="text.secondary" sx={{py:1}}>該当データがありません</Typography>
                      </TableCell>
                    </TableRow>
                  )}
                </TableBody>
              </Table>
            </TableContainer>
          </Box>

          {/* 明細テーブル（既存の GenericPanel を流用） */}
          <GenericPanel
            title="売上明細"
            list={filtered}
            columns={columns}
            kpiFactory={()=>[]}        // KPIは上で出したので非表示
            filters={{...safeFilters}} // 安全な形に正規化したものを渡す
          />
        </CardContent>
      </Card>
    );
  }
}

,

  /* --- 履歴 --- */
history:{
  title:"履歴管理",

  // ========== 列 ==========
  columns:[
    {key:'schedule_history_id',label:'履歴ID',mono:true},
    {key:'title',label:'タイトル'},
    {key:'category',label:'カテゴリ'},
    {key:'sub_category',label:'サブカテゴリ'},

    // ← グローバル status は無視し、hist_status を表示
    {key:'hist_status',label:'状態',render:r=>{
      const COLOR = { 完了:'success', 進行中:'primary', 保留:'default', 中止:'default' };
      return <Chip size="small" label={r.hist_status||'—'} color={COLOR[r.hist_status]||'default'}/>;
    }},

    {key:'period',label:'開始/終了',render:r=>{
      const f=(d)=>{ if(!d) return '—'; const dt=new Date(d);
        const y=dt.getFullYear(), m=String(dt.getMonth()+1).padStart(2,'0'), dd=String(dt.getDate()).padStart(2,'0');
        return `${y}-${m}-${dd}`; };
      return <span className="mono">{f(r.start_date)} ~ {f(r.close_date)}</span>;
    }},
    {key:'cost',label:'コスト(千円)',align:'right',mono:true,render:r=>{
      const v=Number(r.cost)||0; return v.toLocaleString(undefined,{maximumFractionDigits:0});
    }},
    {key:'location',label:'場所'},
    {key:'owner_id_key',label:'担当部署Key',align:'right',mono:true},
    {key:'manager_id',label:'管理者ID',mono:true},
    {key:'related',label:'関連(区分/ID)',render:r=>
      <span className="mono">{(r.related_id_category||'—')}/{(r.related_id||'—')}</span>
    },
    {key:'files',label:'ファイル',render:r=>{
      const flags=[r.file_plan&&'計画',r.file_investment_performance&&'投資実績',r.file_material&&'資料',r.photo&&'写真'].filter(Boolean);
      return flags.length?flags.join('・'):'—';
    }},
    {key:'detail_content',label:'詳細',render:r=>{
      const s=r.detail_content||''; const t=s||'—';
      const v=s.length>18?s.slice(0,18)+'…':t;
      return <span title={t}>{v}</span>;
    }},
    {key:'notes',label:'備考',render:r=>{
      const s=r.notes||''; const t=s||'—';
      const v=s.length>18?s.slice(0,18)+'…':t;
      return <span title={t}>{v}</span>;
    }},
    {key:'updated_at',label:'更新日',render:r=>{
      const f=(d)=>{ if(!d) return '—'; const dt=new Date(d);
        const y=dt.getFullYear(), m=String(dt.getMonth()+1).padStart(2,'0'), dd=String(dt.getDate()).padStart(2,'0');
        return `${y}-${m}-${dd}`; };
      return <span className="mono">{f(r.updated_at)}</span>;
    }}
  ],

  // ========== ダミーデータ生成（実データ差替え前提） ==========
  // 重要: グローバルフィルタに掛かる 'status' は固定で '有効' にし、
  // 本来の状態は hist_status に保存して表示・集計で使用します。
  list:(rnd)=>Array.from({length:260}).map((_,i)=>{
    const id = i+1;
    const cats = ['改装','メンテ','販促','法令','IT','防災'];
    const subMap = {
      改装:['内装','外装','什器'],
      メンテ:['空調','電気','給排水'],
      販促:['POP','キャンペーン','什器増設'],
      法令:['点検','届出','是正'],
      IT:['POS','ネットワーク','端末'],
      防災:['訓練','設備点検','是正']
    };
    const category = cats[Math.floor(rnd()*cats.length)];
    const sub_category = subMap[category][Math.floor(rnd()*subMap[category].length)];

    const start = new Date(2019+Math.floor(rnd()*6), Math.floor(rnd()*12), 1+Math.floor(rnd()*27));
    const maybeClosed = rnd() < 0.6;
    const close_date = maybeClosed
      ? new Date(start.getFullYear(), start.getMonth()+Math.floor(rnd()*4), start.getDate()+Math.floor(rnd()*20))
      : null;
    const hist_status = close_date
      ? (rnd()<0.66?'完了':'進行中')
      : (rnd()<0.5?'進行中':(rnd()<0.5?'保留':'中止'));

    const cost = +(50 + rnd()*4950).toFixed(2);
    const locs = ['売場','バックヤード','機械室','屋外','倉庫','厨房'];

    return {
      // スキーマ 1〜26
      id,                                        // 1
      store_id_key: 1 + Math.floor(rnd()*200),   // 2
      schedule_history_id: `SH-${String(100000+id).slice(-6)}`, // 3

      // ★ グローバルには常に通すためのダミー（統合状態フィルタ回避用）
      status: '有効',                            // 4  ← ここは固定値

      // 本来の状態は別名で保持（表示・KPIはこちらを使用）
      hist_status,                               //  ← 追加フィールド（スキーマ外の表示用）

      category,                                  // 5
      sub_category,                              // 6
      title: `${category}/${sub_category} ${id}`,// 7
      start_date: start,                         // 8
      close_date,                                // 9
      owner_id_key: 100 + Math.floor(rnd()*900), // 10
      manager_id: `MG-${String(1000+Math.floor(rnd()*9000))}`, // 11
      detail_content: rnd()<0.5 ? '関係各所と調整済、次回会議で承認見込み' : '', // 12
      cost,                                      // 13
      location: locs[Math.floor(rnd()*locs.length)], // 14
      related_id_category: rnd()<0.5 ? ['契約','設備','テナント','工事'][Math.floor(rnd()*4)] : '', // 15
      related_id: rnd()<0.5 ? `RL-${String(10000+Math.floor(rnd()*90000))}` : '', // 16
      file_plan: rnd()<0.35 ? 'plan_v1.pdf' : '',                      // 17
      file_investment_performance: rnd()<0.25 ? 'investment_2024.xlsx' : '', // 18
      file_material: rnd()<0.45 ? 'material.zip' : '',                 // 19
      photo: rnd()<0.4 ? 'photo_001.jpg' : '',                         // 20
      notes: rnd()<0.3 ? '夜間作業あり／ビル管理連絡必須' : '',         // 21
      created_at: new Date(start.getTime()-86400000*3),                 // 22
      created_by: 'system',                                             // 23
      updated_at: new Date(),                                           // 24
      updated_by: 'system',                                             // 25
      is_deleted: rnd()<0.02 ? 1 : 0,                                   // 26

      // 統合フィルタ（App 側で STOREID を割当）
      facility: null
    };
  }),

  // ========== KPI（hist_status を使用） ==========
  kpi:(rows)=>{
    const valid = rows.filter(x=>!x.is_deleted);
    const total = valid.length;
    const done = valid.filter(x=>x.hist_status==='完了').length;
    const running = valid.filter(x=>x.hist_status==='進行中').length;
    const sumCost = valid.reduce((s,x)=>s+(Number(x.cost)||0),0);

    const now = new Date(), year = now.getFullYear();
    const startedThisYear = valid.filter(x=>x.start_date && new Date(x.start_date).getFullYear()===year).length;
    const closedThisYear  = valid.filter(x=>x.close_date && new Date(x.close_date).getFullYear()===year).length;

    return [
      {label:'履歴件数', value: total},
      {label:'完了率', value: total? Math.round(done/total*100)+'%' : '—', sub:`完了 ${done} 件`},
      {label:'進行中', value: running},
      {label:'総コスト(千円)', value: sumCost.toLocaleString(undefined,{maximumFractionDigits:0})},
      {label:`${year} 開始/完了`, value: `${startedThisYear}/${closedThisYear}`}
    ];
  }
}
,

  /* --- 近隣 --- */
neighbor:{
  title:"近隣情報管理",
  // テーブル列（GenericPanel 側で nowrap + ellipsis + 横スクロール）
  columns:[
    {key:'neighbor_id',label:'近隣ID',mono:true},
    {key:'neighbor_name',label:'名称'},
    {key:'category',label:'区分'},
    {key:'status',label:'状態',render:r=>{
      // tinyint(1) unsigned → 表示用（有効/無効）に正規化
      const label = r.status ? '有効' : '無効';
      const color = r.status ? 'success' : 'default';
      return <Chip size="small" label={label} color={color}/>;
    }},
    {key:'distance',label:'距離(m)',align:'right',mono:true,render:r=>{
      const v = Number(r.distance)||0;
      return v.toLocaleString(undefined,{minimumFractionDigits:2,maximumFractionDigits:2});
    }},
    {key:'amount',label:'金額(千円)',align:'right',mono:true,render:r=>{
      const v = Number(r.amount)||0;
      return v.toLocaleString(undefined,{minimumFractionDigits:0,maximumFractionDigits:0});
    }},
    {key:'address',label:'住所'},
    {key:'notes',label:'備考',render:r=>{
      const s=r.notes||''; return s.length>20 ? s.slice(0,20)+'…' : (s||'—');
    }},
    {key:'updated_at',label:'更新日',render:r=>{
      return r.updated_at ? <span className="mono">{new Date(r.updated_at).toISOString().slice(0,10)}</span> : '—';
    }}
  ],

  // ダミーデータ生成（実データ置換前提）
  list:(rnd)=>Array.from({length:180}).map((_,i)=>{
    const id = i+1;
    const statusFlag = rnd() > 0.1 ? 1 : 0; // 約90%が有効
    const dist = +(100 + rnd()*3000).toFixed(2); // 100〜3100m
    const amt  = +(50 + rnd()*950).toFixed(2);   // 50〜1000 (千円想定)
    const categories = ['商業施設','公共施設','駐車場','学校','病院','競合店','交通機関'];
    const cities = ['千代田区','中央区','港区','新宿区','渋谷区','台東区','江東区','品川区'];
    const chome = `${Math.ceil(rnd()*3)}丁目${Math.ceil(rnd()*20)}-${Math.ceil(rnd()*30)}`;

    return {
      // スキーマ準拠
      id,                                 // 1
      store_id_key: 1 + Math.floor(rnd()*200), // 2
      status: statusFlag,                 // 3 tinyint(1) unsigned
      category: pick(rnd, categories),    // 4
      neighbor_name: `近隣施設${id}`,     // 5
      distance: dist,                     // 6 decimal(12,2)
      address: `東京都${pick(rnd,cities)}${chome}`, // 7
      amount: amt,                        // 8 decimal(12,2)
      notes: rnd()<0.25 ? '営業時間注意／騒音あり' : '', // 9
      created_at: new Date(),             // 10
      created_by: 'system',               // 11
      updated_at: new Date(),             // 12
      updated_by: 'system',               // 13
      is_deleted: rnd()<0.02 ? 1 : 0,     // 14
      neighbor_id: `NB-${String(10000+id).padStart(5,'0')}`, // 15

      // 統合フィルタ連携（App 側で STOREID を割当：facility は後段で上書き）
      facility: null
    };
  }),

  // KPI：件数／有効率／平均距離／合計金額／近距離(～500m)
  kpi:(rows)=>{
    const valid = rows.filter(x=>!x.is_deleted);
    const total = valid.length;
    const active = valid.filter(x=>x.status).length;
    const avgDist = total ? valid.reduce((s,x)=>s+(Number(x.distance)||0),0)/total : 0;
    const sumAmt  = valid.reduce((s,x)=>s+(Number(x.amount)||0),0);
    const near500 = valid.filter(x=>(Number(x.distance)||0) <= 500).length;
    return [
      {label:'近隣件数', value: total},
      {label:'有効率', value: total? Math.round(active/total*100)+'%' : '—', sub:`有効 ${active} 件`},
      {label:'平均距離(m)', value: avgDist.toLocaleString(undefined,{maximumFractionDigits:0})},
      {label:'金額合計(千円)', value: sumAmt.toLocaleString(undefined,{maximumFractionDigits:0})},
      {label:'～500m', value: near500}
    ];
  }
},

  /* --- 法令 --- */
law:{
  title:"法令管理",
  // ※ GenericPanel 側でセルは nowrap + ellipsis（横スクロール）になります
  columns:[
    {key:'legal_id',label:'法令ID',mono:true},
    {key:'store_id_key',label:'店舗キー',align:'right',mono:true},
    {key:'status',label:'適合',render:r=>{
      const ok = r.status==='遵守';
      return <Chip size="small" label={r.status} color={ok?'success':'default'}/>;
    }},
    {key:'category',label:'区分'},
    {key:'location_law',label:'所在地(法令)'},
    {key:'city_law',label:'市区町村'},
    {key:'submission_date',label:'届出日',render:r=>{
      return r.submission_date
        ? <span className="mono">{new Date(r.submission_date).toISOString().slice(0,10)}</span>
        : '—';
    }},
    {key:'business_hours',label:'営業時間',render:r=><span className="mono">{r.business_hours_start||'—'}~{r.business_hours_end||'—'}</span>},
    {key:'parking',label:'駐車(必/届)',mono:true,render:r=><span className="mono">{r.required_parking_spots}/{r.reported_parking_spots}</span>},
    {key:'bicycle',label:'自転車(必/届)',mono:true,render:r=><span className="mono">{r.required_bicycle_spots}/{r.reported_bicycle_spots}</span>},
    {key:'delivery_time',label:'搬入時間',render:r=><span className="mono">{r.delivery_time_start||'—'}~{r.delivery_time_end||'—'}</span>},
    {key:'old_heart_building_compliance',label:'旧ハートビル',render:r=>r.old_heart_building_compliance? '適合':'—'},
    {key:'new_barrier_free_compliance',label:'新バリアフリー',render:r=>r.new_barrier_free_compliance? '適合':'—'},
    {key:'waste_location',label:'廃棄物 置場'},
    {key:'waste_capacity',label:'廃棄物 容量'},
    {key:'building_owner_type',label:'建物所有者 区分'},
    {key:'building_owner_representative',label:'建物所有者 代表'},
    {key:'store_operator_type',label:'運営 区分'},
    {key:'store_operator_representative',label:'運営 代表'},
    {key:'notes',label:'備考',render:r=>{
      const s=r.notes||''; return s.length>20? s.slice(0,20)+'…':(s||'—');
    }},
    {key:'updated_at',label:'更新日',render:r=>{
      return r.updated_at
        ? <span className="mono">{new Date(r.updated_at).toISOString().slice(0,10)}</span>
        : '—';
    }}
  ],

  // ダミーデータ生成（実データ差替え前提）
  list:(rnd)=>Array.from({length:120}).map((_,i)=>{
    const compliant = rnd()>.28; // おおよそ 72% が遵守
    const required_parking = Math.floor(5 + rnd()*25);
    const reported_parking = Math.max(0, required_parking + Math.floor(-3 + rnd()*7));
    const required_bicycle = Math.floor(10 + rnd()*40);
    const reported_bicycle = Math.max(0, required_bicycle + Math.floor(-5 + rnd()*11));
    const startH = String(7 + Math.floor(rnd()*5)).padStart(2,'0')+':00:00';  // 07:00〜11:00
    const endH   = String(20 + Math.floor(rnd()*4)).padStart(2,'0')+':00:00'; // 20:00〜23:00
    const delS   = String(6 + Math.floor(rnd()*3)).padStart(2,'0')+':00:00';  // 06:00〜08:00
    const delE   = String(9 + Math.floor(rnd()*3)).padStart(2,'0')+':00:00';  // 09:00〜11:00

    return {
      // スキーマ準拠 1〜31
      id: i+1,                                                       // 1
      legal_id: `LG-${String(10000+i).padStart(5,'0')}`,             // 2
      store_id_key: 1 + Math.floor(rnd()*200),                       // 3
      status: compliant ? '遵守' : '未対応',                           // 4 tinyint(1) → 表示用へ正規化
      category: pick(rnd,['防火','用途変更','騒音','景観','衛生']),     // 5
      location_law: `所在地${1+Math.floor(rnd()*50)}`,               // 6
      city_law: pick(rnd,['千代田区','中央区','港区','新宿区','渋谷区','台東区','江東区']), // 7
      submission_date: new Date(2018+Math.floor(rnd()*7), Math.floor(rnd()*12), 1+Math.floor(rnd()*27)), // 8
      business_hours_start: startH,                                   // 9
      required_parking_spots: required_parking,                       // 10
      reported_parking_spots: reported_parking,                       // 11
      required_bicycle_spots: required_bicycle,                       // 12
      reported_bicycle_spots: reported_bicycle,                       // 13
      delivery_time_start: delS,                                      // 14
      old_heart_building_compliance: rnd()<0.6 ? 1 : 0,               // 15
      new_barrier_free_compliance: rnd()<0.7 ? 1 : 0,                 // 16
      waste_location: pick(rnd,['B1ごみ庫','1Fごみ庫','屋外ストッカー']), // 17
      waste_capacity: pick(rnd,['1.5m³','3.0m³','5.0m³']),            // 18
      waste_pdf: rnd()<0.3 ? 'PDF: waste_guide.pdf' : '',             // 19
      building_owner_type: pick(rnd,['法人','個人','区有']),           // 20
      building_owner_representative: rnd()<0.7 ? `代表${Math.ceil(rnd()*300)}`:'', // 21
      store_operator_type: pick(rnd,['直営','FC','委託']),             // 22
      store_operator_representative: `管${Math.ceil(rnd()*500)}`,     // 23
      notes: rnd()<0.35 ? '是正指導中（騒音）／次回点検要' : '',        // 24
      created_at: new Date(),                                         // 25
      created_by: 'system',                                           // 26
      updated_at: new Date(),                                         // 27
      updated_by: 'system',                                           // 28
      is_deleted: rnd()<0.02 ? 1 : 0,                                 // 29
      business_hours_end: endH,                                       // 30
      delivery_time_end: delE,                                        // 31

      // 統合フィルタ連携（App 側で STOREID を割当：facility は後段で上書き）
      facility: null
    };
  }),

  // KPI：件数／遵守率／不足件数（駐車・自転車）
  kpi:(r)=>{
    const valid = r.filter(x=>!x.is_deleted);
    const ok = valid.filter(x=>x.status==='遵守').length;
    const total = valid.length;
    const parkingShort = valid.filter(x=>(x.reported_parking_spots??0) < (x.required_parking_spots??0)).length;
    const bicycleShort = valid.filter(x=>(x.reported_bicycle_spots??0) < (x.required_bicycle_spots??0)).length;
    return [
      {label:'法令件数', value: total},
      {label:'遵守率', value: total? Math.round(ok/total*100)+'%' : '—', sub:`遵守 ${ok} 件`},
      {label:'駐車 不足件数', value: parkingShort},
      {label:'自転車 不足件数', value: bicycleShort},
      {label:'PDF あり', value: valid.filter(x=>x.waste_pdf).length}
    ];
  }
},

  /* --- 土地 --- */
land:{
  title:"土地情報管理",
  // テーブル列（GenericPanel 側で nowrap + ellipsis + 横スクロール）
  columns:[
    {key:'land_id',label:'土地ID',mono:true},
    {key:'name',label:'名称'},
    {key:'land_division',label:'地目/区分'},
    {key:'use_area',label:'用途地域'},
    {key:'site_area',label:'敷地面積(㎡)',align:'right',mono:true,render:r=>{
      const v=Number(r.site_area)||0;
      return v.toLocaleString(undefined,{minimumFractionDigits:2,maximumFractionDigits:2});
    }},
    {key:'route_price',label:'路線価(千円/㎡)',align:'right',mono:true,render:r=>{
      const v=Number(r.route_price)||0;
      return v.toLocaleString(undefined,{minimumFractionDigits:0,maximumFractionDigits:0});
    }},
    {key:'address',label:'所在地'},
    {key:'status',label:'状態',render:r=>{
      // tinyint(1) → 表示用に正規化（有効/無効）
      const label = r.status ? '有効' : '無効';
      const color = r.status ? 'success' : 'default';
      return <Chip size="small" label={label} color={color}/>;
    }},
    {key:'contract_id_key',label:'契約キー',align:'right',mono:true},
    {key:'notes',label:'備考',render:r=>{
      const s=r.notes||''; return s.length>20?s.slice(0,20)+'…':(s||'—');
    }},
    {key:'updated_at',label:'更新日',render:r=>{
      return r.updated_at ? <span className="mono">{new Date(r.updated_at).toISOString().slice(0,10)}</span> : '—';
    }}
  ],

  // ダミーデータ生成（実データ差し替え前提）
  list:(rnd)=>Array.from({length:120}).map((_,i)=>{
    const id = i+1;
    const statusFlag = rnd() > 0.08 ? 1 : 0; // 約92%を有効に
    const site = +(200 + rnd()*9800).toFixed(2);          // 200〜10,000㎡
    const route = +(50 + rnd()*450).toFixed(0);           // 50〜500 千円/㎡
    const landDivs = ['宅地','雑種地','田','畑','山林','原野'];
    const useAreas = ['商業地域','近隣商業','準工業','第一種住居','第二種住居','準住居'];
    const cities = ['千代田区','中央区','港区','新宿区','渋谷区','台東区','江東区','品川区'];
    const chome = `${Math.ceil(rnd()*3)}丁目${Math.ceil(rnd()*20)}-${Math.ceil(rnd()*30)}`;

    return {
      // スキーマ準拠 1〜17
      id,                                   // 1
      store_id_key: 1 + Math.floor(rnd()*200),     // 2
      land_id: `LD-${String(10000+id).padStart(5,'0')}`, // 3
      status: statusFlag,                   // 4 tinyint(1)
      name: `土地${id}`,                    // 5
      land_division: pick(rnd,landDivs),    // 6
      use_area: pick(rnd,useAreas),         // 7
      site_area: site,                      // 8 decimal(12,2)
      route_price: route,                   // 9 decimal(12,2)（千円/㎡想定）
      contract_id_key: Math.floor(1000 + rnd()*9000), // 10
      notes: rnd()<0.25 ? '建蔽/容積に留意・高架近接' : '', // 11
      created_at: new Date(),               // 12
      created_by: 'system',                 // 13
      updated_at: new Date(),               // 14
      updated_by: 'system',                 // 15
      is_deleted: rnd()<0.02 ? 1 : 0,       // 16
      address: `東京都${pick(rnd,cities)}${chome}`, // 17

      // 統合フィルタ（App 側で STOREID を割当：facility は後段で上書き）
      facility: null
    };
  }),

  // KPI：件数／有効率／総面積／平均路線価／高路線価（>=300）
  kpi:(rows)=>{
    const valid = rows.filter(x=>!x.is_deleted);
    const total = valid.length;
    const active = valid.filter(x=>x.status).length;
    const sumArea = valid.reduce((s,x)=>s+(Number(x.site_area)||0),0);
    const avgRoute = total ? valid.reduce((s,x)=>s+(Number(x.route_price)||0),0)/total : 0;
    const highRoute = valid.filter(x=>(Number(x.route_price)||0) >= 300).length;
    return [
      {label:'土地数', value: total},
      {label:'有効率', value: total?Math.round(active/total*100)+'%':'—', sub:`有効 ${active} 件`},
      {label:'総面積(㎡)', value: sumArea.toLocaleString(undefined,{maximumFractionDigits:0})},
      {label:'平均路線価(千円/㎡)', value: avgRoute.toLocaleString(undefined,{maximumFractionDigits:0})},
      {label:'高路線価 (≧300)', value: highRoute}
    ];
  }
}
};

/* ========= アプリ本体 ========= */
const theme=createTheme({palette:{primary:{main:'#1976d2'}}});
const ALL_STATUS = ['稼働','有効','点検中','未対応','期限切れ','停止','閉店','完了','未完','遵守','無効','退去'];

function App(){
  const [facSel,setFacSel]=React.useState([]);
  const [sts,setSts]=React.useState(['稼働','有効','未対応']);
  const [qInput,setQInput]=React.useState('');
  const q = useDebounced(qInput, 300);

  // 1) 先に店舗生成 → 施設候補（=店舗）を作成
  // 2) 他パネルの facility を store_id に統一
  const dataMemo = React.useMemo(()=>{
    const rndStore = makeRng('seed:store');
    const storeList = panels.store.list(rndStore);
    const storeIds = storeList.map(s=>s.store_id);
    const facilities = storeList.map(s=>({id:s.store_id, name:s.store_name}));

    const entries = Object.entries(panels).map(([id,p])=>{
      if(id==='store') return [id, storeList];
      const rnd = makeRng('seed:'+id);
      const list = p.list(rnd).map(row=>{
        const chosen = storeIds[Math.floor(rnd()*storeIds.length)];
        return {...row, facility: row.facility || chosen};
      });
      return [id, list];
    });
    return { all:Object.fromEntries(entries.concat([['store',storeList]])), facilities };
  },[]);

  const filters={facilities:facSel,q, statuses:sts};

  // 各パネルへのスクロール用 ref
  const panelRefs = React.useRef({});
  const panelOrder = Object.keys(panels);
  panelOrder.forEach(id=>{ if(!panelRefs.current[id]) panelRefs.current[id]=React.createRef(); });

  const onJump = (id)=>{
    const el = panelRefs.current[id]?.current;
    if(el){ el.scrollIntoView({behavior:'smooth', block:'start'}); }
  };
  const navItems = panelOrder.map(id=>({id, title: panels[id].title}));

  return(
    <ThemeProvider theme={theme}>
      <Box sx={{pb:2}}>
        {/* 半透明スティッキーヘッダー */}
        <StickyHeader
          facilities={dataMemo.facilities}
          facSel={facSel}
          setFacSel={setFacSel}
          sts={sts}
          setSts={setSts}
          qInput={qInput}
          setQInput={setQInput}
          navItems={navItems}
          onJump={onJump}
        />

        {/* 本体 */}
        <Box className="grid" sx={{ px:{xs:1, md:2}, pt:1 }}>
{/* 👇 修正版のパネル描画ループ */}
{panelOrder.map((id) => {
  const panel = panels[id];
  if (!panel) return null; // ← panels定義にないidはスキップ

  const PanelComponent = typeof panel.Custom === 'function' ? panel.Custom : GenericPanel;
  const list = dataMemo.all[id] || []; // 安全対策：データがない場合でも空配列
  const columns = panel.columns || [];

  return (
    <Box key={id} id={`panel-${id}`} ref={panelRefs.current[id]}>
      <PanelComponent
        title={panel.title}
        list={list}
        columns={columns}
        kpiFactory={panel.kpi}
        filters={filters}
        renderCard={panel.renderCard}
        cardWhen={panel.cardWhen}
      />
    </Box>
  );
})}
        </Box>
      </Box>
    </ThemeProvider>
  );
}

ReactDOM.createRoot(document.getElementById('app')).render(<App/>);
  </script>
</body>
</html>
