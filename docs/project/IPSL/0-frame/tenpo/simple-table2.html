<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>設備管理システム</title>
  <!-- React and ReactDOM -->
  <script src="https://cdn.jsdelivr.net/npm/react@18/umd/react.production.min.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/react-dom@18/umd/react-dom.production.min.js" crossorigin="anonymous"></script>
  <!-- MUI (Material-UI) v5 -->
  <script src="https://cdn.jsdelivr.net/npm/@mui/material@5.11.15/umd/material-ui.production.min.js" crossorigin="anonymous"></script>
  <!-- Babel for JSX -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.21.0/babel.min.js" crossorigin="anonymous"></script>
  <!-- Emotion ライブラリ -->
  <script src="https://cdn.jsdelivr.net/npm/@emotion/react@11.11.0/dist/emotion-react.umd.min.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@emotion/styled@11.11.0/dist/emotion-styled.umd.min.js" crossorigin="anonymous"></script>
  <!-- Papaparse for CSV parsing -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js" crossorigin="anonymous"></script>
  <!-- SheetJS for Excel handling -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js" crossorigin="anonymous"></script>
  <!-- Material-UIのスタイルシート -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons" />
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: 'Roboto', sans-serif;
    }
    #root {
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }
    .content {
      flex: 1;
      padding: 10px; /* パディングを減らしてコンパクトに */
      background-color: #f5f5f5;
    }
    .footer {
      padding: 10px;
      text-align: center;
      background-color: #1976d2;
      color: white;
    }
    .editable-cell {
      position: relative;
      padding: 4px 8px; /* パディングを減らしてコンパクトに */
    }
    .editable-input {
      width: 100%;
      padding: 4px 8px; /* パディングを減らしてコンパクトに */
      font-size: 0.875rem; /* フォントサイズを小さく */
    }
    .changed-cell {
      background-color: #ffcccb; /* 赤色 */
    }
    .MuiTableCell-root {
      padding: 4px 8px !important;
      font-size: 0.875rem;
    }
    .confirmation-buttons {
      margin-bottom: 20px;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const {
      AppBar, Toolbar, Typography, Table, TableBody, TableCell, TableContainer,
      TableHead, TableRow, Paper, TextField, Select, MenuItem: MenuItemMUI,
      InputLabel, FormControl, Button, IconButton, Dialog, DialogActions, DialogContent,
      DialogTitle, Switch, FormControlLabel, Snackbar, Alert,
      Box, Grid, Checkbox, TablePagination, Menu, Tooltip
    } = MaterialUI;

    const { useState, useEffect, useRef } = React;

    // 初期メーターの定義
    const initialMeters = [
      {
        id: 1,
        meterId: "MTR-001",
        meterName: "電気メーター1",
        locationName: "東京営業所",
        installationPlace: "第1営業所",
        manager: "山田 太郎",
        previousValue: 1000,
        previousConfirmationDate: "2023-11-15",
        previousRegistrant: "山田 太郎",
        currentValue: 1100,
        confirmationDate: "2024-12-01",
        registrant: "佐藤 花子",
        usage: 100,
      },
      {
        id: 2,
        meterId: "MTR-002",
        meterName: "電気メーター2",
        locationName: "大阪営業所",
        installationPlace: "第2営業所",
        manager: "佐藤 花子",
        previousValue: 2000,
        previousConfirmationDate: "2023-11-10",
        previousRegistrant: "佐藤 花子",
        currentValue: 2100,
        confirmationDate: "2024-12-02",
        registrant: "山田 太郎",
        usage: 100,
      },
      // 必要に応じて他のメーターも追加可能
    ];

    // 初期設備データ（メーターに関連する設備情報を想定）
    const initialEquipments = [
      {
        no: 1,
        equipmentId: "MTR-001",
        equipmentName: "電気機器A",
        equipmentCategory: "計測機器",
        modelNumber: "EM-100A",
        purchaseDate: "2023-01-15",
        location: "東京営業所",
        installationPlace: "第1営業所",
        manager: "山田 太郎",
        status: "良好",
        nextMaintenanceDate: "2024-01-15",
        lastMaintenanceDate: "2023-01-15",
        maintenanceInterval: "12",
        usefulLife: "60",
        scheduledUpdateDate: "2028-01-15",
        notes: "定期メンテナンス済",
        active: true,
      },
      {
        no: 2,
        equipmentId: "MTR-002",
        equipmentName: "電気機器B",
        equipmentCategory: "計測機器",
        modelNumber: "EM-200B",
        purchaseDate: "2023-02-20",
        location: "大阪営業所",
        installationPlace: "第2営業所",
        manager: "佐藤 花子",
        status: "良好",
        nextMaintenanceDate: "2024-02-20",
        lastMaintenanceDate: "2023-02-20",
        maintenanceInterval: "12",
        usefulLife: "60",
        scheduledUpdateDate: "2028-02-20",
        notes: "定期メンテナンス済",
        active: true,
      },
      // 必要に応じて他の設備データも追加可能
    ];

    function App() {
      // メーター管理用のステート
      const [meters, setMeters] = useState(Array.isArray(initialMeters) ? initialMeters : []);
      const [meterDialogOpen, setMeterDialogOpen] = useState(false);
      const [newMeter, setNewMeter] = useState({
        meterId: "",
        meterName: "",
        locationName: "",
        installationPlace: "",
        manager: "",
        previousValue: "",
        previousConfirmationDate: "",
        previousRegistrant: "",
        currentValue: "",
        confirmationDate: "",
        registrant: "",
        usage: 0,
      });
      const [editMeter, setEditMeter] = useState(null);
      const [meterSnackbar, setMeterSnackbar] = useState({ open: false, message: "", severity: "success" });

      // 設備管理用のステート（関連設備情報）
      const [equipments, setEquipments] = useState(initialEquipments);

      // フィルターエリアのステート
      const [filterYear, setFilterYear] = useState("");
      const [filterMonth, setFilterMonth] = useState("");
      const [filterLocation, setFilterLocation] = useState("");
      const [filterCategory, setFilterCategory] = useState("");
      const [filterStatus, setFilterStatus] = useState(""); // 状態フィルターを追加
      const [searchTerm, setSearchTerm] = useState("");

      // 編集状態のステート（確定前の変更を管理）
      const [editStates, setEditStates] = useState({}); // { meterId: { field: newValue } }

      // 確定後の状態を保持するためのステート
      const [previousMeters, setPreviousMeters] = useState(null);

      // スナックバーのステート
      const [snackbar, setSnackbar] = useState({ open: false, message: "", severity: "success" });

      // ページネーションのステート
      const [page, setPage] = useState(0);
      const [rowsPerPage, setRowsPerPage] = useState(10);
      const [rowsPerPageOption, setRowsPerPageOption] = useState('10'); // '10', '20', '30', '全て', '数値入力'
      const [customRowsPerPage, setCustomRowsPerPage] = useState('');

      // 操作メニューのステート
      const [anchorEl, setAnchorEl] = useState(null);
      const [menuRow, setMenuRow] = useState(null);
      const [openSubMenuDialog, setOpenSubMenuDialog] = useState(false);
      const [subMenuAction, setSubMenuAction] = useState("");
      const [currentRow, setCurrentRow] = useState(null);

      // 選択されたメーターのステート（複数選択）
      const [selectedMeterIds, setSelectedMeterIds] = useState([]);

      // フィルター関連（拠点名と設備カテゴリー）
      const uniqueLocations = Array.isArray(meters) ? [...new Set(meters.map(m => m.locationName))] : [];
      const uniqueCategories = Array.isArray(equipments) ? [...new Set(equipments.map(eq => eq.equipmentCategory))] : [];
      
      // ユニークな年度と月度を「前回確認日」と「確認日」の両方から抽出
      const uniqueYears = Array.isArray(meters) ? 
        [...new Set([
          ...meters.map(m => {
            const date = new Date(m.previousConfirmationDate);
            return isNaN(date.getFullYear()) ? "" : date.getFullYear();
          }),
          ...meters.map(m => {
            const date = new Date(m.confirmationDate);
            return isNaN(date.getFullYear()) ? "" : date.getFullYear();
          })
        ])].filter(year => year !== "").sort((a, b) => b - a) 
        : [];

      const uniqueMonths = Array.isArray(meters) ? 
        [...new Set([
          ...meters.map(m => {
            const date = new Date(m.previousConfirmationDate);
            return isNaN(date.getMonth()) ? "" : date.getMonth() + 1;
          }),
          ...meters.map(m => {
            const date = new Date(m.confirmationDate);
            return isNaN(date.getMonth()) ? "" : date.getMonth() + 1;
          })
        ])].filter(month => month !== "").sort((a, b) => a - b) 
        : [];

      // フィルター処理
      const filteredMeters = Array.isArray(meters) ? meters.filter(meter => {
        const prevDate = new Date(meter.previousConfirmationDate);
        const confDate = new Date(meter.confirmationDate);
        const prevYear = isNaN(prevDate.getFullYear()) ? "" : prevDate.getFullYear();
        const prevMonth = isNaN(prevDate.getMonth()) ? "" : prevDate.getMonth() + 1;
        const confYear = isNaN(confDate.getFullYear()) ? "" : confDate.getFullYear();
        const confMonth = isNaN(confDate.getMonth()) ? "" : confDate.getMonth() + 1;

        const yearMatch = filterYear === "" || prevYear === parseInt(filterYear) || confYear === parseInt(filterYear);
        const monthMatch = filterMonth === "" || prevMonth === parseInt(filterMonth) || confMonth === parseInt(filterMonth);
        const locationMatch = filterLocation === "" || meter.locationName === filterLocation;
        const categoryMatch = filterCategory === "" || equipments.find(eq => eq.equipmentId === meter.meterId)?.equipmentCategory === filterCategory;
        const statusMatch = filterStatus === "" || equipments.find(eq => eq.equipmentId === meter.meterId)?.status === filterStatus; // 状態フィルターのマッチ
        const searchMatch = meter.meterId.includes(searchTerm) ||
                            meter.meterName.includes(searchTerm) ||
                            meter.locationName.includes(searchTerm) ||
                            meter.installationPlace.includes(searchTerm) ||
                            meter.manager.includes(searchTerm);

        return yearMatch && monthMatch && locationMatch && categoryMatch && statusMatch && searchMatch;
      }) : [];

      // ページネーションハンドラー
      const handleChangePage = (event, newPage) => {
        setPage(newPage);
      };

      const handleRowsPerPageOptionChange = (event) => {
        const value = event.target.value;
        setRowsPerPageOption(value);
        setPage(0);

        if (value === '全て') {
          setRowsPerPage(filteredMeters.length);
          setCustomRowsPerPage('');
        } else if (value === '数値入力') {
          setRowsPerPage(customRowsPerPage ? parseInt(customRowsPerPage, 10) : 10);
        } else {
          setRowsPerPage(parseInt(value, 10));
          setCustomRowsPerPage('');
        }
      };

      const handleCustomRowsPerPageChange = (event) => {
        const value = event.target.value;
        setCustomRowsPerPage(value);
        const parsedValue = parseInt(value, 10);
        if (!isNaN(parsedValue) && parsedValue > 0) {
          setRowsPerPage(parsedValue);
        } else {
          setRowsPerPage(10); // デフォルト値
        }
        setPage(0);
      };

      // 操作メニューのハンドラー
      const handleMenuClick = (event, row) => {
        setAnchorEl(event.currentTarget);
        setMenuRow(row);
      };

      const handleMenuClose = () => {
        setAnchorEl(null);
        setMenuRow(null);
      };

      const handleMenuAction = (action) => {
        if (action === "詳細" || action === "記録" || action === "履歴") {
          setSubMenuAction(action);
          setCurrentRow(menuRow);
          setOpenSubMenuDialog(true);
        } else if (action === "削除") {
          handleDeleteMeter(menuRow.id);
        }
        handleMenuClose();
      };

      // サブメニュー用モーダルの閉鎖
      const handleCloseSubMenuDialog = () => {
        setOpenSubMenuDialog(false);
        setSubMenuAction("");
        setCurrentRow(null);
      };

      // メーター追加ダイアログのハンドラー
      const handleOpenMeterDialog = () => {
        setNewMeter({
          meterId: "",
          meterName: "",
          locationName: "",
          installationPlace: "",
          manager: "",
          previousValue: "",
          previousConfirmationDate: "",
          previousRegistrant: "",
          currentValue: "",
          confirmationDate: "",
          registrant: "",
          usage: 0,
        });
        setEditMeter(null);
        setMeterDialogOpen(true);
      };

      const handleCloseMeterDialog = () => {
        setMeterDialogOpen(false);
      };

      // メーターの追加・編集ハンドラー
      const handleAddOrEditMeter = () => {
        if (!newMeter.meterId || !newMeter.meterName) {
          setMeterSnackbar({ open: true, message: "メーターIDとメーター名は必須です。", severity: "error" });
          return;
        }

        if (editMeter) {
          // 編集の場合
          setMeters(meters.map(m => m.id === editMeter.id ? { 
            ...m, 
            meterId: newMeter.meterId, 
            meterName: newMeter.meterName, 
            locationName: newMeter.locationName, 
            installationPlace: newMeter.installationPlace, 
            manager: newMeter.manager,
            previousValue: parseFloat(newMeter.previousValue) || 0, 
            previousConfirmationDate: newMeter.previousConfirmationDate || "",
            previousRegistrant: newMeter.previousRegistrant || "",
            currentValue: parseFloat(newMeter.currentValue) || 0, 
            confirmationDate: newMeter.confirmationDate || "",
            registrant: newMeter.registrant || "",
            usage: (parseFloat(newMeter.currentValue) || 0) - (parseFloat(newMeter.previousValue) || 0)
          } : m));
          setMeterSnackbar({ open: true, message: "メーター情報を更新しました。", severity: "success" });
        } else {
          // 新規追加の場合
          const newId = meters.length > 0 ? Math.max(...meters.map(m => m.id)) + 1 : 1;
          setMeters([...meters, { 
            id: newId, 
            meterId: newMeter.meterId, 
            meterName: newMeter.meterName, 
            locationName: newMeter.locationName, 
            installationPlace: newMeter.installationPlace, 
            manager: newMeter.manager,
            previousValue: parseFloat(newMeter.previousValue) || 0, 
            previousConfirmationDate: newMeter.previousConfirmationDate || "",
            previousRegistrant: newMeter.previousRegistrant || "",
            currentValue: parseFloat(newMeter.currentValue) || 0, 
            confirmationDate: newMeter.confirmationDate || "",
            registrant: newMeter.registrant || "",
            usage: (parseFloat(newMeter.currentValue) || 0) - (parseFloat(newMeter.previousValue) || 0)
          }]);
          setMeterSnackbar({ open: true, message: "新しいメーターを追加しました。", severity: "success" });
        }
        setMeterDialogOpen(false);
      };

      // メーター削除ハンドラー
      const handleDeleteMeter = (id) => {
        if (window.confirm("本当にこのメーターを削除しますか？")) {
          const meterToDelete = meters.find(m => m.id === id);
          setMeters(meters.filter(m => m.id !== id));
          setEquipments(equipments.filter(eq => eq.equipmentId !== meterToDelete?.meterId));
          setMeterSnackbar({ open: true, message: "メーターを削除しました。", severity: "info" });
          setSelectedMeterIds(selectedMeterIds.filter(mid => mid !== id));
        }
      };

      // メーター編集ハンドラー
      const handleEditMeter = (meter) => {
        setNewMeter({
          meterId: meter.meterId,
          meterName: meter.meterName,
          locationName: meter.locationName,
          installationPlace: meter.installationPlace,
          manager: meter.manager,
          previousValue: meter.previousValue,
          previousConfirmationDate: meter.previousConfirmationDate,
          previousRegistrant: meter.previousRegistrant,
          currentValue: meter.currentValue,
          confirmationDate: meter.confirmationDate,
          registrant: meter.registrant,
          usage: meter.usage,
        });
        setEditMeter(meter);
        setMeterDialogOpen(true);
      };

      // メーター入力変更ハンドラー
      const handleMeterChange = (e) => {
        const { name, value } = e.target;
        let updatedMeter = { ...newMeter, [name]: value };

        // 利用量の計算
        const prevVal = name === "previousValue" ? parseFloat(value) : parseFloat(updatedMeter.previousValue) || 0;
        const currVal = name === "currentValue" ? parseFloat(value) : parseFloat(updatedMeter.currentValue) || 0;
        updatedMeter.usage = currVal - prevVal;

        setNewMeter(updatedMeter);
      };

      // セル変更ハンドラー（確定前の変更をeditStatesに保存）
      const handleCellValueChange = (meterId, field, newValue) => {
        const updatedFieldValue = field.includes('Value') ? parseFloat(newValue) || 0 : newValue;

        setEditStates(prev => {
          const updatedMeterState = {
            ...prev[meterId],
            [field]: updatedFieldValue
          };

          // 利用量の計算
          const previousValue = updatedMeterState.previousValue !== undefined ? parseFloat(updatedMeterState.previousValue) : meters.find(m => m.id === meterId).previousValue;
          const currentValue = updatedMeterState.currentValue !== undefined ? parseFloat(updatedMeterState.currentValue) : meters.find(m => m.id === meterId).currentValue;
          const updatedUsage = currentValue - previousValue;

          updatedMeterState.usage = updatedUsage;

          return {
            ...prev,
            [meterId]: updatedMeterState
          };
        });
      };

      // インポートハンドラー
      const handleImport = (e) => {
        const file = e.target.files[0];
        if (file) {
          Papa.parse(file, {
            header: true,
            skipEmptyLines: true,
            complete: function(results) {
              const importedMeters = results.data.map((row, index) => ({
                id: meters.length + index + 1,
                meterId: row['メーターID'] || "",
                meterName: row['メーター名'] || "",
                locationName: row['拠点名'] || "",
                installationPlace: row['設置場所'] || "",
                manager: row['管理者'] || "",
                previousValue: parseFloat(row['前回値']) || 0,
                previousConfirmationDate: row['前回確認日'] || "",
                previousRegistrant: row['前回登録者'] || "",
                currentValue: parseFloat(row['メーター値']) || 0,
                confirmationDate: row['確認日'] || "",
                registrant: row['登録者'] || "",
                usage: (parseFloat(row['メーター値']) || 0) - (parseFloat(row['前回値']) || 0),
              }));
              setMeters([...meters, ...importedMeters]);

              // 関連設備情報もインポートする場合、必要に応じて以下に追加
              // 例:
              // const importedEquipments = results.data.map(...);
              // setEquipments([...equipments, ...importedEquipments]);

              setSnackbar({ open: true, message: "データをインポートしました。", severity: "success" });
            },
            error: function(error) {
              console.error("インポートエラー:", error);
              setSnackbar({ open: true, message: "インポートに失敗しました。", severity: "error" });
            }
          });
        }
      };

      // エクスポートハンドラー
      const handleExport = () => {
        const dataToExport = filteredMeters.map(meter => ({
          'No.': meter.id,
          'メーターID': meter.meterId,
          'メーター名': meter.meterName,
          '設置場所': meter.installationPlace,
          '拠点名': meter.locationName,
          '管理者': meter.manager,
          '利用量': meter.usage,
          '前回値': meter.previousValue,
          '前回確認日': meter.previousConfirmationDate,
          '前回登録者': meter.previousRegistrant,
          'メーター値': meter.currentValue,
          '確認日': meter.confirmationDate,
          '登録者': meter.registrant,
        }));
        const worksheet = XLSX.utils.json_to_sheet(dataToExport);
        const workbook = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(workbook, worksheet, "メーターデータ");
        XLSX.writeFile(workbook, "meter_data.xlsx");
      };

      // テンプレートダウンロードハンドラーの追加
      const handleDownloadTemplate = () => {
        const templateHeaders = [
          'メーターID',
          'メーター名',
          '拠点名',
          '設置場所',
          '管理者',
          '利用量',
          '前回値',
          '前回確認日',
          '前回登録者',
          'メーター値',
          '確認日',
          '登録者',
        ];

        const templateData = [
          templateHeaders,
          // 例として1行目のデータを追加（必要に応じてコメントアウトを外してください）
          // ['MTR-003', '電気メーター3', '名古屋営業所', '第3営業所', '鈴木 一郎', '100', '3000', '2023-11-20', '鈴木 一郎', '3100', '2024-12-03', '山田 太郎']
        ];

        // CSV文字列を生成
        const csvContent = templateData.map(e => e.join(",")).join("\n");

        // Blobを作成してダウンロード
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.setAttribute("download", "import_template.csv");
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      };

      const handleCloseSnackbar = () => {
        setSnackbar({ ...snackbar, open: false });
      };

      // スナックバーの閉鎖ハンドラー
      const handleCloseMeterSnackbar = () => {
        setMeterSnackbar({ ...meterSnackbar, open: false });
      };

      // 確定ボタンハンドラー
      const handleConfirmChanges = () => {
        // 保存前の状態を保持
        setPreviousMeters(meters);

        // editStatesをmetersに適用
        const updatedMeters = meters.map(meter => {
          if (editStates[meter.id]) {
            // 新しい値を取得、既存の値がない場合は元の値を使用
            const newPreviousValue = editStates[meter.id].previousValue !== undefined ? parseFloat(editStates[meter.id].previousValue) : meter.previousValue;
            const newCurrentValue = editStates[meter.id].currentValue !== undefined ? parseFloat(editStates[meter.id].currentValue) : meter.currentValue;
            const newUsage = newCurrentValue - newPreviousValue;

            const newPreviousConfirmationDate = editStates[meter.id].previousConfirmationDate !== undefined ? editStates[meter.id].previousConfirmationDate : meter.previousConfirmationDate;
            const newConfirmationDate = editStates[meter.id].confirmationDate !== undefined ? editStates[meter.id].confirmationDate : meter.confirmationDate;

            const newPreviousRegistrant = editStates[meter.id].previousRegistrant !== undefined ? editStates[meter.id].previousRegistrant : meter.previousRegistrant;
            const newRegistrant = editStates[meter.id].registrant !== undefined ? editStates[meter.id].registrant : meter.registrant;

            return {
              ...meter,
              ...editStates[meter.id],
              previousValue: newPreviousValue,
              currentValue: newCurrentValue,
              usage: newUsage,
              previousConfirmationDate: newPreviousConfirmationDate,
              confirmationDate: newConfirmationDate,
              previousRegistrant: newPreviousRegistrant,
              registrant: newRegistrant,
            };
          }
          return meter;
        });

        setMeters(updatedMeters);
        setEditStates({});
        setSnackbar({ open: true, message: "変更を確定しました。", severity: "success" });
      };

      // 取り消しボタンハンドラー
      const handleUndoChanges = () => {
        if (Object.keys(editStates).length > 0) {
          // 確定前の変更をキャンセル
          setEditStates({});
          setSnackbar({ open: true, message: "変更を取り消しました。", severity: "info" });
        } else if (previousMeters) {
          // 確定後の変更を元に戻す
          setMeters(previousMeters);
          setPreviousMeters(null);
          setSnackbar({ open: true, message: "変更を元に戻しました。", severity: "warning" });
        }
      };

      // テーブルの選択ハンドラー
      const handleSelectAllClick = (event) => {
        if (event.target.checked) {
          const newSelecteds = filteredMeters.map((meter) => meter.id);
          setSelectedMeterIds(newSelecteds);
          return;
        }
        setSelectedMeterIds([]);
      };

      const handleRowClick = (event, id) => {
        if (selectedMeterIds.includes(id)) {
          setSelectedMeterIds(selectedMeterIds.filter((selectedId) => selectedId !== id));
        } else {
          setSelectedMeterIds([...selectedMeterIds, id]);
        }
      };

      const isSelected = (id) => selectedMeterIds.includes(id);

      // デバッグ用コンソールログ
      useEffect(() => {
        console.log("meters is array:", Array.isArray(meters));
        console.log("meters data:", meters);
      }, [meters]);

      return (
        <Box display="flex" flexDirection="column" minHeight="100vh">
          {/* ヘッダー */}
          <AppBar position="static">
            <Toolbar>
              <Typography variant="h6" component="div" sx={{ flexGrow: 1 }}>
                設備管理システム
              </Typography>
            </Toolbar>
          </AppBar>

          {/* メインコンテンツ */}
          <Box className="content">
            {/* フィルターエリア */}
            <Paper style={{ padding: 20, marginBottom: 20 }}>
              <Grid container spacing={2} alignItems="center">
                {/* 年度フィルター */}
                <Grid item xs={12} sm={6} md={2}>
                  <FormControl variant="outlined" size="small" fullWidth>
                    <InputLabel>年度</InputLabel>
                    <Select
                      value={filterYear}
                      onChange={(e) => setFilterYear(e.target.value)}
                      label="年度"
                    >
                      <MenuItemMUI value=""><em>全て</em></MenuItemMUI>
                      {uniqueYears.map((year) => (
                        <MenuItemMUI key={year} value={year}>{year}年度</MenuItemMUI>
                      ))}
                    </Select>
                  </FormControl>
                </Grid>
                {/* 月度フィルター */}
                <Grid item xs={12} sm={6} md={2}>
                  <FormControl variant="outlined" size="small" fullWidth>
                    <InputLabel>月度</InputLabel>
                    <Select
                      value={filterMonth}
                      onChange={(e) => setFilterMonth(e.target.value)}
                      label="月度"
                    >
                      <MenuItemMUI value=""><em>全て</em></MenuItemMUI>
                      {uniqueMonths.map((month) => (
                        <MenuItemMUI key={month} value={month}>{month}月度</MenuItemMUI>
                      ))}
                    </Select>
                  </FormControl>
                </Grid>
                {/* 拠点フィルター */}
                <Grid item xs={12} sm={6} md={2}>
                  <FormControl variant="outlined" size="small" fullWidth>
                    <InputLabel>拠点フィルター</InputLabel>
                    <Select
                      value={filterLocation}
                      onChange={(e) => setFilterLocation(e.target.value)}
                      label="拠点フィルター"
                    >
                      <MenuItemMUI value=""><em>全て</em></MenuItemMUI>
                      {uniqueLocations.map((location) => (
                        <MenuItemMUI key={location} value={location}>{location}</MenuItemMUI>
                      ))}
                    </Select>
                  </FormControl>
                </Grid>
                {/* 設備カテゴリー */}
                <Grid item xs={12} sm={6} md={2}>
                  <FormControl variant="outlined" size="small" fullWidth>
                    <InputLabel>設備カテゴリー</InputLabel>
                    <Select
                      value={filterCategory}
                      onChange={(e) => setFilterCategory(e.target.value)}
                      label="設備カテゴリー"
                    >
                      <MenuItemMUI value=""><em>全て</em></MenuItemMUI>
                      {uniqueCategories.map((category) => (
                        <MenuItemMUI key={category} value={category}>{category}</MenuItemMUI>
                      ))}
                    </Select>
                  </FormControl>
                </Grid>
                {/* 状態フィルター */}
                <Grid item xs={12} sm={6} md={2}>
                  <FormControl variant="outlined" size="small" fullWidth>
                    <InputLabel>状態フィルター</InputLabel>
                    <Select
                      value={filterStatus}
                      onChange={(e) => setFilterStatus(e.target.value)}
                      label="状態フィルター"
                    >
                      <MenuItemMUI value=""><em>全て</em></MenuItemMUI>
                      <MenuItemMUI value="良好">良好</MenuItemMUI>
                      <MenuItemMUI value="使用中">使用中</MenuItemMUI>
                      <MenuItemMUI value="故障中">故障中</MenuItemMUI>
                      <MenuItemMUI value="稼働中">稼働中</MenuItemMUI>
                    </Select>
                  </FormControl>
                </Grid>
                {/* 検索 */}
                <Grid item xs={12} sm={6} md={2}>
                  <TextField
                    label="検索"
                    variant="outlined"
                    size="small"
                    fullWidth
                    value={searchTerm}
                    onChange={(e) => setSearchTerm(e.target.value)}
                  />
                </Grid>
                {/* フィルターリセットボタン */}
                <Grid item xs={12} sm={12} md={2}>
                  <Button
                    variant="outlined"
                    color="secondary"
                    fullWidth
                    onClick={() => {
                      setFilterYear("");
                      setFilterMonth("");
                      setFilterLocation("");
                      setFilterCategory("");
                      setFilterStatus("");
                      setSearchTerm("");
                    }}
                  >
                    リセット
                  </Button>
                </Grid>
              </Grid>
            </Paper>

            {/* 関連設備情報セクション（選択されたメーターに限定、複数選択時は統合リスト表示） */}
            <Paper style={{ padding: 20, marginBottom: 40 }}>
              <Typography variant="h6" gutterBottom>
                選択されたメーターに関連する設備情報
              </Typography>
              {selectedMeterIds.length > 0 ? (
                (() => {
                  // 選択されたメーターのmeterIdsを取得
                  const selectedMeters = meters.filter(m => selectedMeterIds.includes(m.id));
                  const selectedMeterIdsList = selectedMeters.map(m => m.meterId);

                  // 選択されたメーターに関連する全設備を取得
                  const relatedEquipments = equipments.filter(eq => selectedMeterIdsList.includes(eq.equipmentId));

                  if (relatedEquipments.length > 0) {
                    return (
                      <TableContainer component={Paper}>
                        <Table size="small">
                          <TableHead>
                            <TableRow>
                              <TableCell>No.</TableCell>
                              <TableCell>メーターID</TableCell>
                              <TableCell>メーター名</TableCell>
                              <TableCell>設備ID</TableCell>
                              <TableCell>設備カテゴリー</TableCell>
                              <TableCell>設備名</TableCell>
                              <TableCell>型番</TableCell>
                              <TableCell>購入日</TableCell>
                              <TableCell>拠点</TableCell>
                              <TableCell>設置場所</TableCell>
                              <TableCell>管理者</TableCell>
                              <TableCell>状態</TableCell>
                              <TableCell>メンテナンス予定日</TableCell>
                              <TableCell>メンテナンス前回実施日</TableCell>
                              <TableCell>メンテナンス周期（月）</TableCell>
                              <TableCell>耐用年数（月）</TableCell>
                              <TableCell>更新予定日</TableCell>
                              <TableCell>備考</TableCell>
                              <TableCell>有効</TableCell>
                            </TableRow>
                          </TableHead>
                          <TableBody>
                            {relatedEquipments.map((eq, idx) => {
                              const meter = meters.find(m => m.meterId === eq.equipmentId);
                              return (
                                <TableRow key={eq.no}>
                                  <TableCell>{idx + 1}</TableCell>
                                  <TableCell>{meter?.meterId || "N/A"}</TableCell>
                                  <TableCell>{meter?.meterName || "N/A"}</TableCell>
                                  <TableCell>{eq.equipmentId}</TableCell>
                                  <TableCell>{eq.equipmentCategory}</TableCell>
                                  <TableCell>{eq.equipmentName}</TableCell>
                                  <TableCell>{eq.modelNumber}</TableCell>
                                  <TableCell>{eq.purchaseDate}</TableCell>
                                  <TableCell>{eq.location}</TableCell>
                                  <TableCell>{eq.installationPlace}</TableCell>
                                  <TableCell>{eq.manager}</TableCell>
                                  <TableCell>{eq.status}</TableCell>
                                  <TableCell>{eq.nextMaintenanceDate || "未設定"}</TableCell>
                                  <TableCell>{eq.lastMaintenanceDate || "未設定"}</TableCell>
                                  <TableCell>{eq.maintenanceInterval || "未設定"}</TableCell>
                                  <TableCell>{eq.usefulLife || "未設定"}</TableCell>
                                  <TableCell>{eq.scheduledUpdateDate || "未設定"}</TableCell>
                                  <TableCell>{eq.notes}</TableCell>
                                  <TableCell>
                                    <FormControlLabel
                                      control={
                                        <Switch
                                          checked={eq.active}
                                          onChange={() => {
                                            const updatedEquipments = equipments.map(equipment => equipment.no === eq.no ? { ...equipment, active: !equipment.active } : equipment);
                                            setEquipments(updatedEquipments);
                                            setSnackbar({ open: true, message: "設備の状態を更新しました。", severity: "success" });
                                          }}
                                          color="primary"
                                        />
                                      }
                                      label={eq.active ? "有効" : "無効"}
                                    />
                                  </TableCell>
                                </TableRow>
                              );
                            })}
                          </TableBody>
                        </Table>
                      </TableContainer>
                    );
                  } else {
                    return (
                      <Typography>選択されたメーターに関連する設備が見つかりません。</Typography>
                    );
                  }
                })()
              ) : (
                <Typography>メーターが選択されていません。</Typography>
              )}
            </Paper>

            {/* 確定・取り消しボタン */}
            {(Object.keys(editStates).length > 0 || previousMeters) && (
              <Box className="confirmation-buttons">
                {Object.keys(editStates).length > 0 && (
                  <>
                    <Button variant="contained" color="primary" onClick={handleConfirmChanges} style={{ marginRight: 10 }}>
                      確定
                    </Button>
                    <Button variant="outlined" color="secondary" onClick={handleUndoChanges}>
                      取り消し
                    </Button>
                  </>
                )}
                {previousMeters && !Object.keys(editStates).length && (
                  <Button variant="outlined" color="secondary" onClick={handleUndoChanges}>
                    取り消し
                  </Button>
                )}
              </Box>
            )}

            {/* メーター管理セクション */}
            <Paper style={{ padding: 20 }}>
              <Grid container spacing={2} alignItems="center" style={{ marginBottom: 20 }}>
                <Grid item xs={12} md={6}>
                  <Toolbar>
                    <Typography variant="h6" component="div" style={{ flexGrow: 1 }}>
                      メーター管理テーブル
                    </Typography>
                  </Toolbar>
                </Grid>
                <Grid item xs={12} md={6} style={{ textAlign: 'right' }}>
                  <Button variant="contained" color="primary" onClick={handleOpenMeterDialog} style={{ marginRight: 10 }}>
                    メーター追加
                  </Button>
                  <Button variant="contained" color="success" onClick={handleExport} style={{ marginRight: 10 }}>
                    エクスポート
                  </Button>
                  {/* テンプレートダウンロードボタンの追加 */}
                  <Button variant="contained" color="warning" onClick={handleDownloadTemplate} style={{ marginRight: 10 }}>
                    テンプレートダウンロード
                  </Button>
                  <input
                    accept=".csv, .xlsx, .xls"
                    style={{ display: 'none' }}
                    id="import-file-meter"
                    type="file"
                    onChange={handleImport}
                  />
                  <label htmlFor="import-file-meter">
                    <Button variant="contained" color="secondary" component="span">
                      インポート
                    </Button>
                  </label>
                </Grid>
              </Grid>

              {/* メーター管理テーブル */}
              <TableContainer component={Paper}>
                <Table size="small" stickyHeader>
                  <TableHead>
                    <TableRow>
                      <TableCell padding="checkbox">
                        <Checkbox
                          indeterminate={selectedMeterIds.length > 0 && selectedMeterIds.length < filteredMeters.length}
                          checked={filteredMeters.length > 0 && selectedMeterIds.length === filteredMeters.length}
                          onChange={handleSelectAllClick}
                          color="primary"
                        />
                      </TableCell>
                      <TableCell>No.</TableCell>
                      <TableCell>メーターID</TableCell>
                      <TableCell>メーター名</TableCell>
                      <TableCell>設置場所</TableCell>
                      <TableCell>拠点名</TableCell>
                      <TableCell>管理者</TableCell>
                      <TableCell>利用量</TableCell>
                      <TableCell>前回値</TableCell>
                      <TableCell>前回確認日</TableCell>
                      <TableCell>前回登録者</TableCell>
                      <TableCell>メーター値</TableCell>
                      <TableCell>確認日</TableCell>
                      <TableCell>登録者</TableCell>
                      <TableCell>操作</TableCell> {/* 操作列を追加 */}
                    </TableRow>
                  </TableHead>
                  <TableBody>
                    {(rowsPerPage > 0
                      ? filteredMeters.slice(page * rowsPerPage, page * rowsPerPage + rowsPerPage)
                      : filteredMeters
                    ).map((meter, index) => {
                      const isItemSelected = isSelected(meter.id);
                      const labelId = `enhanced-table-checkbox-${index}`;

                      // 編集された値を取得
                      const editedMeter = editStates[meter.id] || {};
                      const previousValue = editedMeter.previousValue !== undefined ? editedMeter.previousValue : meter.previousValue;
                      const currentValue = editedMeter.currentValue !== undefined ? editedMeter.currentValue : meter.currentValue;
                      const usage = currentValue - previousValue;

                      return (
                        <TableRow 
                          key={meter.id} 
                          hover 
                          role="checkbox"
                          aria-checked={isItemSelected}
                          selected={isItemSelected}
                          onClick={() => handleRowClick(null, meter.id)}
                          style={{ cursor: 'pointer' }}
                        >
                          <TableCell padding="checkbox">
                            <Checkbox
                              checked={isItemSelected}
                              onChange={(event) => handleRowClick(event, meter.id)}
                              color="primary"
                              inputProps={{
                                'aria-labelledby': labelId,
                              }}
                              onClick={(e) => e.stopPropagation()} // チェックボックスのクリックで行選択を防ぐ
                            />
                          </TableCell>
                          <TableCell>{index + 1}</TableCell>
                          <TableCell>{meter.meterId}</TableCell>
                          <TableCell>{meter.meterName}</TableCell>
                          <TableCell>{meter.installationPlace}</TableCell>
                          <TableCell>{meter.locationName}</TableCell>
                          <TableCell>{meter.manager}</TableCell>
                          <TableCell>{usage}</TableCell>
                          {/* Editable Cells */}
                          {['previousValue', 'previousConfirmationDate', 'previousRegistrant', 'currentValue', 'confirmationDate', 'registrant'].map(field => {
                            const hasEdit = editStates[meter.id] && field in editStates[meter.id];
                            const cellValue = hasEdit ? editStates[meter.id][field] : meter[field];
                            const isChanged = hasEdit;
                            return (
                              <TableCell
                                key={field}
                                className={isChanged ? 'changed-cell' : ''}
                              >
                                <Tooltip title={isChanged ? `元の値: ${meter[field]}` : ''}>
                                  {field.includes('Date') ? (
                                    <TextField
                                      type="date"
                                      value={cellValue}
                                      onChange={(e) => handleCellValueChange(meter.id, field, e.target.value)}
                                      className="editable-input"
                                      InputLabelProps={{
                                        shrink: true,
                                      }}
                                      onClick={(e) => e.stopPropagation()} // テーブル行の選択を防ぐ
                                    />
                                  ) : (
                                    <TextField
                                      type={field.includes('Value') ? 'number' : 'text'}
                                      value={cellValue}
                                      onChange={(e) => handleCellValueChange(meter.id, field, e.target.value)}
                                      className="editable-input"
                                      onClick={(e) => e.stopPropagation()} // テーブル行の選択を防ぐ
                                    />
                                  )}
                                </Tooltip>
                              </TableCell>
                            );
                          })}
                          {/* 操作列 */}
                          <TableCell>
                            <IconButton onClick={(e) => { e.stopPropagation(); handleEditMeter(meter); }}>
                              <span className="material-icons">edit</span>
                            </IconButton>
                            <IconButton onClick={(e) => { e.stopPropagation(); handleMenuClick(e, meter); }}>
                              <span className="material-icons">more_vert</span>
                            </IconButton>
                          </TableCell>
                        </TableRow>
                      );
                    })}
                    {filteredMeters.length === 0 && (
                      <TableRow>
                        <TableCell colSpan={15} align="center">
                          メーターが登録されていません。
                        </TableCell>
                      </TableRow>
                    )}
                  </TableBody>
                </Table>
              </TableContainer>

              {/* 操作メニュー */}
              <Menu
                anchorEl={anchorEl}
                open={Boolean(anchorEl)}
                onClose={handleMenuClose}
              >
                <MenuItemMUI onClick={() => handleMenuAction('詳細')}>詳細</MenuItemMUI>
                <MenuItemMUI onClick={() => handleMenuAction('記録')}>記録</MenuItemMUI>
                <MenuItemMUI onClick={() => handleMenuAction('履歴')}>履歴</MenuItemMUI>
                <MenuItemMUI onClick={() => handleMenuAction('削除')}>削除</MenuItemMUI>
              </Menu>

              {/* ページネーション */}
              <Grid container alignItems="center" justifyContent="flex-end" style={{ marginTop: 20 }}>
                <Grid item>
                  <Grid container alignItems="center">
                    <Typography variant="body2" style={{ marginRight: 10 }}>
                      合計件数: {filteredMeters.length} 件
                    </Typography>
                    <Typography variant="body2" style={{ marginRight: 10 }}>
                      1ページあたりの件数:
                    </Typography>
                    <FormControl variant="outlined" size="small" style={{ width: 120, marginRight: 10 }}>
                      <InputLabel>表示件数</InputLabel>
                      <Select
                        value={rowsPerPageOption}
                        onChange={handleRowsPerPageOptionChange}
                        label="表示件数"
                      >
                        <MenuItemMUI value="10">10</MenuItemMUI>
                        <MenuItemMUI value="20">20</MenuItemMUI>
                        <MenuItemMUI value="30">30</MenuItemMUI>
                        <MenuItemMUI value="全て">全て</MenuItemMUI>
                        <MenuItemMUI value="数値入力">数値入力</MenuItemMUI>
                      </Select>
                    </FormControl>
                    {rowsPerPageOption === '数値入力' && (
                      <TextField
                        value={customRowsPerPage}
                        onChange={handleCustomRowsPerPageChange}
                        variant="outlined"
                        size="small"
                        type="number"
                        inputProps={{ min: 1 }}
                        style={{ width: 80, marginRight: 10 }}
                      />
                    )}
                    <TablePagination
                      component="div"
                      count={filteredMeters.length}
                      rowsPerPage={rowsPerPage}
                      page={page}
                      onPageChange={handleChangePage}
                      style={{ border: 'none' }}
                      labelRowsPerPage=""
                      rowsPerPageOptions={[]}
                    />
                  </Grid>
                </Grid>
              </Grid>
            </Paper>
          </Box>

          {/* フッター */}
          <Box className="footer">
            <Typography variant="body2">
              © 2024 設備管理システム. All rights reserved.
            </Typography>
          </Box>

          {/* メーター追加・編集ダイアログ */}
          <Dialog open={meterDialogOpen} onClose={handleCloseMeterDialog} maxWidth="sm" fullWidth>
            <DialogTitle>{editMeter ? "メーター編集" : "メーター追加"}</DialogTitle>
            <DialogContent>
              <Grid container spacing={2}>
                <Grid item xs={12} sm={6}>
                  <TextField
                    label="メーターID"
                    variant="outlined"
                    fullWidth
                    required
                    name="meterId"
                    value={newMeter.meterId}
                    onChange={handleMeterChange}
                  />
                </Grid>
                <Grid item xs={12} sm={6}>
                  <TextField
                    label="メーター名"
                    variant="outlined"
                    fullWidth
                    required
                    name="meterName"
                    value={newMeter.meterName}
                    onChange={handleMeterChange}
                  />
                </Grid>
                <Grid item xs={12} sm={6}>
                  <TextField
                    label="拠点名"
                    variant="outlined"
                    fullWidth
                    name="locationName"
                    value={newMeter.locationName}
                    onChange={handleMeterChange}
                  />
                </Grid>
                <Grid item xs={12} sm={6}>
                  <TextField
                    label="設置場所"
                    variant="outlined"
                    fullWidth
                    name="installationPlace"
                    value={newMeter.installationPlace}
                    onChange={handleMeterChange}
                  />
                </Grid>
                <Grid item xs={12} sm={6}>
                  <TextField
                    label="管理者"
                    variant="outlined"
                    fullWidth
                    name="manager"
                    value={newMeter.manager}
                    onChange={handleMeterChange}
                  />
                </Grid>
                <Grid item xs={12} sm={6}>
                  <TextField
                    label="前回値"
                    variant="outlined"
                    fullWidth
                    type="number"
                    name="previousValue"
                    value={newMeter.previousValue}
                    onChange={handleMeterChange}
                  />
                </Grid>
                <Grid item xs={12} sm={6}>
                  <TextField
                    label="前回確認日"
                    variant="outlined"
                    fullWidth
                    type="date"
                    name="previousConfirmationDate"
                    InputLabelProps={{
                      shrink: true,
                    }}
                    value={newMeter.previousConfirmationDate}
                    onChange={handleMeterChange}
                  />
                </Grid>
                <Grid item xs={12} sm={6}>
                  <TextField
                    label="前回登録者"
                    variant="outlined"
                    fullWidth
                    name="previousRegistrant"
                    value={newMeter.previousRegistrant}
                    onChange={handleMeterChange}
                  />
                </Grid>
                <Grid item xs={12} sm={6}>
                  <TextField
                    label="メーター値"
                    variant="outlined"
                    fullWidth
                    type="number"
                    name="currentValue"
                    value={newMeter.currentValue}
                    onChange={handleMeterChange}
                  />
                </Grid>
                <Grid item xs={12} sm={6}>
                  <TextField
                    label="確認日"
                    variant="outlined"
                    fullWidth
                    type="date"
                    name="confirmationDate"
                    InputLabelProps={{
                      shrink: true,
                    }}
                    value={newMeter.confirmationDate}
                    onChange={handleMeterChange}
                  />
                </Grid>
                <Grid item xs={12} sm={6}>
                  <TextField
                    label="登録者"
                    variant="outlined"
                    fullWidth
                    name="registrant"
                    value={newMeter.registrant}
                    onChange={handleMeterChange}
                  />
                </Grid>
                <Grid item xs={12} sm={6}>
                  <TextField
                    label="利用量"
                    variant="outlined"
                    fullWidth
                    type="number"
                    name="usage"
                    value={newMeter.usage}
                    InputProps={{
                      readOnly: true,
                    }}
                  />
                </Grid>
              </Grid>
            </DialogContent>
            <DialogActions>
              <Button onClick={handleCloseMeterDialog} color="secondary">
                キャンセル
              </Button>
              <Button onClick={handleAddOrEditMeter} color="primary" variant="contained">
                {editMeter ? "更新" : "追加"}
              </Button>
            </DialogActions>
          </Dialog>

          {/* サブメニュー用モーダルダイアログ */}
          <Dialog open={openSubMenuDialog} onClose={handleCloseSubMenuDialog} maxWidth="sm" fullWidth>
            <DialogTitle>
              {subMenuAction === "詳細" && "詳細情報"}
              {subMenuAction === "記録" && "記録情報"}
              {subMenuAction === "履歴" && "履歴情報"}
            </DialogTitle>
            <DialogContent>
              {currentRow && (
                <>
                  <Typography variant="subtitle1" gutterBottom>
                    メーターID: {currentRow.meterId}
                  </Typography>
                  <Typography variant="subtitle1" gutterBottom>
                    メーター名: {currentRow.meterName}
                  </Typography>
                  <Typography variant="subtitle1" gutterBottom>
                    管理者: {currentRow.manager}
                  </Typography>
                  {subMenuAction === "詳細" && (
                    <>
                      <Typography variant="body1" gutterBottom>
                        拠点名: {currentRow.locationName}
                      </Typography>
                      <Typography variant="body1" gutterBottom>
                        設置場所: {currentRow.installationPlace}
                      </Typography>
                      <Typography variant="body1" gutterBottom>
                        前回値: {currentRow.previousValue}
                      </Typography>
                      <Typography variant="body1" gutterBottom>
                        前回確認日: {currentRow.previousConfirmationDate || "未設定"}
                      </Typography>
                      <Typography variant="body1" gutterBottom>
                        前回登録者: {currentRow.previousRegistrant || "未設定"}
                      </Typography>
                      <Typography variant="body1" gutterBottom>
                        メーター値: {currentRow.currentValue}
                      </Typography>
                      <Typography variant="body1" gutterBottom>
                        確認日: {currentRow.confirmationDate || "未設定"}
                      </Typography>
                      <Typography variant="body1" gutterBottom>
                        登録者: {currentRow.registrant || "未設定"}
                      </Typography>
                      <Typography variant="body1" gutterBottom>
                        利用量: {currentRow.usage}
                      </Typography>
                    </>
                  )}
                  {subMenuAction === "記録" && (
                    <>
                      {/* 記録情報の詳細をここに追加 */}
                      <Typography variant="body1" gutterBottom>
                        記録情報がここに表示されます。
                      </Typography>
                    </>
                  )}
                  {subMenuAction === "履歴" && (
                    <>
                      {/* 履歴情報の詳細をここに追加 */}
                      <Typography variant="body1" gutterBottom>
                        履歴情報がここに表示されます。
                      </Typography>
                    </>
                  )}
                </>
              )}
            </DialogContent>
            <DialogActions>
              <Button onClick={handleCloseSubMenuDialog} color="primary">
                閉じる
              </Button>
            </DialogActions>
          </Dialog>

          {/* スナックバー（一般用） */}
          <Snackbar
            open={snackbar.open}
            autoHideDuration={3000}
            onClose={handleCloseSnackbar}
            anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}
          >
            <Alert onClose={handleCloseSnackbar} severity={snackbar.severity} sx={{ width: '100%' }}>
              {snackbar.message}
            </Alert>
          </Snackbar>

          {/* スナックバー（メーター管理用） */}
          <Snackbar
            open={meterSnackbar.open}
            autoHideDuration={3000}
            onClose={handleCloseMeterSnackbar}
            anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}
          >
            <Alert onClose={handleCloseMeterSnackbar} severity={meterSnackbar.severity} sx={{ width: '100%' }}>
              {meterSnackbar.message}
            </Alert>
          </Snackbar>
        </Box>
        );
    }
      ReactDOM.render(<App />, document.getElementById('root'));
      </script>
    </body>
</html>
