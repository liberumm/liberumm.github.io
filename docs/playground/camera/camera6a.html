<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="shortcut icon" href="./images/favicon.ico">
    <title>QuaggaJS with React and Material-UI</title>

    <!-- Fonts to support Material Design -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap"
    />
    <!-- Icons to support Material Design -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons" />

    <!-- React and ReactDOM -->
    <script src="https://cdn.jsdelivr.net/npm/react@18/umd/react.production.min.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/react-dom@18/umd/react-dom.production.min.js" crossorigin="anonymous"></script>
    <!-- Emotion ライブラリ -->
    <script src="https://cdn.jsdelivr.net/npm/@emotion/react@11.11.0/dist/emotion-react.umd.min.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@emotion/styled@11.11.0/dist/emotion-styled.umd.min.js" crossorigin="anonymous"></script>
    <!-- MUI (Material-UI) v5 -->
    <script src="https://cdn.jsdelivr.net/npm/@mui/material@5.11.15/umd/material-ui.production.min.js" crossorigin="anonymous"></script>
    <!-- Babel for JSX -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.21.0/babel.min.js" crossorigin="anonymous"></script>

    <!-- QuaggaJS library -->
    <script src="https://unpkg.com/@ericblade/quagga2@1.7.4/dist/quagga.min.js"></script>
    
    <style>
        /* Body layout and styling */
        body {
            background-color: white; 
            font-size: 12px; 
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        /* Main content area */
        .main-content {
            flex: 1;
            padding: 16px;
            padding-top: 64px; /* AppBarの高さ分 */
        }
        /* QuaggaJS canvas area styling */
        #my_quagga {
            width: 100%; 
            height: 50vh; 
            margin: 0;
            position: relative;
            background-color: #f5f5f5; 
            cursor: pointer;
            border-radius: 8px;
            overflow: hidden;
        }
        /* Ensures Quagga's video and canvas take up the full area */
        #my_quagga video, #my_quagga canvas {
            width: 100%; 
            height: 100%; 
            position: absolute; 
            top: 0; 
            left: 0;
        }
        /* Error message styling */
        .error {
            color: red;
        }
        /* History section styling with scrolling enabled */
        #history {
            margin-top: 5px;
            color: black; 
            text-align: left;
            max-height: 20vh; 
            overflow-y: auto; 
            cursor: pointer;
            padding-left: 0;
        }
        #history ul {
            list-style-type: none; 
            padding-left: 0;
        }
        /* Modal history area with scrolling */
        #modal-history {
            max-height: 40vh;
            overflow-y: auto;
            padding: 10px;
            text-align: left;
        }
        /* Modal content layout */
        .modal-content {
            background-color: white;
            padding: 10px;
            border-radius: 10px;
            max-width: 90%;
            margin: 20px auto;
        }
        /* Advanced settings styling */
        .advanced-settings {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        /* Footer styling */
        .footer {
            padding: 16px;
            background-color: #f5f5f5;
            text-align: center;
        }
    </style>

</head>
<body>
    <div id="root"></div>
    <!-- Usage -->
    <script type="text/babel">
        // Destructure necessary components from MaterialUI
        const {
            Button,
            Switch,
            Typography,
            Modal,
            TextField,
            Container,
            Grid,
            Box,
            Select,
            MenuItem,
            InputLabel,
            FormControl,
            Checkbox,
            ListItemText,
            OutlinedInput,
            ThemeProvider,
            createTheme,
            AppBar,
            Toolbar,
            IconButton,
            Icon,
            Paper,
            Alert,
            List,
            ListItem,
            ListItemIcon,
            FormControlLabel,
            RadioGroup,
            Radio
        } = MaterialUI;

        const { useEffect, useRef, useState } = React;

        // デフォルトテーマを作成
        const defaultTheme = createTheme({
            palette: {
                mode: 'light', // デフォルトはライトモード
            },
        });

        function BarcodeScanner() {
            const quaggaRef = useRef(null);
            const captureCanvasRef = useRef(null);

            // バーコード読み取り結果
            const [result, setResult] = useState("***");
            const [totalScans, setTotalScans] = useState(0);
            const [errorMessage, setErrorMessage] = useState("");
            const [history, setHistory] = useState([]);

            // モード管理
            const [singleMode, setSingleMode] = useState(false);
            const [isScanning, setIsScanning] = useState(false);

            // モーダル管理
            const [modalOpen, setModalOpen] = useState(false);
            const [singleScanModalOpen, setSingleScanModalOpen] = useState(false);
            const [modalHistory, setModalHistory] = useState([]);

            // 履歴検索
            const [searchTerm, setSearchTerm] = useState("");
            const [searchResults, setSearchResults] = useState([]);

            // 詳細設定
            const [showAdvancedSettings, setShowAdvancedSettings] = useState(false);

            // カメラ設定
            const [cameraFacingMode, setCameraFacingMode] = useState("environment"); // 'environment' or 'user'
            const [isTorchOn, setIsTorchOn] = useState(false);
            const [currentStream, setCurrentStream] = useState(null);

            // BoxとLineの表示管理
            const [showBox, setShowBox] = useState(true); // デフォルトは表示
            const [showLine, setShowLine] = useState(true); // デフォルトは表示

            // QuaggaJSの設定オプション
            const [inputStreamOptions, setInputStreamOptions] = useState({
                name: 'Live',
                type: 'LiveStream',
                constraints: {
                    width: 640,
                    height: 480,
                    facingMode: 'environment'
                },
                area: { 
                    top: "0%", 
                    right: "0%",
                    bottom: "0%", 
                    left: "0%"
                }
            });

            const [decoderOptions, setDecoderOptions] = useState({
                readers: ['code_128_reader', 'ean_reader', 'ean_8_reader'],
                multiple: false,
                locate: true,
                halfSample: true,
                patchSize: 'medium'
            });

            const [otherOptions, setOtherOptions] = useState({
                numOfWorkers: 4,
                frequency: 10
            });

            // 必要な連続検出回数
            const [requiredConsecutiveDetections, setRequiredConsecutiveDetections] = useState(3);
            const lastDetectedCodeRef = useRef(null);
            const currentConsecutiveDetectionsRef = useRef(0);

            // 既存のstate定義に追加
            const [settingsModalOpen, setSettingsModalOpen] = useState(false);
            const [capturedImages, setCapturedImages] = useState([]); // 読み取り成功時の画像を保存
            const [downloadType, setDownloadType] = useState('text'); // 'text' or 'full'
            const [resultModalOpen, setResultModalOpen] = useState(false);

            // 既存のref定義の後に追加
            const videoRef = useRef(null);

            // 設定モーダルの開閉
            const handleSettingsModal = () => {
                setSettingsModalOpen(!settingsModalOpen);
            };

            // 読み取り結果モーダルの開閉
            const handleResultModal = () => {
                setResultModalOpen(!resultModalOpen);
            };

            // 画像のキャプチャ処理
            const captureImage = async () => {
                if (!quaggaRef.current) return null;
                
                const video = quaggaRef.current.querySelector('video');
                const canvas = document.createElement('canvas');
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(video, 0, 0);
                return canvas.toDataURL('image/jpeg');
            };

            // 履歴のダウンロード
            const downloadHistory = () => {
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                if (downloadType === 'text') {
                    // テキストのみ
                    const content = history.map(item => 
                        `Code: ${item.code}, Timestamp: ${item.timestamp}`
                    ).join('\n');
                    
                    const blob = new Blob([content], { type: 'text/plain' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `barcode-history-${timestamp}.txt`;
                    a.click();
                    URL.revokeObjectURL(url);
                } else {
                    // 画像付き
                    const zip = new JSZip();
                    let textContent = '';
                    
                    history.forEach((item, index) => {
                        textContent += `Code: ${item.code}, Timestamp: ${item.timestamp}\n`;
                        if (item.image) {
                            const imageData = item.image.split(',')[1];
                            zip.file(`image-${index}.jpg`, imageData, {base64: true});
                        }
                    });
                    
                    zip.file('history.txt', textContent);
                    zip.generateAsync({type: 'blob'}).then(content => {
                        const url = URL.createObjectURL(content);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `barcode-history-${timestamp}.zip`;
                        a.click();
                        URL.revokeObjectURL(url);
                    });
                }
            };

            // イベントリスナーの設定
            useEffect(() => {
                // バーコード検出時の処理
                const handleDetected = async (result) => {
                    const barcodeValue = result.codeResult.code;
                    const timestamp = new Date().toLocaleString();
                    const capturedImage = await captureImage();

                    if (barcodeValue === lastDetectedCodeRef.current) {
                        currentConsecutiveDetectionsRef.current += 1;

                        if (currentConsecutiveDetectionsRef.current >= requiredConsecutiveDetections) {
                            // 認識成功
                            setResult(barcodeValue);
                            setTotalScans(prev => prev + 1);
                            setHistory(prev => [...prev, { 
                                code: barcodeValue, 
                                timestamp,
                                image: capturedImage 
                            }]);
                            currentConsecutiveDetectionsRef.current = 0; // リセット
                            lastDetectedCodeRef.current = null; // リセット

                            if (singleMode) {
                                setModalHistory([{ code: barcodeValue, timestamp }]);
                                stopScanner(); // スキャナーを停止
                                setSingleScanModalOpen(true); // モーダルを開く
                            }
                        }
                    } else {
                        // 新しいバーコードが検出された場合、カウントをリセット
                        lastDetectedCodeRef.current = barcodeValue;
                        currentConsecutiveDetectionsRef.current = 1;
                    }
                };

                // handleProcessed 関数を修正して box と line を条件付きで描画
                const handleProcessed = (result) => {
                    if (!result || typeof result !== "object" || !result.boxes) return;
                    const ctx = Quagga.canvas.ctx.overlay;
                    const canvas = Quagga.canvas.dom.overlay;
                    ctx.clearRect(0, 0, parseInt(canvas.width), parseInt(canvas.height));

                    // デバッグ用に showBox と showLine の値をログ出力
                    console.log("showBox:", showBox, "showLine:", showLine);

                    if (showBox) {
                        Quagga.ImageDebug.drawPath(result.box, { x: 0, y: 1 }, ctx, { color: "blue", lineWidth: 5 });
                    }

                    if (showLine) {
                        Quagga.ImageDebug.drawPath(result.line, { x: 'x', y: 'y' }, ctx, { color: "red", lineWidth: 3 });
                    }
                };

                Quagga.onDetected(handleDetected);
                Quagga.onProcessed(handleProcessed);

                // クリーンアップ
                return () => {
                    Quagga.offDetected(handleDetected);
                    Quagga.offProcessed(handleProcessed);
                    Quagga.stop();
                };
            }, [singleMode, requiredConsecutiveDetections, showBox, showLine]); // 依存関係を最小限に


            // スキャナーの初期化・開始
            const startScanner = () => {
                setErrorMessage("");
                setIsScanning(true);
                currentConsecutiveDetectionsRef.current = 0;
                lastDetectedCodeRef.current = null;

                Quagga.init({
                    inputStream: {
                        name: inputStreamOptions.name,
                        type: inputStreamOptions.type,
                        target: quaggaRef.current,
                        constraints: {
                            ...inputStreamOptions.constraints,
                            // MediaStreamの制約を明示的に設定
                            width: { ideal: inputStreamOptions.constraints.width },
                            height: { ideal: inputStreamOptions.constraints.height },
                            facingMode: inputStreamOptions.constraints.facingMode
                        },
                        area: inputStreamOptions.area
                    },
                    decoder: decoderOptions,
                    locate: decoderOptions.locate,
                    numOfWorkers: otherOptions.numOfWorkers,
                    frequency: otherOptions.frequency
                }, (err) => {
                    if (err) {
                        setErrorMessage("初期化エラー: " + err.message);
                        setIsScanning(false);
                        return;
                    }
                    Quagga.start();

                    // カメラストリームの取得を修正
                    const getStream = async () => {
                        try {
                            // videoElementを取得
                            const videoElement = quaggaRef.current.querySelector('video');
                            if (videoElement && videoElement.srcObject) {
                                setCurrentStream(videoElement.srcObject);
                            }
                        } catch (error) {
                            console.error("カメラストリーム取得エラー:", error);
                        }
                    };
                    getStream();
                });
            };

            // スキャナーの停止
            const stopScanner = () => {
                Quagga.stop();
                setIsScanning(false);
                //setIsTorchOn(false); // トーチをオフにする
                currentConsecutiveDetectionsRef.current = 0;
                lastDetectedCodeRef.current = null;
            };

            // スキャナーの切り替え
            const toggleScanner = () => {
                if (isScanning) {
                    stopScanner();
                } else {
                    startScanner();
                }
            };

            // 履歴のリセット
            const resetHistory = () => {
                setHistory([]);
            };

            // モードの切り替え
            const handleToggle = () => {
                setSingleMode(prev => {
                    const newMode = !prev;
                    if (newMode) {
                        // 単発モードに切り替える場合はスキャナーを停止
                        stopScanner();
                    } else {
                        // 連続モードに切り替える場合はスキャナーを停止
                        stopScanner();
                    }
                    return newMode;
                });
            };

            // モーダルの閉鎖
            const handleCloseModal = () => {
                setModalOpen(false);
            };

            const handleSingleScanClose = () => {
                setSingleScanModalOpen(false);
                if (!singleMode) {
                    startScanner(); // 再スキャンモードの場合はスキャナーを開始
                }
            };

            // 履歴モーダルの表示
            const handleHistoryClick = () => {
                setModalHistory(history);
                setModalOpen(true);
            };

            // 履歴検索
            const handleSearch = () => {
                const results = history.filter(item =>
                    item.code.includes(searchTerm) || item.timestamp.includes(searchTerm)
                );
                setSearchResults(results);
            };

            // カメラの切り替え
            const switchCamera = () => {
                const newFacingMode = cameraFacingMode === "environment" ? "user" : "environment";
                setCameraFacingMode(newFacingMode);
                setInputStreamOptions(prev => ({
                    ...prev,
                    constraints: {
                        ...prev.constraints,
                        facingMode: newFacingMode
                    }
                }));
                stopScanner();
                if (!singleMode) {
                    stopScanner();
                }
            };

            // トーチの切り替え
            const toggleTorch = () => {
                if (navigator.userAgent.includes('iPhone') && navigator.userAgent.includes('Safari')) {
                    alert("iPhone Safariではライト機能はサポートされていません。");
                } else {
                    if (currentStream) {
                        currentStream.getTracks().forEach(track => {
                            if (track.kind === 'video') {
                                const capabilities = track.getCapabilities();
                                if (capabilities.torch) {
                                    track.applyConstraints({
                                        advanced: [{ torch: !isTorchOn }]
                                    }).then(() => {
                                        setIsTorchOn(prev => !prev);
                                    }).catch(err => {
                                        console.error("トーチの切り替えエラー: ", err);
                                        setErrorMessage("トーチの切り替えに失敗しました。");
                                    });
                                } else {
                                    alert("このデバイスではトーチ機能がサポートされていません。");
                                }
                            }
                        });
                    } else {
                        // カメラストリームが取得できない場合の処理（必要に応じて追加）
                    }
                }
            };

            // 詳細設定の切り替え
            const toggleAdvancedSettings = () => {
                setShowAdvancedSettings(prev => !prev);
            };

            // 詳細設定の適用
            const applyAdvancedSettings = () => {
                if (isScanning) {
                    stopScanner();
                    startScanner();
                }
                setShowAdvancedSettings(false);
            };

            // AppBarコンポーネント
            const AppBarComponent = () => (
                <AppBar position="fixed" color="primary">
                    <Toolbar>
                        <IconButton
                            edge="start"
                            color="inherit"
                            aria-label="menu"
                            sx={{ mr: 2 }}
                        >
                            <Icon>menu</Icon>
                        </IconButton>
                        <Typography variant="h6" component="div" sx={{ flexGrow: 1 }}>
                            Barcode Scanner
                        </Typography>
                        <IconButton
                            color="inherit"
                            onClick={handleSettingsModal}
                        >
                            <Icon>settings</Icon>
                        </IconButton>
                    </Toolbar>
                </AppBar>
            );

            // Footerコンポーネント
            const Footer = () => (
                <Box className="footer">
                    <Typography variant="body2" color="text.secondary">
                        © 2023 Barcode Scanner. All rights reserved.
                    </Typography>
                </Box>
            );

            // 設定モーダル
            const SettingsModal = () => (
                <Modal
                    open={settingsModalOpen}
                    onClose={handleSettingsModal}
                    aria-labelledby="settings-modal-title"
                >
                    <Container className="modal-content">
                        <Typography variant="h6" id="settings-modal-title">詳細設定</Typography>
                        {/* 既存の詳細設定のコンテンツをここに移動 */}
                        <Grid item>
                            <div className="advanced-settings">
                                <Typography variant="h6">設定</Typography>
                                {/* スキャンボックスとスキャンラインの表示切替 */}
                                <Grid container spacing={1}>
                                    <Grid item xs={6}>
                                        <Typography variant="body2">スキャンボックス表示</Typography>
                                        <Switch
                                            checked={showBox}
                                            onChange={(e) => {
                                                setShowBox(e.target.checked);
                                            }}
                                            id="box-toggle-switch"
                                        />
                                    </Grid>
                                    <Grid item xs={6}>
                                        <Typography variant="body2">スキャンライン表示</Typography>
                                        <Switch
                                            checked={showLine}
                                            onChange={(e) => setShowLine(e.target.checked)}
                                            id="line-toggle-switch"
                                        />
                                    </Grid>
                                </Grid>
                                <Grid container spacing={1}>
                                    {/* 連続検出回数の設定 */}
                                    <Grid item xs={12} md={12}>
                                        <Typography variant="subtitle1">連続検出回数</Typography>
                                        <Grid container spacing={1}>
                                            <Grid item xs={12}>
                                                <TextField
                                                    label="必要な連続検出回数"
                                                    type="number"
                                                    fullWidth
                                                    value={requiredConsecutiveDetections}
                                                    onChange={(e) => {
                                                        const value = parseInt(e.target.value);
                                                        if (value > 0) {
                                                            setRequiredConsecutiveDetections(value);
                                                        }
                                                    }}
                                                    inputProps={{ min: 1 }}
                                                />
                                            </Grid>
                                        </Grid>
                                    </Grid>
                                    {/* InputStream Options */}
                                    <Grid item xs={12} md={12}>
                                        <Typography variant="subtitle1">Input Stream Options</Typography>
                                        <Grid container spacing={2}>
                                            <Grid item xs={12}>
                                                <FormControl fullWidth>
                                                    <InputLabel id="facing-mode-label">カメラ方向</InputLabel>
                                                    <Select
                                                        labelId="facing-mode-label"
                                                        id="facing-mode-select"
                                                        value={cameraFacingMode}
                                                        label="カメラ方向"
                                                        onChange={(e) => {
                                                            const newFacingMode = e.target.value;
                                                            setCameraFacingMode(newFacingMode);
                                                            setInputStreamOptions(prev => ({
                                                                ...prev,
                                                                constraints: {
                                                                    ...prev.constraints,
                                                                    facingMode: newFacingMode
                                                                }
                                                            }));
                                                        }}
                                                    >
                                                        <MenuItem value="environment">背面カメラ</MenuItem>
                                                        <MenuItem value="user">前面カメラ</MenuItem>
                                                    </Select>
                                                </FormControl>
                                            </Grid>
                                            <Grid item xs={6}>
                                                <TextField
                                                    label="幅 (px)"
                                                    type="number"
                                                    fullWidth
                                                    value={inputStreamOptions.constraints.width}
                                                    onChange={(e) => setInputStreamOptions(prev => ({
                                                        ...prev,
                                                        constraints: {
                                                            ...prev.constraints,
                                                            width: parseInt(e.target.value) || 640
                                                        }
                                                    }))}
                                                />
                                            </Grid>
                                            <Grid item xs={6}>
                                                <TextField
                                                    label="高さ (px)"
                                                    type="number"
                                                    fullWidth
                                                    value={inputStreamOptions.constraints.height}
                                                    onChange={(e) => setInputStreamOptions(prev => ({
                                                        ...prev,
                                                        constraints: {
                                                            height: parseInt(e.target.value) || 480
                                                        }
                                                    }))}
                                                />
                                            </Grid>
                                            <Grid item xs={12}>
                                                <Typography variant="body2" style={{ marginTop: '10px' }}>読み取りエリア (%):</Typography>
                                            </Grid>
                                            <Grid item xs={3}>
                                                <TextField
                                                    label="Top"
                                                    type="number"
                                                    inputProps={{ min: 0, max: 100 }}
                                                    fullWidth
                                                    value={parseInt(inputStreamOptions.area.top)}
                                                    onChange={(e) => {
                                                        const value = Math.min(Math.max(parseInt(e.target.value) || 0, 0), 100);
                                                        setInputStreamOptions(prev => ({
                                                            ...prev,
                                                            area: {
                                                                ...prev.area,
                                                                top: `${value}%`
                                                            }
                                                        }));
                                                    }}
                                                />
                                            </Grid>
                                            <Grid item xs={3}>
                                                <TextField
                                                    label="Bottom"
                                                    type="number"
                                                    inputProps={{ min: 0, max: 100 }}
                                                    fullWidth
                                                    value={parseInt(inputStreamOptions.area.bottom)}
                                                    onChange={(e) => {
                                                        const value = Math.min(Math.max(parseInt(e.target.value) || 0, 0), 100);
                                                        setInputStreamOptions(prev => ({
                                                            ...prev,
                                                            area: {
                                                                ...prev.area,
                                                                bottom: `${value}%`
                                                            }
                                                        }));
                                                    }}
                                                />
                                            </Grid>
                                            <Grid item xs={3}>
                                                <TextField
                                                    label="Left"
                                                    type="number"
                                                    inputProps={{ min: 0, max: 100 }}
                                                    fullWidth
                                                    value={parseInt(inputStreamOptions.area.left)}
                                                    onChange={(e) => {
                                                        const value = Math.min(Math.max(parseInt(e.target.value) || 0, 0), 100);
                                                        setInputStreamOptions(prev => ({
                                                            ...prev,
                                                            area: {
                                                                ...prev.area,
                                                                left: `${value}%`
                                                            }
                                                        }));
                                                    }}
                                                />
                                            </Grid>
                                            <Grid item xs={3}>
                                                <TextField
                                                    label="Right"
                                                    type="number"
                                                    inputProps={{ min: 0, max: 100 }}
                                                    fullWidth
                                                    value={parseInt(inputStreamOptions.area.right)}
                                                    onChange={(e) => {
                                                        const value = Math.min(Math.max(parseInt(e.target.value) || 0, 0), 100);
                                                        setInputStreamOptions(prev => ({
                                                            ...prev,
                                                            area: {
                                                                ...prev.area,
                                                                right: `${value}%`
                                                            }
                                                        }));
                                                    }}
                                                />
                                            </Grid>
                                        </Grid>
                                    </Grid>

                                    {/* Decoder Options */}
                                    <Grid item xs={12} md={6}>
                                        <Typography variant="subtitle1">Decoder Options</Typography>
                                        <Grid container spacing={2}>
                                            <Grid item xs={12}>
                                                <FormControl fullWidth>
                                                    <InputLabel id="readers-label">読み取りフォーマット</InputLabel>
                                                    <Select
                                                        labelId="readers-label"
                                                        id="readers-select"
                                                        multiple
                                                        value={decoderOptions.readers}
                                                        onChange={(e) => setDecoderOptions(prev => ({
                                                            ...prev,
                                                            readers: e.target.value
                                                        }))}
                                                        input={<OutlinedInput label="読み取りフォーマット" />}
                                                        renderValue={(selected) => selected.map(val => {
                                                            switch(val) {
                                                                case 'code_128_reader': return 'Code 128';
                                                                case 'ean_reader': return 'EAN-13';
                                                                case 'ean_8_reader': return 'EAN-8';
                                                                case 'upc_reader': return 'UPC-A';
                                                                case 'code_39_reader': return 'Code 39';
                                                                case 'codabar_reader': return 'Codabar';
                                                                case 'interleaved_2of5_reader': return 'Interleaved 2 of 5';
                                                                default: return val;
                                                            }
                                                        }).join(', ')}
                                                    >
                                                        {[
                                                            { label: 'Code 128', value: 'code_128_reader' },
                                                            { label: 'EAN-13', value: 'ean_reader' },
                                                            { label: 'EAN-8', value: 'ean_8_reader' },
                                                            { label: 'UPC-A', value: 'upc_reader' },
                                                            { label: 'Code 39', value: 'code_39_reader' },
                                                            { label: 'Codabar', value: 'codabar_reader' },
                                                            { label: 'Interleaved 2 of 5', value: 'interleaved_2of5_reader' },
                                                        ].map((option) => (
                                                            <MenuItem key={option.value} value={option.value}>
                                                                <Checkbox checked={decoderOptions.readers.indexOf(option.value) > -1} />
                                                                <ListItemText primary={option.label} />
                                                            </MenuItem>
                                                        ))}
                                                    </Select>
                                                </FormControl>
                                            </Grid>
                                            <Grid item xs={12}>
                                                <FormControl fullWidth>
                                                    <InputLabel id="patch-size-label">パッチサイズ</InputLabel>
                                                    <Select
                                                        labelId="patch-size-label"
                                                        id="patch-size-select"
                                                        value={decoderOptions.patchSize}
                                                        label="パッチサイズ"
                                                        onChange={(e) => setDecoderOptions(prev => ({
                                                            ...prev,
                                                            patchSize: e.target.value
                                                        }))}
                                                    >
                                                        <MenuItem value="small">小</MenuItem>
                                                        <MenuItem value="medium">中</MenuItem>
                                                        <MenuItem value="large">大</MenuItem>
                                                    </Select>
                                                </FormControl>
                                            </Grid>
                                            <Grid item xs={6}>
                                                <Grid container alignItems="center" spacing={1}>
                                                    <Grid item>
                                                        <Typography variant="body2">Half Sample</Typography>
                                                    </Grid>
                                                    <Grid item>
                                                        <Switch
                                                            checked={decoderOptions.halfSample}
                                                            onChange={(e) => setDecoderOptions(prev => ({
                                                                ...prev,
                                                                halfSample: e.target.checked
                                                            }))}
                                                            id="half-sample-switch"
                                                        />
                                                    </Grid>
                                                </Grid>
                                            </Grid>
                                            <Grid item xs={6}>
                                                <Grid container alignItems="center" spacing={1}>
                                                    <Grid item>
                                                        <Typography variant="body2">複数読み取り</Typography>
                                                    </Grid>
                                                    <Grid item>
                                                        <Switch
                                                            checked={decoderOptions.multiple}
                                                            onChange={(e) => setDecoderOptions(prev => ({
                                                                ...prev,
                                                                multiple: e.target.checked
                                                            }))}
                                                            id="multiple-switch"
                                                        />
                                                    </Grid>
                                                </Grid>
                                            </Grid>
                                            <Grid item xs={12}>
                                                <Grid container alignItems="center" spacing={1}>
                                                    <Grid item>
                                                        <Typography variant="body2">自動位置検出</Typography>
                                                    </Grid>
                                                    <Grid item>
                                                        <Switch
                                                            checked={decoderOptions.locate}
                                                            onChange={(e) => setDecoderOptions(prev => ({
                                                                ...prev,
                                                                locate: e.target.checked
                                                            }))}
                                                            id="locate-switch"
                                                        />
                                                    </Grid>
                                                </Grid>
                                            </Grid>
                                        </Grid>
                                    </Grid>
                                    {/* その他のオプション */}
                                    <Grid item xs={12} md={6}>
                                        <Typography variant="subtitle1">その他のオプション</Typography>
                                        <Grid container spacing={1}>
                                            <Grid item xs={6}>
                                                <TextField
                                                    label="ワーカーの数"
                                                    type="number"
                                                    fullWidth
                                                    value={otherOptions.numOfWorkers}
                                                    onChange={(e) => setOtherOptions(prev => ({
                                                        ...prev,
                                                        numOfWorkers: parseInt(e.target.value) || 4
                                                    }))}
                                                />
                                            </Grid>
                                            <Grid item xs={6}>
                                                <TextField
                                                    label="キャプチャ頻度 (フレーム/秒)"
                                                    type="number"
                                                    fullWidth
                                                    value={otherOptions.frequency}
                                                    onChange={(e) => setOtherOptions(prev => ({
                                                        ...prev,
                                                        frequency: parseInt(e.target.value) || 10
                                                    }))}
                                                />
                                            </Grid>
                                        </Grid>
                                    </Grid>
                                </Grid>

                                {/* 設定を適用するボタン */}
                                <Grid container justifyContent="flex-end" spacing={2}>
                                    <Grid item xs={12} sm={6} md={3}>
                                        <Button variant="contained" color="primary" onClick={applyAdvancedSettings} fullWidth id="apply_settings_button">
                                            設定を適用
                                        </Button>
                                    </Grid>
                                </Grid>
                            </div>
                        </Grid>
                    </Container>
                </Modal>
            );

            // 読み取り結果モーダル
            const ResultModal = () => (
                <Modal
                    open={resultModalOpen}
                    onClose={handleResultModal}
                    aria-labelledby="result-modal-title"
                >
                    <Container className="modal-content">
                        <Typography variant="h6" id="result-modal-title">読み取り履歴</Typography>
                        <Grid container spacing={2}>
                            <Grid item xs={12}>
                                <FormControl component="fieldset">
                                    <Typography variant="body2">ダウンロード形式</Typography>
                                    <RadioGroup
                                        value={downloadType}
                                        onChange={(e) => setDownloadType(e.target.value)}
                                    >
                                        <FormControlLabel 
                                            value="text" 
                                            control={<Radio />} 
                                            label="テキストのみ" 
                                        />
                                        <FormControlLabel 
                                            value="full" 
                                            control={<Radio />} 
                                            label="画像付き" 
                                        />
                                    </RadioGroup>
                                </FormControl>
                            </Grid>
                            <Grid item xs={12}>
                                <Button 
                                    variant="contained" 
                                    color="primary" 
                                    onClick={downloadHistory}
                                    fullWidth
                                >
                                    履歴をダウンロード
                                </Button>
                            </Grid>
                            <Grid item xs={12}>
                                <div style={{maxHeight: '50vh', overflow: 'auto'}}>
                                    {history.map((item, index) => (
                                        <Box key={index} mb={2} p={1} border={1} borderColor="grey.300" borderRadius={1}>
                                            <Typography variant="body1">
                                                Code: {item.code}
                                            </Typography>
                                            <Typography variant="body2" color="textSecondary">
                                                Timestamp: {item.timestamp}
                                            </Typography>
                                            {item.image && (
                                                <img 
                                                    src={item.image} 
                                                    alt={`Scan ${index}`} 
                                                    style={{maxWidth: '100%', marginTop: '8px'}}
                                                />
                                            )}
                                        </Box>
                                    ))}
                                </div>
                            </Grid>
                        </Grid>
                    </Container>
                </Modal>
            );

            return (
                <ThemeProvider theme={defaultTheme}>
                    <Box sx={{ minHeight: '100vh', display: 'flex', flexDirection: 'column' }}>
                        <AppBarComponent />
                        <Container className="main-content" maxWidth="lg">
                            <Grid container spacing={2}>
                                {/* スキャナーエリア */}
                                <Grid item xs={12}>
                                    <Paper elevation={3}>
                                        <div id="my_quagga" ref={quaggaRef} onClick={toggleScanner}></div>
                                        <canvas ref={captureCanvasRef} width="640" height="480" style={{ display: 'none' }}></canvas>
                                    </Paper>
                                </Grid>

                                {/* 認識結果 */}
                                <Grid item xs={12}>
                                    <Paper 
                                        elevation={1} 
                                        sx={{ p: 2 }} 
                                        onClick={handleResultModal}
                                        style={{ cursor: 'pointer' }}
                                    >
                                        <Typography variant="h6" gutterBottom>
                                            読数: {totalScans} 結果: {result}
                                        </Typography>
                                        {errorMessage && (
                                            <Alert severity="error">{errorMessage}</Alert>
                                        )}
                                    </Paper>
                                </Grid>

                                {/* コントロールパネル */}
                                <Grid item xs={12}>
                                    <Paper elevation={1} sx={{ p: 2 }}>
                                        <Grid container spacing={2}>
                                            <Grid item xs={12}>
                                                <Button
                                                    variant="contained"
                                                    color={isScanning ? "error" : "primary"}
                                                    onClick={toggleScanner}
                                                    fullWidth
                                                    startIcon={<Icon>
                                                        {isScanning ? 'stop' : 'play_arrow'}
                                                    </Icon>}
                                                >
                                                    スキャン{isScanning ? '停止' : '開始'}
                                                </Button>
                                            </Grid>
                                            <Grid item xs={12} sm={4}>
                                                <FormControlLabel
                                                    control={
                                                        <Switch
                                                            checked={singleMode}
                                                            onChange={handleToggle}
                                                        />
                                                    }
                                                    label={singleMode ? '単スキャン' : '連スキャン'}
                                                />
                                            </Grid>
                                            <Grid item xs={6} sm={4}>
                                                <Button
                                                    variant="outlined"
                                                    onClick={switchCamera}
                                                    fullWidth
                                                    startIcon={<Icon>flip_camera_ios</Icon>}
                                                >
                                                    {cameraFacingMode === "environment" ? "背面" : "前面"}
                                                </Button>
                                            </Grid>
                                            <Grid item xs={6} sm={4}>
                                                <Button
                                                    variant="outlined"
                                                    onClick={toggleTorch}
                                                    fullWidth
                                                    startIcon={<Icon>
                                                        {isTorchOn ? 'flash_off' : 'flash_on'}
                                                    </Icon>}
                                                >
                                                    ライト
                                                </Button>
                                            </Grid>
                                        </Grid>
                                    </Paper>
                                </Grid>

                                {/* 履歴セクション */}
                                <Grid item xs={12}>
                                    <Paper elevation={1} sx={{ p: 2 }}>
                                        <Box display="flex" justifyContent="space-between" alignItems="center" mb={2}>
                                            <Typography variant="h6">履歴</Typography>
                                            <Button
                                                variant="outlined"
                                                onClick={resetHistory}
                                                startIcon={<Icon>delete</Icon>}
                                            >
                                                クリア
                                            </Button>
                                        </Box>
                                        <List dense>
                                            {history.slice(-5).map((item, index) => (
                                                <ListItem key={index}>
                                                    <ListItemIcon>
                                                        <Icon>barcode</Icon>
                                                    </ListItemIcon>
                                                    <ListItemText
                                                        primary={item.code}
                                                        secondary={item.timestamp}
                                                    />
                                                </ListItem>
                                            ))}
                                        </List>
                                        {history.length > 5 && (
                                            <Button
                                                fullWidth
                                                onClick={handleHistoryClick}
                                                variant="text"
                                            >
                                                全ての履歴を表示
                                            </Button>
                                        )}
                                    </Paper>
                                </Grid>

                                {/* 詳細設定 */}
                                {showAdvancedSettings && (
                                    <Grid item>
                                        <div className="advanced-settings">
                                            <Typography variant="h6">設定</Typography>
                                            {/* スキャンボックスとスキャンラインの表示切替 */}
                                            <Grid container spacing={1}>
                                                <Grid item xs={6}>
                                                    <Typography variant="body2">スキャンボックス表示</Typography>
                                                    <Switch
                                                        checked={showBox}
                                                        onChange={(e) => {
                                                            setShowBox(e.target.checked);
                                                        }}
                                                        id="box-toggle-switch"
                                                    />
                                                </Grid>
                                                <Grid item xs={6}>
                                                    <Typography variant="body2">スキャンライン表示</Typography>
                                                    <Switch
                                                        checked={showLine}
                                                        onChange={(e) => setShowLine(e.target.checked)}
                                                        id="line-toggle-switch"
                                                    />
                                                </Grid>
                                            </Grid>
                                            <Grid container spacing={1}>
                                                {/* 連続検出回数の設定 */}
                                                <Grid item xs={12} md={12}>
                                                    <Typography variant="subtitle1">連続検出回数</Typography>
                                                    <Grid container spacing={1}>
                                                        <Grid item xs={12}>
                                                            <TextField
                                                                label="必要な連続検出回数"
                                                                type="number"
                                                                fullWidth
                                                                value={requiredConsecutiveDetections}
                                                                onChange={(e) => {
                                                                    const value = parseInt(e.target.value);
                                                                    if (value > 0) {
                                                                        setRequiredConsecutiveDetections(value);
                                                                    }
                                                                }}
                                                                inputProps={{ min: 1 }}
                                                            />
                                                        </Grid>
                                                    </Grid>
                                                </Grid>
                                                {/* InputStream Options */}
                                                <Grid item xs={12} md={12}>
                                                    <Typography variant="subtitle1">Input Stream Options</Typography>
                                                    <Grid container spacing={2}>
                                                        <Grid item xs={12}>
                                                            <FormControl fullWidth>
                                                                <InputLabel id="facing-mode-label">カメラ方向</InputLabel>
                                                                <Select
                                                                    labelId="facing-mode-label"
                                                                    id="facing-mode-select"
                                                                    value={cameraFacingMode}
                                                                    label="カメラ方向"
                                                                    onChange={(e) => {
                                                                        const newFacingMode = e.target.value;
                                                                        setCameraFacingMode(newFacingMode);
                                                                        setInputStreamOptions(prev => ({
                                                                            ...prev,
                                                                            constraints: {
                                                                                ...prev.constraints,
                                                                                facingMode: newFacingMode
                                                                            }
                                                                        }));
                                                                    }}
                                                                >
                                                                    <MenuItem value="environment">背面カメラ</MenuItem>
                                                                    <MenuItem value="user">前面カメラ</MenuItem>
                                                                </Select>
                                                            </FormControl>
                                                        </Grid>
                                                        <Grid item xs={6}>
                                                            <TextField
                                                                label="幅 (px)"
                                                                type="number"
                                                                fullWidth
                                                                value={inputStreamOptions.constraints.width}
                                                                onChange={(e) => setInputStreamOptions(prev => ({
                                                                    ...prev,
                                                                    constraints: {
                                                                        ...prev.constraints,
                                                                        width: parseInt(e.target.value) || 640
                                                                    }
                                                                }))}
                                                            />
                                                        </Grid>
                                                        <Grid item xs={6}>
                                                            <TextField
                                                                label="高さ (px)"
                                                                type="number"
                                                                fullWidth
                                                                value={inputStreamOptions.constraints.height}
                                                                onChange={(e) => setInputStreamOptions(prev => ({
                                                                    ...prev,
                                                                    constraints: {
                                                                        height: parseInt(e.target.value) || 480
                                                                    }
                                                                }))}
                                                            />
                                                        </Grid>
                                                        <Grid item xs={12}>
                                                            <Typography variant="body2" style={{ marginTop: '10px' }}>読み取りエリア (%):</Typography>
                                                        </Grid>
                                                        <Grid item xs={3}>
                                                            <TextField
                                                                label="Top"
                                                                type="number"
                                                                inputProps={{ min: 0, max: 100 }}
                                                                fullWidth
                                                                value={parseInt(inputStreamOptions.area.top)}
                                                                onChange={(e) => {
                                                                    const value = Math.min(Math.max(parseInt(e.target.value) || 0, 0), 100);
                                                                    setInputStreamOptions(prev => ({
                                                                        ...prev,
                                                                        area: {
                                                                            ...prev.area,
                                                                            top: `${value}%`
                                                                        }
                                                                    }));
                                                                }}
                                                            />
                                                        </Grid>
                                                        <Grid item xs={3}>
                                                            <TextField
                                                                label="Bottom"
                                                                type="number"
                                                                inputProps={{ min: 0, max: 100 }}
                                                                fullWidth
                                                                value={parseInt(inputStreamOptions.area.bottom)}
                                                                onChange={(e) => {
                                                                    const value = Math.min(Math.max(parseInt(e.target.value) || 0, 0), 100);
                                                                    setInputStreamOptions(prev => ({
                                                                        ...prev,
                                                                        area: {
                                                                            ...prev.area,
                                                                            bottom: `${value}%`
                                                                        }
                                                                    }));
                                                                }}
                                                            />
                                                        </Grid>
                                                        <Grid item xs={3}>
                                                            <TextField
                                                                label="Left"
                                                                type="number"
                                                                inputProps={{ min: 0, max: 100 }}
                                                                fullWidth
                                                                value={parseInt(inputStreamOptions.area.left)}
                                                                onChange={(e) => {
                                                                    const value = Math.min(Math.max(parseInt(e.target.value) || 0, 0), 100);
                                                                    setInputStreamOptions(prev => ({
                                                                        ...prev,
                                                                        area: {
                                                                            ...prev.area,
                                                                            left: `${value}%`
                                                                        }
                                                                    }));
                                                                }}
                                                            />
                                                        </Grid>
                                                        <Grid item xs={3}>
                                                            <TextField
                                                                label="Right"
                                                                type="number"
                                                                inputProps={{ min: 0, max: 100 }}
                                                                fullWidth
                                                                value={parseInt(inputStreamOptions.area.right)}
                                                                onChange={(e) => {
                                                                    const value = Math.min(Math.max(parseInt(e.target.value) || 0, 0), 100);
                                                                    setInputStreamOptions(prev => ({
                                                                        ...prev,
                                                                        area: {
                                                                            ...prev.area,
                                                                            right: `${value}%`
                                                                        }
                                                                    }));
                                                                }}
                                                            />
                                                        </Grid>
                                                    </Grid>
                                                </Grid>

                                                {/* Decoder Options */}
                                                <Grid item xs={12} md={6}>
                                                    <Typography variant="subtitle1">Decoder Options</Typography>
                                                    <Grid container spacing={2}>
                                                        <Grid item xs={12}>
                                                            <FormControl fullWidth>
                                                                <InputLabel id="readers-label">読み取りフォーマット</InputLabel>
                                                                <Select
                                                                    labelId="readers-label"
                                                                    id="readers-select"
                                                                    multiple
                                                                    value={decoderOptions.readers}
                                                                    onChange={(e) => setDecoderOptions(prev => ({
                                                                        ...prev,
                                                                        readers: e.target.value
                                                                    }))}
                                                                    input={<OutlinedInput label="読み取りフォーマット" />}
                                                                    renderValue={(selected) => selected.map(val => {
                                                                        switch(val) {
                                                                            case 'code_128_reader': return 'Code 128';
                                                                            case 'ean_reader': return 'EAN-13';
                                                                            case 'ean_8_reader': return 'EAN-8';
                                                                            case 'upc_reader': return 'UPC-A';
                                                                            case 'code_39_reader': return 'Code 39';
                                                                            case 'codabar_reader': return 'Codabar';
                                                                            case 'interleaved_2of5_reader': return 'Interleaved 2 of 5';
                                                                            default: return val;
                                                                        }
                                                                    }).join(', ')}
                                                                >
                                                                    {[
                                                                        { label: 'Code 128', value: 'code_128_reader' },
                                                                        { label: 'EAN-13', value: 'ean_reader' },
                                                                        { label: 'EAN-8', value: 'ean_8_reader' },
                                                                        { label: 'UPC-A', value: 'upc_reader' },
                                                                        { label: 'Code 39', value: 'code_39_reader' },
                                                                        { label: 'Codabar', value: 'codabar_reader' },
                                                                        { label: 'Interleaved 2 of 5', value: 'interleaved_2of5_reader' },
                                                                    ].map((option) => (
                                                                        <MenuItem key={option.value} value={option.value}>
                                                                            <Checkbox checked={decoderOptions.readers.indexOf(option.value) > -1} />
                                                                            <ListItemText primary={option.label} />
                                                                        </MenuItem>
                                                                    ))}
                                                                </Select>
                                                            </FormControl>
                                                        </Grid>
                                                        <Grid item xs={12}>
                                                            <FormControl fullWidth>
                                                                <InputLabel id="patch-size-label">パッチサイズ</InputLabel>
                                                                <Select
                                                                    labelId="patch-size-label"
                                                                    id="patch-size-select"
                                                                    value={decoderOptions.patchSize}
                                                                    label="パッチサイズ"
                                                                    onChange={(e) => setDecoderOptions(prev => ({
                                                                        ...prev,
                                                                        patchSize: e.target.value
                                                                    }))}
                                                                >
                                                                    <MenuItem value="small">小</MenuItem>
                                                                    <MenuItem value="medium">中</MenuItem>
                                                                    <MenuItem value="large">大</MenuItem>
                                                                </Select>
                                                            </FormControl>
                                                        </Grid>
                                                        <Grid item xs={6}>
                                                            <Grid container alignItems="center" spacing={1}>
                                                                <Grid item>
                                                                    <Typography variant="body2">Half Sample</Typography>
                                                                </Grid>
                                                                <Grid item>
                                                                    <Switch
                                                                        checked={decoderOptions.halfSample}
                                                                        onChange={(e) => setDecoderOptions(prev => ({
                                                                            ...prev,
                                                                            halfSample: e.target.checked
                                                                        }))}
                                                                        id="half-sample-switch"
                                                                    />
                                                                </Grid>
                                                            </Grid>
                                                        </Grid>
                                                        <Grid item xs={6}>
                                                            <Grid container alignItems="center" spacing={1}>
                                                                <Grid item>
                                                                    <Typography variant="body2">複数読み取り</Typography>
                                                                </Grid>
                                                                <Grid item>
                                                                    <Switch
                                                                        checked={decoderOptions.multiple}
                                                                        onChange={(e) => setDecoderOptions(prev => ({
                                                                            ...prev,
                                                                            multiple: e.target.checked
                                                                        }))}
                                                                        id="multiple-switch"
                                                                    />
                                                                </Grid>
                                                            </Grid>
                                                        </Grid>
                                                        <Grid item xs={12}>
                                                            <Grid container alignItems="center" spacing={1}>
                                                                <Grid item>
                                                                    <Typography variant="body2">自動位置検出</Typography>
                                                                </Grid>
                                                                <Grid item>
                                                                    <Switch
                                                                        checked={decoderOptions.locate}
                                                                        onChange={(e) => setDecoderOptions(prev => ({
                                                                            ...prev,
                                                                            locate: e.target.checked
                                                                        }))}
                                                                        id="locate-switch"
                                                                    />
                                                                </Grid>
                                                            </Grid>
                                                        </Grid>
                                                    </Grid>
                                                </Grid>
                                                {/* その他のオプション */}
                                                <Grid item xs={12} md={6}>
                                                    <Typography variant="subtitle1">その他のオプション</Typography>
                                                    <Grid container spacing={1}>
                                                        <Grid item xs={6}>
                                                            <TextField
                                                                label="ワーカーの数"
                                                                type="number"
                                                                fullWidth
                                                                value={otherOptions.numOfWorkers}
                                                                onChange={(e) => setOtherOptions(prev => ({
                                                                    ...prev,
                                                                    numOfWorkers: parseInt(e.target.value) || 4
                                                                }))}
                                                            />
                                                        </Grid>
                                                        <Grid item xs={6}>
                                                            <TextField
                                                                label="キャプチャ頻度 (フレーム/秒)"
                                                                type="number"
                                                                fullWidth
                                                                value={otherOptions.frequency}
                                                                onChange={(e) => setOtherOptions(prev => ({
                                                                    ...prev,
                                                                    frequency: parseInt(e.target.value) || 10
                                                                }))}
                                                            />
                                                        </Grid>
                                                    </Grid>
                                                </Grid>
                                            </Grid>

                                            {/* 設定を適用するボタン */}
                                            <Grid container justifyContent="flex-end" spacing={2}>
                                                <Grid item xs={12} sm={6} md={3}>
                                                    <Button variant="contained" color="primary" onClick={applyAdvancedSettings} fullWidth id="apply_settings_button">
                                                        設定を適用
                                                    </Button>
                                                </Grid>
                                            </Grid>
                                        </div>
                                    </Grid>
                                )}

                                {/* 履歴表示 */}
                                <Grid item>
                                    <div id="history" onClick={handleHistoryClick}>
                                        <Typography variant="h6" id="history_label">履歴</Typography>
                                        <ul>
                                            {history.map((item, index) => (
                                                <li key={index} id={`history_item_${index}`}>
                                                    {index + 1}: {item.code} (時刻: {item.timestamp})
                                                </li>
                                            ))}
                                        </ul>
                                    </div>
                                </Grid>

                                {/* 履歴検索モーダル */}
                                <Modal
                                    open={modalOpen}
                                    onClose={handleCloseModal}
                                    aria-labelledby="modal-title"
                                    aria-describedby="modal-description"
                                    id="history_modal"
                                >
                                    <Container className="modal-content">
                                        <Typography id="modal-title" variant="h6">履歴検索</Typography>
                                        <Grid container spacing={2}>
                                            <Grid item xs={12}>
                                                <TextField 
                                                    label="検索" 
                                                    variant="outlined" 
                                                    fullWidth 
                                                    value={searchTerm} 
                                                    onChange={e => setSearchTerm(e.target.value)} 
                                                    id="search_box"
                                                />
                                            </Grid>
                                            <Grid item xs={12}>
                                                <Button onClick={handleSearch} variant="contained" color="primary" fullWidth id="search_button">
                                                    検索
                                                </Button>
                                            </Grid>
                                            <Grid item xs={12}>
                                                <div id="modal-history">
                                                    <ul style={{ paddingLeft: '0', textAlign: 'left' }}>
                                                        {(searchResults.length > 0 ? searchResults : modalHistory).map((item, index) => (
                                                            <li key={index} id={`modal_history_item_${index}`}>
                                                                {index + 1}: {item.code} (時刻: {item.timestamp})
                                                            </li>
                                                        ))}
                                                    </ul>
                                                </div>
                                            </Grid>
                                            <Grid item xs={12}>
                                                <Button onClick={handleCloseModal} variant="contained" color="primary" fullWidth id="close_button">
                                                    閉じる
                                                </Button>
                                            </Grid>
                                        </Grid>
                                    </Container>
                                </Modal>

                                {/* 単発モードでのバーコード認識結果モーダル */}
                                <Modal
                                    open={singleScanModalOpen}
                                    onClose={handleSingleScanClose}
                                    aria-labelledby="single-scan-modal-title"
                                    aria-describedby="single-scan-modal-description"
                                    id="single_scan_modal"
                                >
                                    <Container className="modal-content">
                                        <Typography id="single-scan-modal-title" variant="h6">バーコード認識結果</Typography>
                                        <Typography>{result}</Typography>
                                        <Grid container justifyContent="flex-end" spacing={1} style={{ marginTop: '20px' }}>
                                            <Grid item xs={6} sm={4} md={3}>
                                                <Button onClick={handleSingleScanClose} variant="contained" color="primary" fullWidth>
                                                    再スキャン
                                                </Button>
                                            </Grid>
                                            <Grid item xs={6} sm={4} md={3}>
                                                <Button onClick={handleSingleScanClose} variant="contained" color="inherit" fullWidth>
                                                    閉じる
                                                </Button>
                                            </Grid>
                                        </Grid>
                                    </Container>
                                </Modal>
                                <SettingsModal />
                                <ResultModal />
                            </Grid>
                        </Container>
                        <Footer />
                    </Box>
                </ThemeProvider>
            );
            }

            const container = document.getElementById('root');
            const root = ReactDOM.createRoot(container);
            root.render(<BarcodeScanner />);
    </script>
</body>
</html>
