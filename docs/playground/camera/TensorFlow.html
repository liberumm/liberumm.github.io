<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Camera App with React, Material-UI v4, and TensorFlow.js</title>
    
    <!-- ReactとReactDOMをCDNから読み込む -->
    <script src="https://unpkg.com/react@16/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js" crossorigin></script>
    
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone@7/babel.min.js"></script>

    <!-- MUI v4のCSS -->
    <link rel="stylesheet" href="https://unpkg.com/@material-ui/core@4.12.4/umd/material-ui.min.css">

    <!-- MUI v4のJS -->
    <script src="https://unpkg.com/@material-ui/core@4.12.4/umd/material-ui.development.js" crossorigin></script>
    
    <!-- TensorFlow.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    
    <style>
        body {
            font-family: Roboto, sans-serif;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            background-color: #f5f5f5;
        }
        #root {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            padding: 20px;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;
        const { Button, Container, Typography } = MaterialUI;

        function CameraApp() {
            const videoRef = useRef(null);
            const canvasRef = useRef(null);
            const [isCameraOn, setCameraOn] = useState(false);
            const [model, setModel] = useState(null);
            const [predictions, setPredictions] = useState([]);

            // カメラの起動/停止の管理
            useEffect(() => {
                if (isCameraOn) {
                    startCamera();
                } else {
                    stopCamera();
                }
            }, [isCameraOn]);

            // TensorFlow.jsのモデルをロード
            useEffect(() => {
                async function loadModel() {
                    try {
                        const model = await tf.loadLayersModel('https://storage.googleapis.com/tfjs-models/tfjs/mnist/model.json');
                        setModel(model);
                        console.log("モデルのロードに成功しました");
                    } catch (error) {
                        console.error("モデルのロードに失敗しました: ", error);
                    }
                }
                loadModel();
            }, []);

            const startCamera = () => {
                navigator.mediaDevices.getUserMedia({ video: true })
                    .then(stream => {
                        videoRef.current.srcObject = stream;
                    })
                    .catch(err => {
                        console.error("カメラへのアクセスに失敗しました: ", err);
                    });
            };

            const stopCamera = () => {
                if (videoRef.current && videoRef.current.srcObject) {
                    const stream = videoRef.current.srcObject;
                    const tracks = stream.getTracks();

                    tracks.forEach(track => track.stop());
                    videoRef.current.srcObject = null;
                }
            };

            // フレームのキャプチャと予測実行
            const captureFrameAndPredict = async () => {
                if (!model) {
                    alert("モデルがロードされていません。しばらく待ってから再試行してください。");
                    return;
                }
                const canvas = canvasRef.current;
                const video = videoRef.current;
                const context = canvas.getContext('2d');
                
                // Canvasにビデオフレームを描画
                context.drawImage(video, 0, 0, 28, 28);

                // フレームをTensorとして取得
                const imageData = context.getImageData(0, 0, 28, 28);
                let imgTensor = tf.browser.fromPixels(imageData, 1);
                imgTensor = imgTensor.expandDims(0).toFloat().div(tf.scalar(255));

                // 予測を実行
                const prediction = model.predict(imgTensor);
                const predictedValue = prediction.argMax(1).dataSync()[0];
                setPredictions(prev => [...prev, predictedValue]);
            };

            return (
                <Container maxWidth="sm">
                    <Typography variant="h4" gutterBottom>
                        Camera and Digit Recognition App
                    </Typography>
                    <video ref={videoRef} autoPlay style={{ width: '100%', maxWidth: '500px', borderRadius: '8px' }} />
                    <canvas ref={canvasRef} style={{ display: 'none' }} width="28" height="28"></canvas>
                    <div style={{ marginTop: '20px', display: 'flex', justifyContent: 'space-between' }}>
                        <Button variant="contained" color="primary" onClick={() => setCameraOn(true)} disabled={isCameraOn}>
                            Start Camera
                        </Button>
                        <Button variant="contained" color="secondary" onClick={() => setCameraOn(false)} disabled={!isCameraOn}>
                            Stop Camera
                        </Button>
                        <Button variant="contained" color="default" onClick={captureFrameAndPredict}>
                            Capture Frame and Predict
                        </Button>
                    </div>
                    <div style={{ marginTop: '20px' }}>
                        <Typography variant="h6">Predicted Values:</Typography>
                        {predictions.length === 0 && <Typography>No predictions yet.</Typography>}
                        {predictions.map((prediction, index) => (
                            <Typography key={index}>Prediction {index + 1}: {prediction}</Typography>
                        ))}
                    </div>
                </Container>
            );
        }

        ReactDOM.render(<CameraApp />, document.getElementById('root'));
    </script>
</body>
</html>
