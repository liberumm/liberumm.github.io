<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>CSVæ“ä½œãƒ„ãƒ¼ãƒ«</title>
  <!-- React and ReactDOM -->
  <script src="https://cdn.jsdelivr.net/npm/react@18/umd/react.production.min.js"  crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/react-dom@18/umd/react-dom.production.min.js"  crossorigin="anonymous"></script>
  <!-- MUI (Material-UI) v5 -->
  <script src="https://cdn.jsdelivr.net/npm/@mui/material@5.11.15/umd/material-ui.production.min.js"  crossorigin="anonymous"></script>
  <!-- Babel for JSX -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.21.0/babel.min.js"  crossorigin="anonymous"></script>
  <!-- Encoding.js for Shift_JIS support -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/encoding-japanese/1.0.30/encoding.min.js"  crossorigin="anonymous"></script>
  <!-- Emotion ãƒ©ã‚¤ãƒ–ãƒ©ãƒª -->
  <script src="https://cdn.jsdelivr.net/npm/@emotion/react@11.11.0/dist/emotion-react.umd.min.js"  crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@emotion/styled@11.11.0/dist/emotion-styled.umd.min.js"  crossorigin="anonymous"></script>
  <style>
    .upload-area {
      border: 2px dashed #ccc;
      padding: 40px;
      text-align: center;
      color: #aaa;
      margin-top: 20px;
      cursor: pointer;
      transition: border-color 0.3s, background-color 0.3s, color 0.3s;
      position: relative;
    }
    .upload-area.drag-over {
      border-color: #007bff;
      background-color: #e9f5ff;
      color: #007bff;
    }
    body {
      margin: 0;
      padding: 0;
      font-family: Roboto, sans-serif;
    }
    .table-responsive {
      width: 100%;
      overflow-x: auto;
    }
    .no-wrap {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .header-input {
      width: 100%;
      box-sizing: border-box;
    }
    .editing-cell {
      background-color: #ffffcc;
    }
    .hidden-file-input {
      display: none;
    }
    .checkbox-cell {
      padding: 0;
      text-align: center;
      position: relative;
      white-space: nowrap;
    }
    .dragging {
      opacity: 0.5;
    }
    .header-actions {
      display: flex;
      gap: 5px;
      margin-top: 5px;
    }
    .resize-handle {
      position: absolute;
      top: 0;
      right: 0;
      width: 15px;
      height: 100%;
      cursor: col-resize;
      user-select: none;
      z-index: 1;
    }
    .header-content {
      position: relative;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
    }
    .header-row {
      background-color: #e0f7fa;
    }
    .original-header-row {
      background-color: #f0f0f0;
      font-style: italic;
    }
    .header-text {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel" data-type="module">
    const { useState, useEffect, useRef, useMemo, useCallback } = React;
    const {
      Container,
      Button,
      TextField,
      Table,
      TableBody,
      TableCell,
      TableContainer,
      TableHead,
      TableRow,
      Select,
      MenuItem,
      FormControl,
      InputLabel,
      Switch,
      FormControlLabel,
      Typography,
      TablePagination,
      TableSortLabel,
      Tooltip,
      IconButton,
      Autocomplete,
      Dialog,
      DialogActions,
      DialogContent,
      DialogContentText,
      DialogTitle,
      Checkbox,
      Snackbar,
      CircularProgress,
    } = MaterialUI;

    // ãƒ¦ãƒ‹ãƒ¼ã‚¯IDç”Ÿæˆã®ãŸã‚ã®é–¢æ•°
    const generateUUID = () => {
      // ç°¡æ˜“çš„ãªUUIDç”Ÿæˆ
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        const r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
      });
    };

    // Comparatoré–¢æ•°ã®å®šç¾©
    function descendingComparator(a, b, orderByIndex) {
      if (b.row[orderByIndex] < a.row[orderByIndex]) {
        return -1;
      }
      if (b.row[orderByIndex] > a.row[orderByIndex]) {
        return 1;
      }
      return 0;
    }

    function getComparator(order, orderByIndex) {
      return order === 'desc'
        ? (a, b) => descendingComparator(a, b, orderByIndex)
        : (a, b) => -descendingComparator(a, b, orderByIndex);
    }

    function stableSort(array, comparator) {
      const stabilizedThis = array.map((el, index) => [el, index]);
      stabilizedThis.sort((a, b) => {
        const cmp = comparator(a[0], b[0]);
        if (cmp !== 0) return cmp;
        return a[1] - b[1];
      });
      return stabilizedThis.map(el => el[0]);
    }

    // ãƒ˜ãƒƒãƒ€ãƒ¼ã¨ãƒ‡ãƒ¼ã‚¿ã®ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ãŠã‚ˆã³ã‚½ãƒ¼ãƒˆå‡¦ç†ã‚’è¡Œã†é–¢æ•°
    const getFilteredAndSortedData = (csvData, useHeader, searchQuery, order, orderBy, page, rowsPerPage) => {
      let data = useHeader ? csvData.slice(1) : csvData;
      // ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
      if (searchQuery.trim() !== '') {
        const lowerCaseQuery = searchQuery.toLowerCase();
        data = data.filter(item =>
          item.row.some(cell => cell.toString().toLowerCase().includes(lowerCaseQuery))
        );
      }

      const totalMatched = data.length; // ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°å¾Œã®ç·è¡Œæ•°

      // ã‚½ãƒ¼ãƒˆ
      if (orderBy !== '') {
        data = stableSort(data, getComparator(order, orderBy));
      }

      // ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³
      if (rowsPerPage > 0) {
        const start = page * rowsPerPage;
        const end = start + rowsPerPage;
        data = data.slice(start, end);
      }

      return { data, totalMatched };
    };

    // FileUploadã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆï¼ˆãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—ã¨ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠã‚’çµ±åˆï¼‰
    const FileUpload = React.memo(({ onFileUpload, isDragOver, setIsDragOver }) => {
      const fileInputRef = useRef(null);

      const handleDragOver = useCallback((e) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragOver(true);
      }, [setIsDragOver]);

      const handleDragLeave = useCallback((e) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragOver(false);
      }, [setIsDragOver]);

      const handleDrop = useCallback((e) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragOver(false);
        const files = e.dataTransfer.files;
        if (files && files.length > 0) {
          onFileUpload(files[0]);
        }
      }, [onFileUpload, setIsDragOver]);

      const handleClick = useCallback(() => {
        fileInputRef.current.click();
      }, []);

      const handleChange = useCallback((e) => {
        if (e.target.files && e.target.files.length > 0) {
          onFileUpload(e.target.files[0]);
        }
      }, [onFileUpload]);

      return (
        <div
          className={`upload-area ${isDragOver ? 'drag-over' : ''}`}
          onDragOver={handleDragOver}
          onDragLeave={handleDragLeave}
          onDrop={handleDrop}
          onClick={handleClick}
        >
          <Typography>
            CSVãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—ã™ã‚‹ã‹ã€ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„
          </Typography>
          <input
            type="file"
            accept=".csv"
            ref={fileInputRef}
            className="hidden-file-input"
            onChange={handleChange}
          />
        </div>
      );
    });

    // EncodingSelectorã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
    const EncodingSelector = React.memo(({ label, value, onChange }) => (
      <FormControl fullWidth margin="normal">
        <InputLabel id={`${label.toLowerCase()}-encoding-label`}>{label}ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰</InputLabel>
        <Select
          labelId={`${label.toLowerCase()}-encoding-label`}
          value={value}
          label={`${label}ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰`}
          onChange={onChange}
        >
          <MenuItem value="UTF-8">UTF-8</MenuItem>
          <MenuItem value="Shift_JIS">Shift_JIS</MenuItem>
        </Select>
      </FormControl>
    ));

    // HeaderToggleã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
    const HeaderToggle = React.memo(({ useHeader, onToggle }) => (
      <FormControlLabel
        control={
          <Switch
            checked={useHeader}
            onChange={onToggle}
            color="primary"
          />
        }
        label="1è¡Œç›®ã‚’ãƒ˜ãƒƒãƒ€ãƒ¼ã¨ã—ã¦ä½¿ç”¨"
        style={{ marginTop: '10px' }}
      />
    ));

    // SearchFieldã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
    const SearchField = React.memo(({ searchQuery, onSearchChange }) => (
      <FormControl fullWidth margin="normal">
        <TextField
          label="æ¤œç´¢"
          variant="outlined"
          value={searchQuery}
          onChange={onSearchChange}
          placeholder="ãƒ‡ãƒ¼ã‚¿ã‚’æ¤œç´¢"
        />
      </FormControl>
    ));

    // ActionButtonsã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆï¼ˆå‰Šé™¤ã¨è¿½åŠ ã®ãƒœã‚¿ãƒ³ã‚’è¿½åŠ ï¼‰
    const ActionButtons = React.memo(({
      onReset,
      onUndo,
      undoDisabled,
      onRedo,
      redoDisabled,
      onToggleEdit,
      isEditMode,
      onDeleteRows,
      onAddRow,
      deleteDisabled,
      addDisabled
    }) => (
      <div style={{ display: 'flex', gap: '10px', marginTop: '20px', flexWrap: 'wrap' }}>
        <Button variant="contained" color="error" onClick={onReset}>
          ãƒªã‚»ãƒƒãƒˆ
        </Button>
        <Button variant="outlined" onClick={onUndo} disabled={undoDisabled}>
          Undo
        </Button>
        <Button variant="outlined" onClick={onRedo} disabled={redoDisabled}>
          Redo
        </Button>
        <Button
          variant="outlined"
          onClick={onToggleEdit}
        >
          {isEditMode ? 'å‚ç…§ãƒ¢ãƒ¼ãƒ‰ã«åˆ‡æ›¿' : 'ç·¨é›†ãƒ¢ãƒ¼ãƒ‰ã«åˆ‡æ›¿'}
        </Button>
        <Button
          variant="outlined"
          color="secondary"
          onClick={onDeleteRows}
          disabled={deleteDisabled}
        >
          é¸æŠã—ãŸè¡Œã‚’å‰Šé™¤
        </Button>
        <Button
          variant="outlined"
          color="primary"
          onClick={onAddRow}
          disabled={addDisabled}
        >
          é¸æŠã—ãŸè¡Œã®ä¸‹ã«è¡Œã‚’è¿½åŠ 
        </Button>
      </div>
    ));

    // DownloadSectionã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
    const DownloadSection = React.memo(({ onDownloadClick, downloadDialogOpen, downloadFileName, setDownloadFileName, onDownloadConfirm, onDownloadCancel }) => (
      <React.Fragment>
        {/* CSVãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ */}
        <div style={{ display: 'flex', justifyContent: 'flex-start', gap: '10px', marginTop: '20px' }}>
          <Button
            variant="contained"
            color="primary"
            onClick={onDownloadClick}
          >
            CSVãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
          </Button>
        </div>

        {/* ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒ€ã‚¤ã‚¢ãƒ­ã‚° */}
        <Dialog open={downloadDialogOpen} onClose={onDownloadCancel}>
          <DialogTitle>CSVãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</DialogTitle>
          <DialogContent>
            <DialogContentText>
              ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«åã‚’æŒ‡å®šã—ã¦ãã ã•ã„ã€‚ãƒ•ã‚¡ã‚¤ãƒ«åã«ã¯ç¾åœ¨ã®æ—¥æ™‚ãŒè‡ªå‹•çš„ã«ä»˜åŠ ã•ã‚Œã¾ã™ã€‚
            </DialogContentText>
            <TextField
              autoFocus
              margin="dense"
              label="ãƒ•ã‚¡ã‚¤ãƒ«å"
              type="text"
              fullWidth
              variant="standard"
              value={downloadFileName}
              onChange={(e) => setDownloadFileName(e.target.value)}
            />
          </DialogContent>
          <DialogActions>
            <Button onClick={onDownloadCancel}>ã‚­ãƒ£ãƒ³ã‚»ãƒ«</Button>
            <Button onClick={onDownloadConfirm} color="primary">ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</Button>
          </DialogActions>
        </Dialog>
      </React.Fragment>
    ));

    // EditableTableCellã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®ä½œæˆï¼ˆãƒ¡ãƒ¢åŒ–æ¸ˆã¿ï¼‰
    const EditableTableCell = React.memo(({
      cell,
      rowId,
      cellIndex,
      isEditMode,
      editingCell,
      setEditingCell,
      handleCellChange,
      pushHistoryNow // è¿½åŠ : å±¥æ­´ãƒ—ãƒƒã‚·ãƒ¥é–¢æ•°ã‚’å—ã‘å–ã‚‹
    }) => {
      const isEditing = isEditMode && editingCell.rowId === rowId && editingCell.cellIndex === cellIndex;
      const [tempValue, setTempValue] = useState(cell);

      useEffect(() => {
        if (!isEditing) {
          setTempValue(cell);
        }
      }, [isEditing, cell]);

      const handleChange = useCallback((e) => {
        setTempValue(e.target.value);
      }, []);

      const handleBlur = useCallback(() => {
        if (tempValue !== cell) {
          handleCellChange(rowId, cellIndex, tempValue);
          pushHistoryNow(); // ç·¨é›†ç¢ºå®šæ™‚ã«å±¥æ­´ã‚’ãƒ—ãƒƒã‚·ãƒ¥
        }
        setEditingCell({ rowId: null, cellIndex: null });
      }, [tempValue, cell, handleCellChange, rowId, cellIndex, setEditingCell, pushHistoryNow]);

      const handleKeyDown = useCallback((e) => {
        if (e.key === 'Enter') {
          if (tempValue !== cell) {
            handleCellChange(rowId, cellIndex, tempValue);
            pushHistoryNow(); // ç·¨é›†ç¢ºå®šæ™‚ã«å±¥æ­´ã‚’ãƒ—ãƒƒã‚·ãƒ¥
          }
          setEditingCell({ rowId: null, cellIndex: null });
        } else if (e.key === 'Escape') {
          setTempValue(cell);
          setEditingCell({ rowId: null, cellIndex: null });
        }
      }, [tempValue, cell, handleCellChange, rowId, cellIndex, setEditingCell, pushHistoryNow]);

      return (
        <TableCell
          className={`no-wrap ${isEditing ? 'editing-cell' : ''}`}
          style={{}}
          onClick={() => {
            if (isEditMode) {
              setEditingCell({ rowId, cellIndex });
            }
          }}
        >
          {isEditing ? (
            <TextField
              value={tempValue}
              onChange={handleChange}
              variant="standard"
              autoFocus
              onBlur={handleBlur}
              onKeyDown={handleKeyDown}
              fullWidth
            />
          ) : (
            <span>{cell}</span>
          )}
        </TableCell>
      );
    });

    // CsvTableã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
    const CsvTable = React.memo(({
      csvData,
      modifiedHeaders,
      originalHeaders, // è¿½åŠ 
      columnWidths,
      handleHeaderChange,
      handleAddColumn,
      handleDeleteColumn,
      handleRequestSort,
      order,
      orderBy,
      handleCellChange,
      isEditMode,
      editingCell,
      setEditingCell,
      handleMouseDown,
      selectedColumns,
      setSelectedColumns,
      selectedRows,
      setSelectedRows,
      useHeader,
      onAddRowAt,
      onDeleteRowAt,
      firstColumnWidth,
      handleHeaderChangeOrder, // è¿½åŠ 
      handleColumnWidthsChange, // è¿½åŠ 
      setCsvData, // æ–°ãŸã«è¿½åŠ 
      pushHistoryNow // è¿½åŠ : å±¥æ­´ãƒ—ãƒƒã‚·ãƒ¥é–¢æ•°ã‚’å—ã‘å–ã‚‹
    }) => {
      // ãƒ˜ãƒƒãƒ€ãƒ¼é¸æŠå€™è£œ
      const headerOptions = [
        "First Name",
        "Middle Name",
        "Last Name",
        "E-mail Address"
      ];

      // å…¨åˆ—é¸æŠãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
      const handleSelectAllColumnsChange = useCallback((e) => {
        const checked = e.target.checked;
        setSelectedColumns(selectedColumns.map(() => checked));
      }, [selectedColumns, setSelectedColumns]);

      // å…¨è¡Œé¸æŠãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
      const handleSelectAllRowsChange = useCallback((e) => {
        const checked = e.target.checked;
        if (checked) {
          // å…¨ã¦ã®è¡¨ç¤ºè¡Œã®idã‚’é¸æŠ
          const allIds = csvData.map(item => item.id);
          setSelectedRows([...new Set([...selectedRows, ...allIds])]);
        } else {
          // è¡¨ç¤ºè¡Œã®idã‚’é¸æŠã‹ã‚‰è§£é™¤
          const newSelected = selectedRows.filter(id => !csvData.some(item => item.id === id));
          setSelectedRows(newSelected);
        }
      }, [csvData, selectedRows, setSelectedRows]);

      // å€‹åˆ¥è¡Œé¸æŠã®ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
      const handleRowSelectChange = useCallback((e, id) => {
        const checked = e.target.checked;
        if (checked) {
          setSelectedRows([...selectedRows, id]);
        } else {
          setSelectedRows(selectedRows.filter(selectedId => selectedId !== id));
        }
      }, [selectedRows, setSelectedRows]);

      // ãƒ‰ãƒ©ãƒƒã‚°ã‚¢ãƒ³ãƒ‰ãƒ‰ãƒ­ãƒƒãƒ—ã«ã‚ˆã‚‹åˆ—é †åºã®å¤‰æ›´
      const [draggedColumn, setDraggedColumn] = useState(null);

      const handleDragStart = useCallback((e, index) => {
        setDraggedColumn(index);
        e.dataTransfer.effectAllowed = 'move';
        // åˆ—ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ãƒ‡ãƒ¼ã‚¿è»¢é€ã«è¨­å®š
        e.dataTransfer.setData('text/plain', index);
      }, []);

      const handleDragOver = useCallback((e, index) => {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
      }, []);

      const handleDrop = useCallback((e, index) => {
        e.preventDefault();
        const draggedIndex = parseInt(e.dataTransfer.getData('text/plain'), 10);
        if (isNaN(draggedIndex) || draggedIndex === index) return;

        const headers = [...modifiedHeaders];
        const [movedHeader] = headers.splice(draggedIndex, 1);
        headers.splice(index, 0, movedHeader);
        handleHeaderChangeOrder(headers); // æ­£ã—ãå‘¼ã³å‡ºã™

        const widths = [...columnWidths];
        const [movedWidth] = widths.splice(draggedIndex, 1);
        widths.splice(index, 0, movedWidth);
        handleColumnWidthsChange(widths); // æ­£ã—ãå‘¼ã³å‡ºã™

        const selectedCols = [...selectedColumns];
        const [movedSelected] = selectedCols.splice(draggedIndex, 1);
        selectedCols.splice(index, 0, movedSelected);
        setSelectedColumns(selectedCols);

        // ãƒ‡ãƒ¼ã‚¿è¡Œã®åˆ—é †åºã‚‚å¤‰æ›´
        const updatedCsvData = csvData.map(item => {
          const newRow = [...item.row];
          const [movedCell] = newRow.splice(draggedIndex, 1);
          newRow.splice(index, 0, movedCell);
          return { ...item, row: newRow };
        });
        setCsvData(updatedCsvData);
        pushHistoryNow(); // ç·¨é›†ç¢ºå®šæ™‚ã«å±¥æ­´ã‚’ãƒ—ãƒƒã‚·ãƒ¥

        setDraggedColumn(null);
      }, [modifiedHeaders, columnWidths, handleHeaderChangeOrder, handleColumnWidthsChange, selectedColumns, csvData, setCsvData, pushHistoryNow]);

      return (
        <React.Fragment>
          <Typography variant="h5" gutterBottom style={{ marginTop: '30px' }}>CSVãƒ‡ãƒ¼ã‚¿</Typography>

          <div className="table-responsive">
            <TableContainer style={{ overflowX: 'auto' }}>
              <Table size="small" style={{ tableLayout: 'fixed', width: '100%' }}>
                <TableHead>
                  {/* å…ƒã®ãƒ˜ãƒƒãƒ€ãƒ¼ãƒ©ãƒ™ãƒ«ã‚’è¡¨ç¤ºã™ã‚‹è¡Œ */}
                  <TableRow className="original-header-row">
                    {/* å·¦ç«¯ã®ã‚»ãƒ«ã¯æ“ä½œåˆ—ãªã®ã§ç©ºç™½ */}
                    <TableCell
                      className="no-wrap"
                      style={{ width: firstColumnWidth }}
                    >
                      æ“ä½œ
                    </TableCell>
                    {/* å„åˆ—ã®å…ƒãƒ˜ãƒƒãƒ€ãƒ¼ãƒ©ãƒ™ãƒ« */}
                    {originalHeaders.map((originalHeader, idx) => (
                      <TableCell
                        key={`original-header-${idx}`}
                        className="no-wrap"
                        style={{ width: columnWidths[idx], textAlign: 'center' }}
                      >
                        {originalHeader}
                      </TableCell>
                    ))}
                    {/* æœ€å¾Œã®åˆ—ã®å¾Œã¯ç©ºã«ã™ã‚‹ */}
                    <TableCell key={`original-header-last`} className="no-wrap" style={{ width: '150px' }}>
                      {/* ç©ºã®ã‚»ãƒ« */}
                    </TableCell>
                  </TableRow>

                  {/* æ–°ã—ã„åˆ—é¸æŠç”¨ã®ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œ */}
                  <TableRow className="header-row">
                    {/* å…¨åˆ—é¸æŠãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ */}
                    <TableCell
                      className="checkbox-cell no-wrap"
                      style={{ width: firstColumnWidth }}
                    >
                      <Checkbox
                        indeterminate={selectedColumns.some(c => c) && !selectedColumns.every(c => c)}
                        checked={selectedColumns.length > 0 && selectedColumns.every(c => c)}
                        onChange={handleSelectAllColumnsChange}
                        color="primary"
                        inputProps={{ 'aria-label': 'å…¨ã¦ã®åˆ—ã‚’é¸æŠ/è§£é™¤' }}
                      />
                    </TableCell>
                    {/* å„åˆ—ã®é¸æŠãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ */}
                    {modifiedHeaders.map((header, idx) => (
                      <TableCell
                        key={`column-select-${idx}`}
                        className={`checkbox-cell no-wrap ${draggedColumn === idx ? 'dragging' : ''}`}
                        style={{ width: columnWidths[idx], position: 'relative' }}
                      >
                        <Checkbox
                          checked={selectedColumns[idx] || false}
                          onChange={(e) => {
                            const updated = [...selectedColumns];
                            updated[idx] = e.target.checked;
                            setSelectedColumns(updated);
                          }}
                          color="primary"
                          inputProps={{ 'aria-label': `åˆ—${idx + 1}ã‚’é¸æŠ` }}
                        />
                      </TableCell>
                    ))}
                    {/* æœ€å¾Œã®åˆ—ã®å¾Œã¯ç©ºã«ã™ã‚‹ */}
                    <TableCell key={`add-sort-last`} className="checkbox-cell no-wrap" style={{ position: 'relative', width: '150px' }}>
                      {/* ç©ºã®ã‚»ãƒ« */}
                    </TableCell>
                  </TableRow>
                  {/* æ—¢å­˜ã®ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œ */}
                  <TableRow className="header-row">
                    {/* å…¨è¡Œé¸æŠãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ */}
                    <TableCell
                      className="checkbox-cell no-wrap"
                      style={{ width: firstColumnWidth, position: 'relative' }}
                    >
                      <Checkbox
                        indeterminate={selectedRows.length > 0 && selectedRows.length < csvData.length}
                        checked={csvData.length > 0 && selectedRows.length === csvData.length}
                        onChange={handleSelectAllRowsChange}
                        color="primary"
                        inputProps={{ 'aria-label': 'å…¨ã¦ã®è¡Œã‚’é¸æŠ/è§£é™¤' }}
                      />
                      {/* åˆ—å¹…èª¿æ•´ãƒãƒ³ãƒ‰ãƒ« */}
                      <div
                        className="resize-handle"
                        onMouseDown={(e) => handleMouseDown(e, -1)} // -1ã‚’ç‰¹åˆ¥ãªå€¤ã¨ã—ã¦ä½¿ç”¨
                      />
                    </TableCell>
                    {/* å„åˆ—ã®ãƒ˜ãƒƒãƒ€ãƒ¼ */}
                    {modifiedHeaders.map((header, idx) => (
                      <TableCell
                        key={`header-${idx}`}
                        className={`no-wrap ${draggedColumn === idx ? 'dragging' : ''}`}
                        style={{ width: columnWidths[idx], position: 'relative' }}
                        draggable
                        onDragStart={(e) => handleDragStart(e, idx)}
                        onDragOver={(e) => handleDragOver(e, idx)}
                        onDrop={(e) => handleDrop(e, idx)}
                      >
                        <div className="header-content">
                          <Tooltip
                            title={header}
                            arrow
                            enterDelay={500}
                          >
                            <div>
                              <Autocomplete
                                freeSolo
                                options={headerOptions}
                                value={modifiedHeaders[idx] || ''}
                                onChange={(event, newValue) => {
                                  handleHeaderChange(idx, newValue || '');
                                }}
                                onInputChange={(event, newInputValue) => {
                                  handleHeaderChange(idx, newInputValue);
                                }}
                                renderInput={(params) => (
                                  <TextField
                                    {...params}
                                    className="header-input"
                                    variant="standard"
                                    label={`åˆ—${idx + 1}`}
                                    InputProps={{
                                      ...params.InputProps,
                                      className: 'header-text',
                                    }}
                                  />
                                )}
                              />
                            </div>
                          </Tooltip>
                          {/* ã‚½ãƒ¼ãƒˆãƒ©ãƒ™ãƒ«ã®è¿½åŠ  */}
                          <TableSortLabel
                            active={orderBy === idx}
                            direction={orderBy === idx ? order : 'asc'}
                            onClick={() => handleRequestSort(idx)}
                          />
                          {/* ç·¨é›†ãƒ¢ãƒ¼ãƒ‰ã®æ™‚ã ã‘åˆ—ãƒ˜ãƒƒãƒ€ãƒ¼ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º */}
                          {isEditMode && (
                            <div className="header-actions">
                              <Tooltip title={`åˆ—${idx + 1}ã®å¾Œã«åˆ—ã‚’è¿½åŠ `}>
                                <IconButton
                                  size="small"
                                  onClick={() => handleAddColumn(idx + 1)}
                                  color="primary"
                                  aria-label={`åˆ—${idx + 1}ã®å¾Œã«åˆ—ã‚’è¿½åŠ `}
                                >
                                  â•
                                </IconButton>
                              </Tooltip>
                              <Tooltip title={`åˆ—${idx + 1}ã‚’å‰Šé™¤`}>
                                <IconButton
                                  size="small"
                                  onClick={() => handleDeleteColumn(idx)}
                                  color="secondary"
                                  aria-label={`åˆ—${idx + 1}ã‚’å‰Šé™¤`}
                                  disabled={modifiedHeaders.length <= 1}
                                >
                                  ğŸ—‘ï¸
                                </IconButton>
                              </Tooltip>
                            </div>
                          )}
                        </div>
                        {/* åˆ—å¹…èª¿æ•´ãƒãƒ³ãƒ‰ãƒ« */}
                        <div
                          className="resize-handle"
                          onMouseDown={(e) => handleMouseDown(e, idx)}
                        />
                      </TableCell>
                    ))}
                    {/* æœ€å¾Œã®åˆ—ã®å¾Œã«ã‚‚è¿½åŠ ãƒœã‚¿ãƒ³ã¨å‰Šé™¤ãƒœã‚¿ãƒ³ã‚’é…ç½®ï¼ˆæ—¢ã«å„ãƒ˜ãƒƒãƒ€ãƒ¼ã«é…ç½®æ¸ˆã¿ãªã®ã§ç©ºã«ã™ã‚‹ï¼‰ */}
                    <TableCell key={`add-sort-last-header`} className="no-wrap" style={{ width: '150px' }}>
                      {/* ç©ºã®ã‚»ãƒ« */}
                    </TableCell>
                  </TableRow>
                </TableHead>
                <TableBody>
                  {csvData.map((item, rowIndex) => (
                    <TableRow key={item.id}>
                      {/* è¡Œé¸æŠç”¨ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã¨â•ğŸ—‘ï¸ãƒœã‚¿ãƒ³ã‚’åŒã‚»ãƒ«ã«é…ç½® */}
                      <TableCell
                        className="checkbox-cell no-wrap"
                        style={{ width: firstColumnWidth, display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '5px', position: 'relative' }}
                      >
                        <Checkbox
                          checked={selectedRows.includes(item.id)}
                          onChange={(e) => handleRowSelectChange(e, item.id)}
                          color="primary"
                          inputProps={{ 'aria-label': `è¡Œã‚’é¸æŠ` }}
                        />
                        {/* ç·¨é›†ãƒ¢ãƒ¼ãƒ‰ã®æ™‚ã ã‘â•ğŸ—‘ï¸ãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º */}
                        {isEditMode && (
                          <React.Fragment>
                            <Tooltip title={`ã“ã®è¡Œã®ä¸‹ã«è¡Œã‚’è¿½åŠ `}>
                              <IconButton
                                size="small"
                                onClick={() => onAddRowAt(item.id)}
                                color="primary"
                                aria-label={`ã“ã®è¡Œã®ä¸‹ã«è¡Œã‚’è¿½åŠ `}
                              >
                                â•
                              </IconButton>
                            </Tooltip>
                            <Tooltip title={`ã“ã®è¡Œã‚’å‰Šé™¤`}>
                              <IconButton
                                size="small"
                                onClick={() => onDeleteRowAt(item.id)}
                                color="secondary"
                                aria-label={`ã“ã®è¡Œã‚’å‰Šé™¤`}
                                disabled={useHeader && item.id === 'header'}
                              >
                                ğŸ—‘ï¸
                              </IconButton>
                            </Tooltip>
                          </React.Fragment>
                        )}
                      </TableCell>
                      {/* å„ã‚»ãƒ«ã®ãƒ‡ãƒ¼ã‚¿ */}
                      {item.row.map((cell, cellIndex) => (
                        <EditableTableCell
                          key={cellIndex}
                          cell={cell}
                          rowId={item.id}
                          cellIndex={cellIndex}
                          isEditMode={isEditMode}
                          editingCell={editingCell}
                          setEditingCell={setEditingCell}
                          handleCellChange={handleCellChange}
                          pushHistoryNow={pushHistoryNow} // è¿½åŠ : å±¥æ­´ãƒ—ãƒƒã‚·ãƒ¥é–¢æ•°ã‚’æ¸¡ã™
                        />
                      ))}
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </TableContainer>
          </div>
        </React.Fragment>
      );
    });

    const App = () => {
      // æ—¢å­˜ã®ã‚¹ãƒ†ãƒ¼ãƒˆå®£è¨€
      const [csvData, setCsvData] = useState([]);
      const [fileData, setFileData] = useState(null); // ãƒ•ã‚¡ã‚¤ãƒ«ã®ArrayBufferã‚’ä¿æŒ
      const [inputEncoding, setInputEncoding] = useState('UTF-8');
      const [outputEncoding, setOutputEncoding] = useState('UTF-8');
      const [useHeader, setUseHeader] = useState(true);
      const [isDragOver, setIsDragOver] = useState(false);
      const [searchQuery, setSearchQuery] = useState(''); // æ¤œç´¢ã‚¯ã‚¨ãƒªã®çŠ¶æ…‹

      // ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³ç”¨ã®çŠ¶æ…‹
      const [page, setPage] = useState(0);
      const [rowsPerPage, setRowsPerPage] = useState(10); // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚’10ã«è¨­å®š

      // ã‚½ãƒ¼ãƒˆç”¨ã®çŠ¶æ…‹
      const [order, setOrder] = useState('asc');
      const [orderBy, setOrderBy] = useState('');

      // ãƒ˜ãƒƒãƒ€ãƒ¼ã®å¤‰æ›´ç”¨ã®çŠ¶æ…‹
      const [modifiedHeaders, setModifiedHeaders] = useState([]);
      const [originalHeaders, setOriginalHeaders] = useState([]); // è¿½åŠ 

      // åˆ—å¹…ã®çŠ¶æ…‹
      const [columnWidths, setColumnWidths] = useState([]);
      const [firstColumnWidth, setFirstColumnWidth] = useState(150); // è¿½åŠ 

      // å±¥æ­´ç®¡ç†
      const [history, setHistory] = useState([]);
      const [future, setFuture] = useState([]);

      // ç·¨é›†ãƒ¢ãƒ¼ãƒ‰ã®çŠ¶æ…‹
      const [isEditMode, setIsEditMode] = useState(false);

      // ç·¨é›†ä¸­ã®ã‚»ãƒ«ã‚’è¿½è·¡ã™ã‚‹çŠ¶æ…‹
      const [editingCell, setEditingCell] = useState({
        rowId: null,
        cellIndex: null,
      });

      // åˆ—å¹…èª¿æ•´ç”¨ã®çŠ¶æ…‹ã‚’ useRef ã«å¤‰æ›´
      const resizingRef = useRef({
        columnIndex: null,
        startX: 0,
        startWidth: 0,
      });

      // ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã®çŠ¶æ…‹
      const [downloadDialogOpen, setDownloadDialogOpen] = useState(false);
      const [downloadFileName, setDownloadFileName] = useState('');

      // CSVãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰æ™‚ã«å‡ºåŠ›ã™ã‚‹åˆ—ã‚’ç®¡ç†ã™ã‚‹ã‚¹ãƒ†ãƒ¼ãƒˆ
      const [selectedColumns, setSelectedColumns] = useState([]);

      // è¡Œé¸æŠç”¨ã®ã‚¹ãƒ†ãƒ¼ãƒˆ
      const [selectedRows, setSelectedRows] = useState([]);

      // Snackbarç”¨ã®ã‚¹ãƒ†ãƒ¼ãƒˆ
      const [snackbarOpen, setSnackbarOpen] = useState(false);
      const [snackbarMessage, setSnackbarMessage] = useState('');

      // ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ã®çŠ¶æ…‹
      const [isLoading, setIsLoading] = useState(false); // è¿½åŠ 

      // CSVãƒ‡ãƒ¼ã‚¿ã‚’ãƒ‡ã‚³ãƒ¼ãƒ‰ã™ã‚‹é–¢æ•°
      const decodeFileData = useCallback((arrayBuffer, encoding) => {
        let decodedText = '';
        if (encoding === 'Shift_JIS') {
          const uint8Array = new Uint8Array(arrayBuffer);
          decodedText = Encoding.convert(uint8Array, {
            to: 'UNICODE',
            from: 'SJIS',
            type: 'string'
          });
        } else {
          const decoder = new TextDecoder(encoding);
          decodedText = decoder.decode(arrayBuffer);
        }
        const rows = decodedText.split(/\r\n|\n/).filter(row => row.trim() !== '').map(row => row.split(','));
        return rows;
      }, []);

      // CSVãƒ‡ãƒ¼ã‚¿ã‚’ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã™ã‚‹é–¢æ•°
      const encodeCsvData = useCallback((data, encoding) => {
        let encodedContent = '';
        if (encoding === 'Shift_JIS') {
          const unicodeString = data.map(row => row.join(',')).join('\n');
          const encodedArray = Encoding.convert(unicodeString, {
            to: 'SJIS',
            from: 'UNICODE',
            type: 'array'
          });
          return new Uint8Array(encodedArray);
        } else {
          // UTF-8ã®å ´åˆã¯Blobã‚’ãã®ã¾ã¾ä½¿ç”¨
          const utf8Encoder = new TextEncoder();
          encodedContent = utf8Encoder.encode(data.map(row => row.join(',')).join('\n'));
          return encodedContent;
        }
      }, []);

      // æ“ä½œå‰ã®çŠ¶æ…‹ã‚’å±¥æ­´ã«ä¿å­˜ã™ã‚‹é–¢æ•°ï¼ˆãƒãƒƒãƒå‡¦ç†ç”¨ï¼‰
      const pushToHistory = useRef(null);
      useEffect(() => {
        // Initialize pushToHistory with debounce
        pushToHistory.current = debounce(() => {
          const currentState = {
            modifiedHeaders: [...modifiedHeaders],
            originalHeaders: [...originalHeaders], // è¿½åŠ 
            columnWidths: [...columnWidths],
            selectedColumns: [...selectedColumns],
            selectedRows: [...selectedRows],
            firstColumnWidth: firstColumnWidth // è¿½åŠ 
          };
          setHistory(prevHistory => [...prevHistory, currentState]);
          setFuture([]); // æ–°ã—ã„æ“ä½œãŒè¡Œã‚ã‚ŒãŸãŸã‚ã€å°†æ¥ã®æ“ä½œã¯ã‚¯ãƒªã‚¢
        }, 500); // 500msã®é…å»¶
      }, [modifiedHeaders, originalHeaders, columnWidths, selectedColumns, selectedRows, firstColumnWidth]);

      // debounceé–¢æ•°ã®å®šç¾©
      function debounce(func, wait) {
        let timeout;
        return function(...args) {
          clearTimeout(timeout);
          timeout = setTimeout(() => func.apply(this, args), wait);
        };
      }

      // ã‚»ãƒ«ç·¨é›†ãŒç¢ºå®šã—ãŸæ™‚ç‚¹ã§å±¥æ­´ã‚’ãƒ—ãƒƒã‚·ãƒ¥ã™ã‚‹é–¢æ•°
      const pushHistoryNow = useCallback(() => {
        const currentState = {
          csvData: JSON.parse(JSON.stringify(csvData)),
          modifiedHeaders: [...modifiedHeaders],
          originalHeaders: [...originalHeaders],
          columnWidths: [...columnWidths],
          selectedColumns: [...selectedColumns],
          selectedRows: [...selectedRows],
          firstColumnWidth: firstColumnWidth
        };
        setHistory(prevHistory => [...prevHistory, currentState]);
        setFuture([]); // æ–°ã—ã„æ“ä½œãŒè¡Œã‚ã‚ŒãŸãŸã‚ã€å°†æ¥ã®æ“ä½œã¯ã‚¯ãƒªã‚¢
      }, [csvData, modifiedHeaders, originalHeaders, columnWidths, selectedColumns, selectedRows, firstColumnWidth]);

      // ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å‡¦ç†
      const handleFileUpload = useCallback((file) => {
        if (file) {
          setIsLoading(true); // ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°é–‹å§‹
          const reader = new FileReader();
          reader.onload = (e) => {
            const arrayBuffer = e.target.result;
            setFileData(arrayBuffer); // ArrayBufferã‚’ä¿å­˜
            try {
              const rows = decodeFileData(arrayBuffer, inputEncoding);
              // å„è¡Œã«ä¸€æ„ã®IDã‚’ä»˜ä¸
              const dataWithId = rows.map((row, idx) => ({
                id: useHeader && idx === 0 ? 'header' : generateUUID(),
                row
              }));
              setCsvData(dataWithId);
              // ãƒ˜ãƒƒãƒ€ãƒ¼ã®åˆæœŸåŒ–
              initializeHeaders(dataWithId);
              // ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³ã¨ã‚½ãƒ¼ãƒˆã‚’ãƒªã‚»ãƒƒãƒˆ
              setPage(0);
              setOrder('asc');
              setOrderBy('');
              // æ¤œç´¢ã‚¯ã‚¨ãƒªã‚’ãƒªã‚»ãƒƒãƒˆ
              setSearchQuery('');
              // å±¥æ­´ã‚’ãƒªã‚»ãƒƒãƒˆ
              setHistory([]);
              setFuture([]);
              // åˆ—å¹…ã®èª¿æ•´ã¯ useEffect ã§è‡ªå‹•çš„ã«è¡Œã‚ã‚Œã‚‹
            } catch (error) {
              alert('ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚„ãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
              console.error('ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
            } finally {
              setIsLoading(false); // ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°çµ‚äº†
            }
          };
          reader.onerror = (e) => {
            alert('ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚');
            console.error('ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', e);
            setIsLoading(false); // ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°çµ‚äº†
          };
          reader.readAsArrayBuffer(file);
        }
      }, [decodeFileData, inputEncoding, useHeader, initializeHeaders]);

      // ãƒ˜ãƒƒãƒ€ãƒ¼ã®åˆæœŸåŒ–
      const initializeHeaders = useCallback((data) => {
        if (useHeader && data.length > 0 && data[0].id === 'header') {
          setModifiedHeaders([...data[0].row]);
          setOriginalHeaders([...data[0].row]); // è¿½åŠ 
          // selectedColumnsã‚’å…¨ã¦trueã§åˆæœŸåŒ–
          setSelectedColumns(data[0].row.map(() => true));
        } else if (data.length > 0) {
          const syntheticHeaders = data[0].row.map((_, idx) => `åˆ—${idx + 1}`);
          setModifiedHeaders(syntheticHeaders);
          setOriginalHeaders(syntheticHeaders); // è¿½åŠ 
          // selectedColumnsã‚’å…¨ã¦trueã§åˆæœŸåŒ–
          setSelectedColumns(data[0].row.map(() => true));
        } else {
          setModifiedHeaders([]);
          setOriginalHeaders([]); // è¿½åŠ 
          setSelectedColumns([]);
        }

        // åˆ—å¹…ã®åˆæœŸåŒ–ã¯adjustColumnWidthsã§è¡Œã†ãŸã‚ã€ã“ã“ã§ã¯è¨­å®šã—ãªã„
      }, [useHeader]);

      // ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°å¤‰æ›´æ™‚ã®å‡¦ç†
      const handleEncodingChange = useCallback((encoding) => {
        setInputEncoding(encoding);
        if (fileData) {
          setIsLoading(true); // ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°é–‹å§‹
          try {
            const rows = decodeFileData(fileData, encoding);
            // å„è¡Œã«ä¸€æ„ã®IDã‚’ä»˜ä¸
            const dataWithId = rows.map((row, idx) => ({
              id: useHeader && idx === 0 ? 'header' : generateUUID(),
              row
            }));
            setCsvData(dataWithId);
            // ãƒ˜ãƒƒãƒ€ãƒ¼ã®å†åˆæœŸåŒ–
            initializeHeaders(dataWithId);
            // ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³ã¨ã‚½ãƒ¼ãƒˆã‚’ãƒªã‚»ãƒƒãƒˆ
            setPage(0);
            setOrder('asc');
            setOrderBy('');
            // æ¤œç´¢ã‚¯ã‚¨ãƒªã‚’ãƒªã‚»ãƒƒãƒˆ
            setSearchQuery('');
            // å±¥æ­´ã‚’ãƒªã‚»ãƒƒãƒˆ
            setHistory([]);
            setFuture([]);
            // åˆ—å¹…ã®èª¿æ•´ã¯ useEffect ã§è‡ªå‹•çš„ã«è¡Œã‚ã‚Œã‚‹
          } catch (error) {
            alert('ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã®å¤‰æ›ã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
            console.error('ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°å¤‰æ›ã‚¨ãƒ©ãƒ¼:', error);
          } finally {
            setIsLoading(false); // ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°çµ‚äº†
          }
        }
      }, [fileData, decodeFileData, useHeader, initializeHeaders]);

      // CSVãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å‡¦ç†
      const handleDownload = useCallback(async (filename) => {
        // ãƒ•ã‚¡ã‚¤ãƒ«åãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„å ´åˆã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆåã‚’ä½¿ç”¨
        if (!filename) {
          const now = new Date();
          const pad = (num) => String(num).padStart(2, '0');
          const formattedDate = `${now.getFullYear()}${pad(now.getMonth() + 1)}${pad(now.getDate())}_${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}`;
          filename = `transformed_${formattedDate}.csv`;
        }

        let dataToDownload = [...csvData];
        if (useHeader && dataToDownload.length > 0 && dataToDownload[0].id === 'header') {
          // ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’modifiedHeadersã«ç½®ãæ›ãˆã‚‹
          dataToDownload[0].row = [...modifiedHeaders];
        }

        // é¸æŠã•ã‚ŒãŸåˆ—ã®ã¿ã‚’æŠ½å‡º
        const selectedIndices = selectedColumns.map((selected, idx) => selected ? idx : null).filter(idx => idx !== null);
        dataToDownload = dataToDownload.map(item => ({
          id: item.id,
          row: selectedIndices.map(idx => item.row[idx])
        }));

        // é¸æŠã•ã‚ŒãŸè¡Œã®ã¿ã‚’æŠ½å‡º
        if (selectedRows.length > 0) {
          dataToDownload = dataToDownload.filter(item => selectedRows.includes(item.id));
        }

        // ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã‚’æŠ½å‡º
        const exportData = dataToDownload.map(item => item.row);

        const encodedContent = encodeCsvData(exportData, outputEncoding);
        const blob = new Blob([encodedContent], { type: 'text/csv;charset=' + (outputEncoding === 'Shift_JIS' ? 'Shift_JIS' : 'UTF-8') });

        if ('showSaveFilePicker' in window) {
          try {
            const options = {
              suggestedName: filename,
              types: [{
                description: 'CSV Files',
                accept: { 'text/csv': ['.csv'] },
              }],
            };
            const handle = await window.showSaveFilePicker(options);
            const writable = await handle.createWritable();
            await writable.write(blob);
            await writable.close();
          } catch (err) {
            console.error('ãƒ•ã‚¡ã‚¤ãƒ«ã®ä¿å­˜ãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¾ã—ãŸ:', err);
          }
        } else {
          // ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ãªã„å ´åˆã€å¾“æ¥ã®æ–¹æ³•ã§ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = filename;
          a.click();
          URL.revokeObjectURL(url);
        }
      }, [csvData, useHeader, modifiedHeaders, selectedColumns, selectedRows, outputEncoding, encodeCsvData]);

      // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã®ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
      const openDownloadDialog = useCallback(() => {
        // ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’é–‹ã
        setDownloadFileName(getDefaultFileName());
        setDownloadDialogOpen(true);
      }, []);

      const getDefaultFileName = useCallback(() => {
        const now = new Date();
        const pad = (num) => String(num).padStart(2, '0');
        const formattedDate = `${now.getFullYear()}${pad(now.getMonth() + 1)}${pad(now.getDate())}_${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}`;
        return `transformed_${formattedDate}.csv`;
      }, []);

      const handleDownloadConfirm = useCallback(() => {
        // ãƒ•ã‚¡ã‚¤ãƒ«åãŒç©ºã§ãªã„ã“ã¨ã‚’ç¢ºèª
        if (downloadFileName.trim() === '') {
          alert('ãƒ•ã‚¡ã‚¤ãƒ«åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚');
          return;
        }
        // .csv æ‹¡å¼µå­ãŒãªã„å ´åˆã¯è¿½åŠ 
        let filename = downloadFileName.trim();
        if (!filename.toLowerCase().endsWith('.csv')) {
          filename += '.csv';
        }
        handleDownload(filename);
        setDownloadDialogOpen(false);
      }, [downloadFileName, handleDownload]);

      const handleDownloadCancel = useCallback(() => {
        setDownloadDialogOpen(false);
      }, []);

      // CSVãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ã®ã‚¯ãƒªãƒƒã‚¯æ™‚ã®å‡¦ç†
      const handleDownloadButtonClick = useCallback(() => {
        if ('showSaveFilePicker' in window) {
          // File System Access API ãŒåˆ©ç”¨å¯èƒ½ãªå ´åˆã€ç›´æ¥ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
          handleDownload();
        } else {
          // åˆ©ç”¨ã§ããªã„å ´åˆã€ãƒ•ã‚¡ã‚¤ãƒ«åã‚’æŒ‡å®šã™ã‚‹ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’è¡¨ç¤º
          openDownloadDialog();
        }
      }, [handleDownload, openDownloadDialog]);

      // ãƒªã‚»ãƒƒãƒˆå‡¦ç†
      const handleReset = useCallback(() => {
        setCsvData([]);
        setFileData(null);
        setInputEncoding('UTF-8');
        setOutputEncoding('UTF-8');
        setUseHeader(true);
        setPage(0);
        setRowsPerPage(10); // ãƒªã‚»ãƒƒãƒˆæ™‚ã«ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚’10ã«æˆ»ã™
        setOrder('asc');
        setOrderBy('');
        setModifiedHeaders([]);
        setOriginalHeaders([]); // è¿½åŠ 
        setSelectedColumns([]);
        setSearchQuery('');
        setHistory([]);
        setFuture([]);
        setIsEditMode(false); // ç·¨é›†ãƒ¢ãƒ¼ãƒ‰ã‚’ãƒªã‚»ãƒƒãƒˆ
        setColumnWidths([]);
        setFirstColumnWidth(150); // è¿½åŠ 
        setEditingCell({ rowId: null, cellIndex: null });
        setSelectedRows([]);
      }, []);

      // ãƒ˜ãƒƒãƒ€ãƒ¼åˆ‡æ›¿æ™‚ã®å‡¦ç†
      const handleHeaderToggle = useCallback((e) => {
        setUseHeader(e.target.checked);
        if (csvData.length > 0) {
          initializeHeaders(csvData);
        }
        // ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³ã¨ã‚½ãƒ¼ãƒˆã‚’ãƒªã‚»ãƒƒãƒˆ
        setPage(0);
        setOrder('asc');
        setOrderBy('');
        // æ¤œç´¢ã‚¯ã‚¨ãƒªã‚’ãƒªã‚»ãƒƒãƒˆ
        setSearchQuery('');
        // å±¥æ­´ã‚’ãƒªã‚»ãƒƒãƒˆ
        setHistory([]);
        setFuture([]);
        // åˆ—å¹…ã®èª¿æ•´ã¯ useEffect ã§è‡ªå‹•çš„ã«è¡Œã‚ã‚Œã‚‹
      }, [csvData, initializeHeaders]);

      // ãƒšãƒ¼ã‚¸å¤‰æ›´æ™‚ã®ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
      const handleChangePage = useCallback((event, newPage) => {
        setPage(newPage);
      }, []);

      // è¡¨ç¤ºè¡Œæ•°å¤‰æ›´æ™‚ã®ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
      const handleChangeRowsPerPage = useCallback((event) => {
        const value = event.target.value === 'all' ? -1 : parseInt(event.target.value, 10);
        setRowsPerPage(value);
        setPage(0);
      }, []);

      // ã‚½ãƒ¼ãƒˆãƒªã‚¯ã‚¨ã‚¹ãƒˆæ™‚ã®ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
      const handleRequestSort = useCallback((property) => {
        const isAsc = orderBy === property && order === 'asc';
        setOrder(isAsc ? 'desc' : 'asc');
        setOrderBy(property);
        setPage(0);
      }, [order, orderBy]);

      // ãƒ˜ãƒƒãƒ€ãƒ¼ã®ãƒ†ã‚­ã‚¹ãƒˆãƒœãƒƒã‚¯ã‚¹å¤‰æ›´æ™‚ã®ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
      const handleHeaderChange = useCallback((index, value) => {
        // pushToHistory.current(); // ä¸è¦
        const updatedHeaders = [...modifiedHeaders];
        updatedHeaders[index] = value;
        setModifiedHeaders(updatedHeaders);
        pushToHistory.current(); // å±¥æ­´ã‚’ãƒ—ãƒƒã‚·ãƒ¥
      }, [modifiedHeaders]);

      // åˆ—é †åºå¤‰æ›´ç”¨ã®ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
      const handleHeaderChangeOrder = useCallback((newHeaders) => {
        setModifiedHeaders(newHeaders);
        pushToHistory.current(); //å±¥æ­´ã‚’ãƒ—ãƒƒã‚·ãƒ¥
      }, []);

      // åˆ—å¹…å¤‰æ›´ç”¨ã®ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
      const handleColumnWidthsChange = useCallback((newWidths) => {
        setColumnWidths(newWidths);
        pushToHistory.current(); //å±¥æ­´ã‚’ãƒ—ãƒƒã‚·ãƒ¥
      }, []);

      // åˆ—ã‚’è¿½åŠ ã™ã‚‹é–¢æ•°ï¼ˆæŒ‡å®šã•ã‚ŒãŸã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ä½ç½®ã«è¿½åŠ ï¼‰
      const handleAddColumn = useCallback((insertIndex) => {
        // æ–°ã—ã„ãƒ˜ãƒƒãƒ€ãƒ¼åã‚’è¨­å®š
        const newHeader = `åˆ—${modifiedHeaders.length + 1}`;
        const updatedHeaders = [...modifiedHeaders];
        updatedHeaders.splice(insertIndex, 0, newHeader); // æŒ‡å®šä½ç½®ã«æŒ¿å…¥
        setModifiedHeaders(updatedHeaders);

        // åˆ—å¹…ã‚’è¿½åŠ 
        const updatedWidths = [...columnWidths];
        updatedWidths.splice(insertIndex, 0, 150); // æ–°ã—ã„åˆ—ã«ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå¹…ã‚’è¨­å®š
        setColumnWidths(updatedWidths);

        // selectedColumnsã‚’æ›´æ–°ï¼ˆæ–°ã—ã„åˆ—ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§é¸æŠçŠ¶æ…‹ï¼‰
        const updatedSelected = [...selectedColumns];
        updatedSelected.splice(insertIndex, 0, true);
        setSelectedColumns(updatedSelected);

        // ãƒ‡ãƒ¼ã‚¿è¡Œã«ç©ºã®ã‚»ãƒ«ã‚’è¿½åŠ 
        const updatedData = csvData.map((item, idx) => {
          if (useHeader && item.id === 'header') {
            return item;
          } else {
            const newRow = [...item.row];
            newRow.splice(insertIndex, 0, ''); // æŒ‡å®šä½ç½®ã«ç©ºã‚»ãƒ«ã‚’æŒ¿å…¥
            return { ...item, row: newRow };
          }
        });
        setCsvData(updatedData);
        pushToHistory.current(); // å±¥æ­´ã‚’ãƒ—ãƒƒã‚·ãƒ¥
      }, [modifiedHeaders, columnWidths, selectedColumns, csvData, useHeader]);

      // åˆ—ã‚’å‰Šé™¤ã™ã‚‹é–¢æ•°ï¼ˆæŒ‡å®šã•ã‚ŒãŸã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ä½ç½®ã‹ã‚‰å‰Šé™¤ï¼‰
      const handleDeleteColumn = useCallback((deleteIndex) => {
        if (modifiedHeaders.length <= 1) {
          alert("æœ€ä½ã§ã‚‚1åˆ—ã¯ä¿æŒã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚");
          return;
        }

        const confirmDelete = window.confirm(`åˆ—ã€Œ${modifiedHeaders[deleteIndex]}ã€ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ`);
        if (!confirmDelete) return;

        const updatedHeaders = [...modifiedHeaders];
        updatedHeaders.splice(deleteIndex, 1); // æŒ‡å®šä½ç½®ã‹ã‚‰1ã¤å‰Šé™¤
        setModifiedHeaders(updatedHeaders);

        // åˆ—å¹…ã‚’å‰Šé™¤
        const updatedWidths = [...columnWidths];
        updatedWidths.splice(deleteIndex, 1);
        setColumnWidths(updatedWidths);

        // selectedColumnsã‚’å‰Šé™¤
        const updatedSelected = [...selectedColumns];
        updatedSelected.splice(deleteIndex, 1);
        setSelectedColumns(updatedSelected);

        const updatedData = csvData.map((item, idx) => {
          if (useHeader && item.id === 'header') {
            return item;
          } else {
            const newRow = [...item.row];
            if (deleteIndex < newRow.length) {
              newRow.splice(deleteIndex, 1); // æŒ‡å®šä½ç½®ã‹ã‚‰1ã¤å‰Šé™¤
            }
            return { ...item, row: newRow };
          }
        });
        setCsvData(updatedData);
        pushToHistory.current(); // å±¥æ­´ã‚’ãƒ—ãƒƒã‚·ãƒ¥
      }, [modifiedHeaders, columnWidths, selectedColumns, csvData, useHeader]);

      // Undoæ“ä½œã®ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
      const handleUndo = useCallback(() => {
        if (history.length === 0) return;
        const previousState = history[history.length - 1];
        const newHistory = history.slice(0, history.length - 1);
        setHistory(newHistory);
        setFuture(prevFuture => [{
          csvData: JSON.parse(JSON.stringify(csvData)),
          modifiedHeaders: [...modifiedHeaders],
          originalHeaders: [...originalHeaders], // è¿½åŠ 
          columnWidths: [...columnWidths],
          selectedColumns: [...selectedColumns],
          selectedRows: [...selectedRows],
          firstColumnWidth: firstColumnWidth
        }, ...prevFuture]);
        setCsvData(previousState.csvData);
        setModifiedHeaders(previousState.modifiedHeaders);
        setOriginalHeaders(previousState.originalHeaders); // è¿½åŠ 
        setColumnWidths(previousState.columnWidths);
        setSelectedColumns(previousState.selectedColumns);
        setSelectedRows(previousState.selectedRows);
        setFirstColumnWidth(previousState.firstColumnWidth);
        setSearchQuery('');
        setEditingCell({ rowId: null, cellIndex: null });
      }, [history, csvData, modifiedHeaders, originalHeaders, columnWidths, selectedColumns, selectedRows, firstColumnWidth]);

      // Redoæ“ä½œã®ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
      const handleRedo = useCallback(() => {
        if (future.length === 0) return;
        const nextState = future[0];
        const newFuture = future.slice(1);
        setFuture(newFuture);
        setHistory(prevHistory => [...prevHistory, {
          csvData: JSON.parse(JSON.stringify(csvData)),
          modifiedHeaders: [...modifiedHeaders],
          originalHeaders: [...originalHeaders], // è¿½åŠ 
          columnWidths: [...columnWidths],
          selectedColumns: [...selectedColumns],
          selectedRows: [...selectedRows],
          firstColumnWidth: firstColumnWidth
        }]);
        setCsvData(nextState.csvData);
        setModifiedHeaders(nextState.modifiedHeaders);
        setOriginalHeaders(nextState.originalHeaders); // è¿½åŠ 
        setColumnWidths(nextState.columnWidths);
        setSelectedColumns(nextState.selectedColumns);
        setSelectedRows(nextState.selectedRows);
        setFirstColumnWidth(nextState.firstColumnWidth);
        setSearchQuery('');
        setEditingCell({ rowId: null, cellIndex: null });
      }, [future, csvData, modifiedHeaders, originalHeaders, columnWidths, selectedColumns, selectedRows, firstColumnWidth]);

      // ã‚»ãƒ«ã®å€¤ã‚’å¤‰æ›´ã™ã‚‹ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ï¼ˆç·¨é›†ãƒ¢ãƒ¼ãƒ‰ç”¨ï¼‰
      const handleCellChange = useCallback((rowId, cellIndex, newValue) => {
        const updatedData = csvData.map(item => {
          if (item.id === rowId) {
            const updatedRow = [...item.row];
            updatedRow[cellIndex] = newValue;
            return { ...item, row: updatedRow };
          }
          return item;
        });
        setCsvData(updatedData);
        // åˆ—å¹…ã‚’å†èª¿æ•´
        adjustColumnWidth(cellIndex, newValue);
        // å±¥æ­´ã¯ãƒãƒƒãƒå‡¦ç†ã«ã‚ˆã‚Š pushToHistory.current() ãŒæ—¢ã«å‘¼ã°ã‚Œã¦ã„ã‚‹
      }, [csvData, adjustColumnWidth]);

      // åˆ—å¹…ã‚’è‡ªå‹•èª¿æ•´ã™ã‚‹é–¢æ•°
      const adjustColumnWidth = useCallback((colIndex, newValue) => {
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        context.font = '16px Roboto'; // ä½¿ç”¨ã—ã¦ã„ã‚‹ãƒ•ã‚©ãƒ³ãƒˆã«åˆã‚ã›ã‚‹
        const metrics = context.measureText(newValue.toString());
        const padding = 20; // ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ï¼ˆãƒ”ã‚¯ã‚»ãƒ«å˜ä½ï¼‰
        const newWidth = padding + metrics.width;
        if (newWidth > columnWidths[colIndex]) {
          const updatedWidths = [...columnWidths];
          updatedWidths[colIndex] = newWidth;
          setColumnWidths(updatedWidths);
        }
      }, [columnWidths]);

      // åˆ—å¹…èª¿æ•´ã®ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ãƒ­ã‚¸ãƒƒã‚¯
      const handleMouseDown = useCallback((e, index) => {
        e.preventDefault(); // ãƒ†ã‚­ã‚¹ãƒˆé¸æŠã‚’é˜²ã
        resizingRef.current = {
          columnIndex: index,
          startX: e.clientX,
          startWidth: index === -1 ? firstColumnWidth : columnWidths[index],
        };

        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¿½åŠ 
        window.addEventListener('mousemove', handleMouseMove);
        window.addEventListener('mouseup', handleMouseUp);
      }, [columnWidths, firstColumnWidth, handleMouseMove, handleMouseUp]);

      const handleMouseMove = useCallback((e) => {
        const { columnIndex, startX, startWidth } = resizingRef.current;
        if (columnIndex === null) return;

        const deltaX = e.clientX - startX;
        const newWidth = startWidth + deltaX;
        if (newWidth > 50) { // æœ€å°å¹…ã‚’50pxã«è¨­å®š
          if (columnIndex === -1) {
            setFirstColumnWidth(newWidth);
          } else {
            const updatedWidths = [...columnWidths];
            updatedWidths[columnIndex] = newWidth;
            setColumnWidths(updatedWidths);
          }
        }
      }, [columnWidths]);

      const handleMouseUp = useCallback(() => {
        // ãƒªã‚µã‚¤ã‚ºã‚’çµ‚äº†
        resizingRef.current = {
          columnIndex: null,
          startX: 0,
          startWidth: 0,
        };
        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’å‰Šé™¤
        window.removeEventListener('mousemove', handleMouseMove);
        window.removeEventListener('mouseup', handleMouseUp);
        // å±¥æ­´ã‚’ãƒ—ãƒƒã‚·ãƒ¥
        pushToHistory.current();
      }, [handleMouseMove]);

      // åˆ—å¹…ã‚’è‡ªå‹•èª¿æ•´ã™ã‚‹é–¢æ•°ï¼ˆCanvas APIã‚’ä½¿ç”¨ï¼‰
      const adjustColumnWidths = useCallback(() => {
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        context.font = '16px Roboto'; // ä½¿ç”¨ã—ã¦ã„ã‚‹ãƒ•ã‚©ãƒ³ãƒˆã«åˆã‚ã›ã‚‹

        const padding = 20; // ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ï¼ˆãƒ”ã‚¯ã‚»ãƒ«å˜ä½ï¼‰

        // 1åˆ—ç›®ã®å¹…ã‚’è¨ˆç®—
        let maxFirstColWidth = context.measureText("æ“ä½œ").width + padding; // "æ“ä½œ" ã¯ãƒ˜ãƒƒãƒ€ãƒ¼ã®æƒ³å®š
        csvData.forEach((item) => {
          // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã¨ã‚¢ã‚¤ã‚³ãƒ³ãƒœã‚¿ãƒ³ã®å¹…ã‚’è€ƒæ…®
          const checkboxWidth = 40; // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®å¹…ã®ç›®å®‰
          const iconsWidth = isEditMode ? 60 : 0; // ã‚¢ã‚¤ã‚³ãƒ³ãƒœã‚¿ãƒ³ã®å¹…ã®ç›®å®‰
          const totalWidth = checkboxWidth + iconsWidth;
          if (totalWidth > maxFirstColWidth) {
            maxFirstColWidth = totalWidth;
          }
        });
        setFirstColumnWidth(maxFirstColWidth);

        const newWidths = modifiedHeaders.map((header, colIndex) => {
          let maxWidth = context.measureText(header).width;

          csvData.forEach((item) => {
            if (useHeader && item.id === 'header') return; // ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œã¯ã‚¹ã‚­ãƒƒãƒ—
            const cell = item.row[colIndex];
            if (cell) {
              const cellWidth = context.measureText(cell.toString()).width;
              if (cellWidth > maxWidth) {
                maxWidth = cellWidth;
              }
            }
          });

          return padding + maxWidth;
        });

        setColumnWidths(newWidths);
      }, [csvData, modifiedHeaders, useHeader, isEditMode]);

      // useEffect ãƒ•ãƒƒã‚¯ã‚’è¿½åŠ ã—ã¦è‡ªå‹•åˆ—å¹…èª¿æ•´ã‚’å®Ÿè¡Œ
      useEffect(() => {
        if (csvData.length > 0) {
          requestAnimationFrame(() => {
            adjustColumnWidths();
          });
        }
      }, [csvData, modifiedHeaders, useHeader, isEditMode, adjustColumnWidths]);

      // ç·¨é›†ãƒ¢ãƒ¼ãƒ‰åˆ‡æ›¿æ™‚ã®å‡¦ç†
      const toggleEditMode = useCallback(() => {
        setIsEditMode(prev => !prev);
        setEditingCell({ rowId: null, cellIndex: null }); // ç·¨é›†ä¸­ã®ã‚»ãƒ«ã‚’ãƒªã‚»ãƒƒãƒˆ
        // åˆ—å¹…ã®èª¿æ•´ã¯ useEffect ã§è‡ªå‹•çš„ã«è¡Œã‚ã‚Œã‚‹
      }, []);

      // é¸æŠã—ãŸè¡Œã‚’å‰Šé™¤ã™ã‚‹ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
      const handleDeleteRows = useCallback(() => {
        if (selectedRows.length === 0) {
          alert('å‰Šé™¤ã™ã‚‹è¡Œã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚');
          return;
        }

        const confirmDelete = window.confirm(`é¸æŠã—ãŸ${selectedRows.length}è¡Œã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ`);
        if (!confirmDelete) return;

        const updatedCsvData = csvData.filter(item => !selectedRows.includes(item.id));
        setCsvData(updatedCsvData);

        // é¸æŠçŠ¶æ…‹ã‚’ã‚¯ãƒªã‚¢
        setSelectedRows([]);
        showSnackbar(`${selectedRows.length}è¡Œã‚’å‰Šé™¤ã—ã¾ã—ãŸã€‚`);
        pushToHistory.current(); // å±¥æ­´ã‚’ãƒ—ãƒƒã‚·ãƒ¥
      }, [selectedRows, csvData]);

      // é¸æŠã—ãŸè¡Œã®ä¸‹ã«æ–°ã—ã„è¡Œã‚’è¿½åŠ ã™ã‚‹ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
      const handleAddRow = useCallback(() => {
        if (selectedRows.length === 0) {
          alert('è¿½åŠ ã™ã‚‹è¡Œã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚');
          return;
        }

        // é¸æŠã•ã‚ŒãŸè¡Œã®ä¸­ã§æœ€å°ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å–å¾—
        const selectedIndices = selectedRows.map(id => csvData.findIndex(item => item.id === id));
        const minIndex = Math.min(...selectedIndices);

        // æ–°ã—ã„è¡Œã‚’æŒ¿å…¥ã™ã‚‹ä½ç½®
        const insertIndex = minIndex + 1;

        // æ–°ã—ã„è¡Œã®ãƒ‡ãƒ¼ã‚¿ï¼ˆç©ºã‚»ãƒ«ã§åˆæœŸåŒ–ï¼‰
        const newRow = modifiedHeaders.map(() => '');

        // æ–°ã—ã„è¡Œã«ä¸€æ„ã®IDã‚’ä»˜ä¸
        const newRowWithId = { id: generateUUID(), row: newRow };

        const updatedCsvData = [...csvData];
        updatedCsvData.splice(insertIndex, 0, newRowWithId);
        setCsvData(updatedCsvData);

        // æ–°ã—ãè¿½åŠ ã—ãŸè¡Œã‚’é¸æŠçŠ¶æ…‹ã«ã™ã‚‹
        setSelectedRows([...selectedRows, newRowWithId.id]);

        // ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³ã‚’ãƒªã‚»ãƒƒãƒˆ
        setPage(0);
        showSnackbar('è¡Œã‚’è¿½åŠ ã—ã¾ã—ãŸã€‚');
        pushToHistory.current(); // å±¥æ­´ã‚’ãƒ—ãƒƒã‚·ãƒ¥
      }, [selectedRows, csvData, modifiedHeaders]);

      // å„è¡Œã«å¯¾ã™ã‚‹è¿½åŠ ãƒ»å‰Šé™¤å‡¦ç†
      const handleAddRowAt = useCallback((rowId) => {
        const index = csvData.findIndex(item => item.id === rowId);
        if (index === -1) return;

        // æ–°ã—ã„è¡Œã‚’æŒ¿å…¥ã™ã‚‹ä½ç½®
        const insertIndex = index + 1;

        // æ–°ã—ã„è¡Œã®ãƒ‡ãƒ¼ã‚¿ï¼ˆç©ºã‚»ãƒ«ã§åˆæœŸåŒ–ï¼‰
        const newRow = modifiedHeaders.map(() => '');

        // æ–°ã—ã„è¡Œã«ä¸€æ„ã®IDã‚’ä»˜ä¸
        const newRowWithId = { id: generateUUID(), row: newRow };

        const updatedCsvData = [...csvData];
        updatedCsvData.splice(insertIndex, 0, newRowWithId);
        setCsvData(updatedCsvData);

        // æ–°ã—ãè¿½åŠ ã—ãŸè¡Œã‚’é¸æŠçŠ¶æ…‹ã«ã™ã‚‹
        setSelectedRows([...selectedRows, newRowWithId.id]);

        // ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³ã‚’ãƒªã‚»ãƒƒãƒˆ
        setPage(0);
        showSnackbar('è¡Œã‚’è¿½åŠ ã—ã¾ã—ãŸã€‚');
        pushToHistory.current(); // å±¥æ­´ã‚’ãƒ—ãƒƒã‚·ãƒ¥
      }, [csvData, modifiedHeaders, selectedRows]);

      const handleDeleteRowAt = useCallback((rowId) => {
        if (useHeader && rowId === 'header') {
          alert('ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œã¯å‰Šé™¤ã§ãã¾ã›ã‚“ã€‚');
          return;
        }

        const confirmDelete = window.confirm(`ã“ã®è¡Œã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ`);
        if (!confirmDelete) return;

        const updatedCsvData = csvData.filter(item => item.id !== rowId);
        setCsvData(updatedCsvData);

        // é¸æŠçŠ¶æ…‹ã‹ã‚‰å‰Šé™¤
        setSelectedRows(selectedRows.filter(id => id !== rowId));
        showSnackbar('è¡Œã‚’å‰Šé™¤ã—ã¾ã—ãŸã€‚');
        pushToHistory.current(); // å±¥æ­´ã‚’ãƒ—ãƒƒã‚·ãƒ¥
      }, [useHeader, csvData, selectedRows]);

      // ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ãŠã‚ˆã³ã‚½ãƒ¼ãƒˆã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã¨ãƒ’ãƒƒãƒˆè¡Œæ•°ã‚’ãƒ¡ãƒ¢åŒ–
      const filteredAndSorted = useMemo(() => getFilteredAndSortedData(csvData, useHeader, searchQuery, order, orderBy, page, rowsPerPage), [csvData, useHeader, searchQuery, order, orderBy, page, rowsPerPage]);

      const { data: paginatedData, totalMatched } = filteredAndSorted;

      // Snackbarã‚’è¡¨ç¤ºã™ã‚‹é–¢æ•°
      const showSnackbar = useCallback((message) => {
        setSnackbarMessage(message);
        setSnackbarOpen(true);
      }, []);

      return (
        <Container style={{ marginTop: '20px', marginBottom: '20px' }}>
          {/* ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ */}
          {isLoading && (
            <div
              style={{
                position: 'fixed',
                top: 0,
                left: 0,
                width: '100%',
                height: '100%',
                backgroundColor: 'rgba(255, 255, 255, 0.7)',
                zIndex: 9999,
                display: 'flex',
                justifyContent: 'center',
                alignItems: 'center'
              }}
            >
              <CircularProgress size={80} /> {/* sizeãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’è¿½åŠ ã—ã¦å¤§ããã—ã¾ã™ */}
            </div>
          )}

          <Typography variant="h4" gutterBottom>CSVæ“ä½œãƒ„ãƒ¼ãƒ«</Typography>

          {/* ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã¨ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ— */}
          <FileUpload
            onFileUpload={handleFileUpload}
            isDragOver={isDragOver}
            setIsDragOver={setIsDragOver}
          />

          {/* å…¥åŠ›ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°é¸æŠ */}
          <EncodingSelector
            label="å…¥åŠ›"
            value={inputEncoding}
            onChange={(e) => handleEncodingChange(e.target.value)}
          />

          {/* å‡ºåŠ›ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°é¸æŠ */}
          <EncodingSelector
            label="å‡ºåŠ›"
            value={outputEncoding}
            onChange={(e) => setOutputEncoding(e.target.value)}
          />

          {/* ãƒ˜ãƒƒãƒ€ãƒ¼ä½¿ç”¨åˆ‡æ›¿ */}
          <HeaderToggle
            useHeader={useHeader}
            onToggle={handleHeaderToggle}
          />

          {/* æ¤œç´¢å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ */}
          <SearchField
            searchQuery={searchQuery}
            onSearchChange={(e) => setSearchQuery(e.target.value)}
          />

          {/* ãƒ’ãƒƒãƒˆã—ãŸè¡Œæ•°ã®è¡¨ç¤º */}
          {csvData.length > 0 && (
            <Typography variant="body1" style={{ marginTop: '10px' }}>
              {totalMatched} ä»¶ã®ãƒ‡ãƒ¼ã‚¿ãŒãƒ’ãƒƒãƒˆã—ã¾ã—ãŸã€‚
            </Typography>
          )}

          {/* ãƒœã‚¿ãƒ³ç¾¤ */}
          <ActionButtons
            onReset={handleReset}
            onUndo={handleUndo}
            undoDisabled={history.length === 0}
            onRedo={handleRedo}
            redoDisabled={future.length === 0}
            onToggleEdit={toggleEditMode}
            isEditMode={isEditMode}
            onDeleteRows={handleDeleteRows}
            onAddRow={handleAddRow}
            deleteDisabled={selectedRows.length === 0}
            addDisabled={selectedRows.length === 0}
          />

          {/* CSVãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚»ã‚¯ã‚·ãƒ§ãƒ³ */}
          <DownloadSection
            onDownloadClick={handleDownloadButtonClick}
            downloadDialogOpen={downloadDialogOpen}
            downloadFileName={downloadFileName}
            setDownloadFileName={setDownloadFileName}
            onDownloadConfirm={handleDownloadConfirm}
            onDownloadCancel={handleDownloadCancel}
          />

          {/* CSVãƒ‡ãƒ¼ã‚¿è¡¨ç¤º */}
          {csvData.length > 0 && (
            <React.Fragment>
              <CsvTable
                csvData={paginatedData}
                modifiedHeaders={modifiedHeaders}
                originalHeaders={originalHeaders} // è¿½åŠ 
                columnWidths={columnWidths}
                handleHeaderChange={handleHeaderChange}
                handleAddColumn={handleAddColumn}
                handleDeleteColumn={handleDeleteColumn}
                handleRequestSort={handleRequestSort}
                order={order}
                orderBy={orderBy}
                handleCellChange={handleCellChange}
                isEditMode={isEditMode}
                editingCell={editingCell}
                setEditingCell={setEditingCell}
                handleMouseDown={handleMouseDown}
                selectedColumns={selectedColumns}
                setSelectedColumns={setSelectedColumns}
                selectedRows={selectedRows}
                setSelectedRows={setSelectedRows}
                useHeader={useHeader}
                onAddRowAt={handleAddRowAt}
                onDeleteRowAt={handleDeleteRowAt}
                firstColumnWidth={firstColumnWidth}
                handleHeaderChangeOrder={handleHeaderChangeOrder} // è¿½åŠ 
                handleColumnWidthsChange={handleColumnWidthsChange} // è¿½åŠ 
                setCsvData={setCsvData} // æ–°ãŸã«è¿½åŠ 
                pushHistoryNow={pushHistoryNow} // è¿½åŠ : å±¥æ­´ãƒ—ãƒƒã‚·ãƒ¥é–¢æ•°ã‚’æ¸¡ã™
              />
              {/* ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³ã®è¿½åŠ  */}
              <TablePagination
                component="div"
                count={totalMatched}
                page={page}
                onPageChange={handleChangePage}
                rowsPerPage={rowsPerPage === -1 ? (useHeader ? csvData.length - 1 : csvData.length) : rowsPerPage}
                onRowsPerPageChange={handleChangeRowsPerPage}
                rowsPerPageOptions={[
                  { label: '10', value: 10 },
                  { label: '30', value: 30 },
                  { label: '50', value: 50 },
                  { label: 'å…¨ã¦', value: -1 } // "å…¨ã¦" ã‚’å€¤ã¨ã—ã¦è¨­å®š
                ]}
                labelRowsPerPage="è¡¨ç¤ºä»¶æ•°"
                labelDisplayedRows={({ from, to, count }) => rowsPerPage === -1 ? `å…¨ã¦${count !== -1 ? `ï¼ˆ${count}ä»¶ï¼‰` : ''}` : `${from}-${to} / ${count}`}
              />
            </React.Fragment>
          )}

          {/* Snackbarã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ */}
          <Snackbar
            open={snackbarOpen}
            autoHideDuration={3000}
            onClose={() => setSnackbarOpen(false)}
            message={snackbarMessage}
          />
        </Container>
      );
    };

    ReactDOM.render(<App />, document.getElementById('root'));
  </script>
</body>
</html>
