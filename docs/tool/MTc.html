<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>データ管理システム - フル機能版</title>

  <!-- Google Fonts and Material Icons -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons" />

  <!-- テーブルのコンパクト表示（スプレッドシート風） -->
  <style>
    .custom-table th, .custom-table td {
      border: 1px solid #ddd;
      padding: 4px; /* コンパクトに */
    }
    .custom-table th {
      background-color: #f2f2f2;
      text-align: center;
    }
    .custom-table td {
      text-align: center;
    }
  </style>
</head>
<body>
<div id="root"></div>

<!-- React and ReactDOM (CDN) -->
<script src="https://cdn.jsdelivr.net/npm/react@18/umd/react.production.min.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/react-dom@18/umd/react-dom.production.min.js" crossorigin="anonymous"></script>

<!-- Material UI (CDN) -->
<script src="https://cdn.jsdelivr.net/npm/@mui/material@5.11.15/umd/material-ui.production.min.js" crossorigin="anonymous"></script>

<!-- Chart.js (CDN) -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<!-- Papa Parse (CDN) -->
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.2/papaparse.min.js" crossorigin="anonymous"></script>

<!-- Babel for JSX -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.21.0/babel.min.js" crossorigin="anonymous"></script>

<!-- Emotion (MUI Styling) -->
<script src="https://cdn.jsdelivr.net/npm/@emotion/react@11.11.0/dist/emotion-react.umd.min.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@emotion/styled@11.11.0/dist/emotion-styled.umd.min.js" crossorigin="anonymous"></script>

<script type="text/babel">

// React Hooks
const {
  useState,
  useEffect,
  useRef,
  useCallback,
  useMemo,  // 追加
  useDeferredValue,
  memo
} = React;

// メモ化されたフィルター用テキストフィールドコンポーネント
const FilterTextField = memo(({ placeholder, value, onChange }) => {
  // ローカルの状態
  const [localValue, setLocalValue] = useState(value);
  const [isEditing, setIsEditing] = useState(false);

  // 外部からの値の更新を反映
  useEffect(() => {
    if (!isEditing) {
      setLocalValue(value);
    }
  }, [value, isEditing]);

  const handleChange = useCallback((e) => {
    setLocalValue(e.target.value);
    setIsEditing(true);
  }, []);

  // Enter または Tab キーで確定
  const handleKeyDown = useCallback((e) => {
    if (e.key === 'Enter' || e.key === 'Tab') {
      e.preventDefault();
      onChange(localValue);
      setIsEditing(false);
      e.target.blur();
    }
    // ESC キーでキャンセル
    if (e.key === 'Escape') {
      setLocalValue(value);
      setIsEditing(false);
      e.target.blur();
    }
  }, [localValue, value, onChange]);

  // フォーカスを失ったときの処理
  const handleBlur = useCallback(() => {
    if (isEditing) {
      onChange(localValue);
      setIsEditing(false);
    }
  }, [isEditing, localValue, onChange]);

  return (
    <TextField
      placeholder={placeholder}
      size="small"
      variant="standard"
      value={localValue}
      onChange={handleChange}
      onKeyDown={handleKeyDown}
      onBlur={handleBlur}
    />
  );
});

// メモ化された編集用テキストフィールドコンポーネント
const EditableTextField = memo(({ value, onChange, ...props }) => {
  // ローカルの状態
  const [localValue, setLocalValue] = useState(value);
  const [isEditing, setIsEditing] = useState(false);

  // 外部からの値の更新を反映
  useEffect(() => {
    if (!isEditing) {
      setLocalValue(value);
    }
  }, [value, isEditing]);

  // テキスト入力時の処理
  const handleChange = useCallback((e) => {
    setLocalValue(e.target.value);
    setIsEditing(true);
  }, []);

  // Enter または Tab キーで確定
  const handleKeyDown = useCallback((e) => {
    if (e.key === 'Enter' || e.key === 'Tab') {
      e.preventDefault();
      onChange(localValue);
      setIsEditing(false);
      e.target.blur();
    }
    // ESC キーでキャンセル
    if (e.key === 'Escape') {
      setLocalValue(value);
      setIsEditing(false);
      e.target.blur();
    }
  }, [localValue, value, onChange]);

  // フォーカスを失ったときの処理
  const handleBlur = useCallback(() => {
    if (isEditing) {
      onChange(localValue);
      setIsEditing(false);
    }
  }, [isEditing, localValue, onChange]);

  return (
    <TextField
      size="small"
      value={localValue}
      onChange={handleChange}
      onKeyDown={handleKeyDown}
      onBlur={handleBlur}
      variant="outlined"
      {...props}
    />
  );
});

// Material UIコンポーネント
const {
  Box,
  AppBar,
  Toolbar,
  Typography,
  Container,
  Tabs,
  Tab,
  TextField,
  Button,
  Select,
  MenuItem,
  FormControl,
  InputLabel,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Paper,
  Grid,
  OutlinedInput,
  Checkbox,
  ListItemText,
  Tooltip,
  TablePagination,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Stepper,
  Step,
  StepLabel,
} = MaterialUI;

// 共通のウィザードモーダルコンポーネント
const WizardModal = memo(({ 
  open, 
  onClose, 
  title, 
  steps, 
  activeStep, 
  handleNext, 
  handleBack, 
  handleFinish, 
  children,
  nextDisabled  // 追加
}) => {
  return (
    <Dialog open={open} onClose={onClose} maxWidth="sm" fullWidth>
      <DialogTitle>{title}</DialogTitle>
      <DialogContent>
        <Stepper activeStep={activeStep} sx={{ py: 3 }}>
          {steps.map((label) => (
            <Step key={label}>
              <StepLabel>{label}</StepLabel>
            </Step>
          ))}
        </Stepper>
        {children}
      </DialogContent>
      <DialogActions>
        <Button onClick={onClose}>キャンセル</Button>
        {activeStep > 0 && (
          <Button onClick={handleBack}>戻る</Button>
        )}
        {activeStep < steps.length - 1 ? (
          <Button 
            onClick={handleNext} 
            variant="contained"
            disabled={nextDisabled}  // 追加
          >
            次へ
          </Button>
        ) : (
          <Button 
            onClick={handleFinish} 
            variant="contained" 
            color="primary"
            disabled={nextDisabled}  // 追加
          >
            完了
          </Button>
        )}
      </DialogActions>
    </Dialog>
  );
});

// カテゴリ追加ウィザードを修正
const CategoryWizard = memo(({ open, onClose, onAdd, categories }) => {
  const [activeStep, setActiveStep] = useState(0);
  const [formData, setFormData] = useState({ name: '' });
  
  const steps = ['カテゴリ名入力', '確認'];

  const handleNext = () => setActiveStep(prev => prev + 1);
  const handleBack = () => setActiveStep(prev => prev - 1);
  const handleFinish = () => {
    // 重複チェック
    if (categories.some(c => c.name === formData.name.trim())) {
      alert('同じ名前のカテゴリが既に存在します');
      return;
    }
    onAdd(formData);
    onClose();
  };

  return (
    <WizardModal
      open={open}
      onClose={onClose}
      title="カテゴリ追加"
      steps={steps}
      activeStep={activeStep}
      handleNext={handleNext}
      handleBack={handleBack}
      handleFinish={handleFinish}
    >
      {activeStep === 0 ? (
        <EditableTextField
          label="カテゴリ名"
          value={formData.name}
          onChange={value => setFormData(prev => ({ ...prev, name: value }))}
          fullWidth
          autoFocus
        />
      ) : (
        <Box>
          <Typography variant="subtitle1">以下の内容で登録します:</Typography>
          <Typography>カテゴリ名: {formData.name}</Typography>
        </Box>
      )}
    </WizardModal>
  );
});

// 構造追加ウィザードを修正
const StructureWizard = memo(({ open, onClose, onAdd, categories, properties, structures }) => {
  const [activeStep, setActiveStep] = useState(0);
  const [formData, setFormData] = useState({
    name: '',
    categoryId: '',
    propertyIds: []  // 追加：関連付けるプロパティのID配列
  });
  
  const steps = ['基本情報入力', 'カテゴリ選択', 'プロパティ選択', '確認'];  // ステップ追加

  const handleNext = () => setActiveStep(prev => prev + 1);
  const handleBack = () => setActiveStep(prev => prev - 1);
  const handleFinish = () => {
    // 重複チェック
    if (structures.some(s => s.name === formData.name.trim())) {
      alert('同じ名前の構造が既に存在します');
      return;
    }
    onAdd(formData);
    onClose();
  };

  const getStepContent = (step) => {
    switch (step) {
      case 0:
        return (
          <EditableTextField
            label="構造名"
            value={formData.name}
            onChange={value => setFormData(prev => ({ ...prev, name: value }))}
            fullWidth
            autoFocus
          />
        );
      case 1:
        return (
          <FormControl fullWidth>
            <InputLabel>カテゴリ</InputLabel>
            <Select
              value={formData.categoryId}
              onChange={e => setFormData(prev => ({ ...prev, categoryId: e.target.value }))}
            >
              {categories.map(cat => (
                <MenuItem key={cat.id} value={cat.id}>{cat.name}</MenuItem>
              ))}
            </Select>
          </FormControl>
        );
      case 2:  // 新規追加：プロパティ選択ステップ
        return (
          <FormControl fullWidth>
            <InputLabel>関連付けるプロパティ</InputLabel>
            <Select
              multiple
              value={formData.propertyIds}
              onChange={e => setFormData(prev => ({ ...prev, propertyIds: e.target.value }))}
              input={<OutlinedInput />}
              renderValue={selected => {
                return selected
                  .map(id => properties.find(p => p.id === id)?.name || '?')
                  .join(', ');
              }}
            >
              {properties.map(prop => (
                <MenuItem key={prop.id} value={prop.id}>
                  <Checkbox checked={formData.propertyIds.indexOf(prop.id) > -1} />
                  <ListItemText primary={prop.name} />
                </MenuItem>
              ))}
            </Select>
          </FormControl>
        );
      case 3:
        const selectedCategory = categories.find(c => c.id === formData.categoryId);
        const selectedProperties = formData.propertyIds
          .map(id => properties.find(p => p.id === id)?.name || '?')
          .join(', ');
        return (
          <Box>
            <Typography variant="subtitle1">以下の内容で登録します:</Typography>
            <Typography>構造名: {formData.name}</Typography>
            <Typography>カテゴリ: {selectedCategory ? selectedCategory.name : '未選択'}</Typography>
            <Typography>関連プロパティ: {selectedProperties}</Typography>
          </Box>
        );
      default:
        return null;
    }
  };

  return (
    <WizardModal
      open={open}
      onClose={onClose}
      title="構造追加"
      steps={steps}
      activeStep={activeStep}
      handleNext={handleNext}
      handleBack={handleBack}
      handleFinish={handleFinish}
    >
      {getStepContent(activeStep)}
    </WizardModal>
  );
});

// 構造編集モーダルコンポーネントを追加
const StructureEditModal = memo(({ 
  open, 
  onClose, 
  structure,
  onSave,
  categories,
  properties 
}) => {
  const [formData, setFormData] = useState({ 
    name: '', 
    categoryId: '',
    propertyIds: []  // 関連付けるプロパティのID配列
  });

  // 構造データが変更されたらフォームを更新
  useEffect(() => {
    if (structure) {
      setFormData({
        name: structure.name,
        categoryId: structure.categoryId,
        propertyIds: properties
          .filter(p => p.structureIds.includes(structure.id))
          .map(p => p.id)
      });
    }
  }, [structure, properties]);

  const handleSave = () => {
    if (formData.name.trim() === '' || !formData.categoryId) {
      alert('名前とカテゴリを選択してください');
      return;
    }
    onSave(formData);
    onClose();
  };

  return (
    <Dialog open={open} onClose={onClose} maxWidth="sm" fullWidth>
      <DialogTitle>構造編集</DialogTitle>
      <DialogContent>
        <Box sx={{ pt: 2 }}>
          <TextField
            label="構造名"
            value={formData.name}
            onChange={e => setFormData(prev => ({ ...prev, name: e.target.value }))}
            fullWidth
            sx={{ mb: 2 }}
          />
          <FormControl fullWidth>
            <InputLabel>カテゴリ</InputLabel>
            <Select
              value={formData.categoryId}
              onChange={e => setFormData(prev => ({ ...prev, categoryId: e.target.value }))}
            >
              {categories.map(cat => (
                <MenuItem key={cat.id} value={cat.id}>{cat.name}</MenuItem>
              ))}
            </Select>
          </FormControl>
          <FormControl fullWidth sx={{ mt: 2 }}>
            <InputLabel>関連付けるプロパティ</InputLabel>
            <Select
              multiple
              value={formData.propertyIds}
              onChange={e => setFormData(prev => ({ ...prev, propertyIds: e.target.value }))}
              input={<OutlinedInput />}
              renderValue={selected => {
                return selected
                  .map(id => properties.find(p => p.id === id)?.name || '?')
                  .join(', ');
              }}
            >
              {properties.map(prop => (
                <MenuItem key={prop.id} value={prop.id}>
                  <Checkbox checked={formData.propertyIds.indexOf(prop.id) > -1} />
                  <ListItemText primary={prop.name} />
                </MenuItem>
              ))}
            </Select>
          </FormControl>
        </Box>
      </DialogContent>
      <DialogActions>
        <Button onClick={onClose}>キャンセル</Button>
        <Button onClick={handleSave} variant="contained">保存</Button>
      </DialogActions>
    </Dialog>
  );
});

// プロパティ追加ウィザードを修正
const PropertyWizard = memo(({ open, onClose, onAdd, structures, properties }) => {
  const [activeStep, setActiveStep] = useState(0);
  const [formData, setFormData] = useState({ name: '', structureIds: [] });
  
  const steps = ['プロパティ名入力', '構造の選択', '確認'];

  const handleNext = () => setActiveStep(prev => prev + 1);
  const handleBack = () => setActiveStep(prev => prev - 1);
  const handleFinish = () => {
    // 重複チェック
    if (properties.some(p => p.name === formData.name.trim())) {
      alert('同じ名前のプロパティが既に存在します');
      return;
    }
    onAdd(formData);
    onClose();
  };

  const getStepContent = (step) => {
    switch (step) {
      case 0:
        return (
          <EditableTextField
            label="プロパティ名"
            value={formData.name}
            onChange={value => setFormData(prev => ({ ...prev, name: value }))}
            fullWidth
            autoFocus
          />
        );
      case 1:
        return (
          <FormControl fullWidth>
            <InputLabel>紐づける構造</InputLabel>
            <Select
              multiple
              value={formData.structureIds}
              onChange={e => setFormData(prev => ({ ...prev, structureIds: e.target.value }))}
              input={<OutlinedInput />}
              renderValue={selected => {
                return selected
                  .map(id => structures.find(s => s.id === id)?.name || '?')
                  .join(', ');
              }}
            >
              {structures.map(str => (
                <MenuItem key={str.id} value={str.id}>
                  <Checkbox checked={formData.structureIds.indexOf(str.id) > -1} />
                  <ListItemText primary={str.name} />
                </MenuItem>
              ))}
            </Select>
          </FormControl>
        );
      case 2:
        const selectedStructures = formData.structureIds
          .map(id => structures.find(s => s.id === id)?.name || '?')
          .join(', ');
        return (
          <Box>
            <Typography variant="subtitle1">以下の内容で登録します:</Typography>
            <Typography>プロパティ名: {formData.name}</Typography>
            <Typography>紐づける構造: {selectedStructures}</Typography>
          </Box>
        );
      default:
        return null;
    }
  };

  return (
    <WizardModal
      open={open}
      onClose={onClose}
      title="プロパティ追加"
      steps={steps}
      activeStep={activeStep}
      handleNext={handleNext}
      handleBack={handleBack}
      handleFinish={handleFinish}
    >
      {getStepContent(activeStep)}
    </WizardModal>
  );
});

// データ登録ウィザードコンポーネントを追加
const DataRecordWizard = memo(({ 
  open, 
  onClose, 
  onAdd, 
  structures, 
  properties,
  dataRecords  // 重複チェック用
}) => {
  const [activeStep, setActiveStep] = useState(0);
  const [formData, setFormData] = useState({
    structureId: '',
    values: {}
  });
  
  const steps = ['構造選択', 'プロパティ入力', '確認'];

  const handleNext = () => setActiveStep(prev => prev + 1);
  const handleBack = () => setActiveStep(prev => prev - 1);
  const handleFinish = () => {
    onAdd(formData);
    onClose();
    setActiveStep(0);
    setFormData({ structureId: '', values: {} });
  };

  // 選択された構造に紐づくプロパティを取得
  const relatedProperties = useMemo(() => {
    if (!formData.structureId) return [];
    return properties.filter(p => 
      p.structureIds.includes(parseInt(formData.structureId))
    );
  }, [formData.structureId, properties]);

  const getStepContent = (step) => {
    switch (step) {
      case 0:
        return (
          <FormControl fullWidth>
            <InputLabel>構造</InputLabel>
            <Select
              value={formData.structureId}
              onChange={(e) => setFormData(prev => ({ 
                ...prev, 
                structureId: e.target.value,
                values: {}  // 構造変更時は値をクリア
              }))}
            >
              <MenuItem value="">
                <em>選択してください</em>
              </MenuItem>
              {structures.map(str => (
                <MenuItem key={str.id} value={str.id}>
                  {str.name}
                </MenuItem>
              ))}
            </Select>
          </FormControl>
        );
      case 1:
        return (
          <Box>
            {relatedProperties.map(prop => (
              <TextField
                key={prop.id}
                label={prop.name}
                value={formData.values[prop.id] || ''}
                onChange={(e) => setFormData(prev => ({
                  ...prev,
                  values: {
                    ...prev.values,
                    [prop.id]: e.target.value
                  }
                }))}
                fullWidth
                sx={{ mb: 2 }}
              />
            ))}
          </Box>
        );
      case 2:
        const selectedStructure = structures.find(s => s.id === parseInt(formData.structureId));
        return (
          <Box>
            <Typography variant="subtitle1">以下の内容で登録します:</Typography>
            <Typography>構造: {selectedStructure?.name || '未選択'}</Typography>
            <Typography>プロパティ:</Typography>
            {Object.entries(formData.values).map(([propId, value]) => {
              const prop = properties.find(p => p.id === parseInt(propId));
              return (
                <Box key={propId} sx={{ pl: 2 }}>
                  <Typography>
                    {prop?.name || '不明'}: {value}
                  </Typography>
                </Box>
              );
            })}
          </Box>
        );
      default:
        return null;
    }
  };

  // 次へボタンの有効/無効制御
  const isNextEnabled = () => {
    switch (activeStep) {
      case 0:
        return !!formData.structureId;
      case 1:
        return relatedProperties.some(p => formData.values[p.id]);
      default:
        return true;
    }
  };

  return (
    <WizardModal
      open={open}
      onClose={onClose}
      title="データ登録"
      steps={steps}
      activeStep={activeStep}
      handleNext={handleNext}
      handleBack={handleBack}
      handleFinish={handleFinish}
      nextDisabled={!isNextEnabled()}
    >
      {getStepContent(activeStep)}
    </WizardModal>
  );
});

/*---------------------------------------------------------
  1) AppBar / Footer
---------------------------------------------------------*/
const AppBarComponent = () => (
  <AppBar position="static">
    <Toolbar>
      <Typography variant="h6" component="div" sx={{ flexGrow: 1 }}>
        データ管理システム
      </Typography>
    </Toolbar>
  </AppBar>
);

const FooterComponent = () => (
  <Box
    component="footer"
    sx={{
      backgroundColor: '#f5f5f5',
      py: 2,
      textAlign: 'center',
      marginTop: 'auto',
    }}
  >
    <Typography variant="body2" color="textSecondary">
      © 2024 データ管理システム. All rights reserved.
    </Typography>
  </Box>
);

/*---------------------------------------------------------
  2) CSV/SQL入出力用のユーティリティ
---------------------------------------------------------*/

// CSVエクスポート (Papa.unparse)
function exportCsv(filename, headers, rows) {
  const dataArray = [];
  dataArray.push(headers);
  rows.forEach(rowObj => {
    const line = headers.map(h => rowObj[h]);
    dataArray.push(line);
  });
  const csvText = Papa.unparse(dataArray);
  const blob = new Blob([csvText], {type:'text/csv;charset=utf-8;'});
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
}

// CSVインポート (Papa.parse)
function importCsv(file, onImported) {
  Papa.parse(file, {
    complete: function(results) {
      const data = results.data;
      if(!data || data.length<2) return;
      const headers = data[0];
      const body = data.slice(1);
      const rowObjects = body.map(rowArr => {
        const obj = {};
        headers.forEach((h,i) => {
          obj[h] = rowArr[i] || '';
        });
        return obj;
      });
      onImported(rowObjects, headers);
    }
  });
}

// SQL出力 (INSERT文)
function exportSql(filename, tableName, headers, rows) {
  let sql = '';
  rows.forEach(r => {
    const colNames = headers.join(', ');
    const values = headers.map(h => {
      const val = (r[h]||'').toString().replace(/'/g,"''");
      return `'${val}'`;
    }).join(', ');
    sql += `INSERT INTO ${tableName} (${colNames}) VALUES (${values});\n`;
  });
  const blob = new Blob([sql], {type:'text/sql;charset=utf-8;'});
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
}

/*---------------------------------------------------------
  3) Chart.jsビジュアライズ
---------------------------------------------------------*/
const DataVisualization = ({
  categories,
  structures,
  properties,
  dataRecords,
  filters,
  setFilters
}) => {
  const [vizTab, setVizTab] = useState(0);
  const [chartType, setChartType] = useState('bar');
  const chartRef = useRef(null);
  const chartInstance = useRef(null);

  const handleVizTabChange = useCallback((event, newValue) => setVizTab(newValue), []);
  const handleFilterChange = useCallback((e) => {
    const { name, value } = e.target;
    setFilters(prev => ({ ...prev, [name]: value }));
  }, [setFilters]);
  const handleChartTypeChange = useCallback((e) => setChartType(e.target.value), []);

  // フィルター用の状態を追加
  const [propertyFilter, setPropertyFilter] = useState('');
  const [keywordFilter, setKeywordFilter] = useState('');

  // フィルター適用済みのデータを取得
  const getFilteredData = useCallback(() => {
    let filteredStructures = structures;
    let filteredRecords = dataRecords;
    let filteredProperties = properties;

    // カテゴリでフィルター
    if (filters.categoryId) {
      filteredStructures = structures.filter(s => s.categoryId === parseInt(filters.categoryId));
      const strIds = filteredStructures.map(s => s.id);
      filteredRecords = dataRecords.filter(r => strIds.includes(r.structureId));
      
      // プロパティもフィルター（選択されたカテゴリの構造に紐づくもののみ）
      const relevantPropIds = new Set();
      filteredStructures.forEach(str => {
        properties.forEach(prop => {
          if (prop.structureIds.includes(str.id)) {
            relevantPropIds.add(prop.id);
          }
        });
      });
      filteredProperties = properties.filter(p => relevantPropIds.has(p.id));
    }
    
    // 構造でフィルター
    if (filters.structureId) {
      filteredStructures = filteredStructures.filter(s => s.id === parseInt(filters.structureId));
      filteredRecords = filteredRecords.filter(r => r.structureId === parseInt(filters.structureId));
      
      // プロパティもフィルター（選択された構造に紐づくもののみ）
      filteredProperties = filteredProperties.filter(p => 
        p.structureIds.includes(parseInt(filters.structureId))
      );
    }

    // プロパティでフィルター
    if (propertyFilter) {
      const propId = parseInt(propertyFilter);
      filteredRecords = filteredRecords.filter(r => r.values[propId] !== undefined);
    }

    // フリーワードでフィルター
    if (keywordFilter) {
      filteredRecords = filteredRecords.filter(r => {
        // レコードの全値を検索対象とする
        const values = Object.values(r.values).join(' ').toLowerCase();
        return values.includes(keywordFilter.toLowerCase());
      });
    }

    return { filteredStructures, filteredRecords, filteredProperties };
  }, [filters, propertyFilter, keywordFilter, structures, properties, dataRecords]);

  useEffect(() => {
    if(!chartRef.current) return;
    const ctx = chartRef.current.getContext('2d');
    if(chartInstance.current) {
      chartInstance.current.destroy();
    }

    const { filteredStructures, filteredRecords, filteredProperties } = getFilteredData();
    
    let labels = [];
    let data = [];
    let backgroundColors = [];

    switch(vizTab) {
      case 0: // 概要
        labels = ['カテゴリ','構造','プロパティ','データ'];
        data = [
          filters.categoryId ? 1 : categories.length, 
          filteredStructures.length,
          properties.length,
          filteredRecords.length
        ];
        backgroundColors = ['#4CAF50','#2196F3','#FFC107','#F44336'];
        break;
        
      case 1: // カテゴリ別
        if (filters.categoryId) {
          // 単一カテゴリの場合はその配下の構造数を表示
          const cat = categories.find(c => c.id === parseInt(filters.categoryId));
          if (cat) {
            labels = [cat.name];
            data = [filteredStructures.length];
            backgroundColors = ['#2196F3'];
          }
        } else {
          // 全カテゴリの場合は従来通り
          labels = categories.map(c => c.name);
          data = categories.map(c => {
            return structures.filter(s => s.categoryId === c.id).length;
          });
          backgroundColors = categories.map(() => '#2196F3');
        }
        break;
        
      case 2: // 構造別
        labels = filteredStructures.map(s => s.name);
        data = filteredStructures.map(s => {
          return filteredRecords.filter(r => r.structureId === s.id).length;
        });
        backgroundColors = filteredStructures.map(() => '#FFC107');
        break;
        
      case 3: // プロパティ別
        // フィルターされた構造に紐づくプロパティのみを表示
        const relevantPropIds = new Set();
        filteredStructures.forEach(str => {
          properties.forEach(prop => {
            if (prop.structureIds.includes(str.id)) {
              relevantPropIds.add(prop.id);
            }
          });
        });
        
        const filteredProps = properties.filter(p => relevantPropIds.has(p.id));
        
        labels = filteredProps.map(p => p.name);
        data = filteredProps.map(p => {
          return filteredRecords.filter(r => r.values[p.id]).length;
        });
        backgroundColors = filteredProps.map(() => '#F44336');
        break;
        
      default:
        break;
    }

    chartInstance.current = new Chart(ctx, {
      type: chartType,
      data: {
        labels,
        datasets: [{
          label: 'データ数',
          data,
          backgroundColor: backgroundColors
        }]
      },
      options: {
        responsive: true,
        plugins: {
          legend: { display: false },
          title: {
            display: true,
            text: filters.categoryId || filters.structureId ? 'フィルター適用中' : '全データ',
            color: '#666'
          }
        }
      }
    });
  }, [vizTab, chartType, filters, propertyFilter, keywordFilter, categories, structures, properties, dataRecords, getFilteredData]);

  return (
    <Box my={3}>
      <Typography variant="h6" gutterBottom>データ参照</Typography>
      <canvas ref={chartRef}></canvas>

      <Box mt={4}>
        <Typography variant="h6" gutterBottom>ビジュアライズ</Typography>
        <Tabs
          value={vizTab}
          onChange={handleVizTabChange}
          textColor="primary"
          indicatorColor="primary"
        >
          <Tab label="概要グラフ" />
          <Tab label="カテゴリ別グラフ" />
          <Tab label="構造別グラフ" />
          <Tab label="プロパティ別グラフ" />
        </Tabs>

        <Box mt={2}>
          <Grid container spacing={2}>
            <Grid item xs={6} sm={3} md={2}>
              <FormControl fullWidth>
                <InputLabel>カテゴリ</InputLabel>
                <Select
                  name="categoryId"
                  value={filters.categoryId}
                  onChange={handleFilterChange}
                >
                  <MenuItem value="">
                    <em>すべて</em>
                  </MenuItem>
                  {categories.map(cat=>(
                    <MenuItem key={cat.id} value={cat.id}>{cat.name}</MenuItem>
                  ))}
                </Select>
              </FormControl>
            </Grid>
            <Grid item xs={6} sm={3} md={2}>
              <FormControl fullWidth>
                <InputLabel>構造</InputLabel>
                <Select
                  name="structureId"
                  value={filters.structureId}
                  onChange={handleFilterChange}
                  disabled={!filters.categoryId}
                >
                  <MenuItem value="">
                    <em>すべて</em>
                  </MenuItem>
                  {structures
                    .filter(s=> !filters.categoryId || s.categoryId===parseInt(filters.categoryId))
                    .map(s=>(
                      <MenuItem key={s.id} value={s.id}>{s.name}</MenuItem>
                    ))}
                </Select>
              </FormControl>
            </Grid>
            <Grid item xs={6} sm={3} md={2}>
              <FormControl fullWidth>
                <InputLabel>プロパティ</InputLabel>
                <Select
                  value={propertyFilter}
                  onChange={(e) => setPropertyFilter(e.target.value)}
                >
                  <MenuItem value="">
                    <em>すべて</em>
                  </MenuItem>
                  {properties
                    .filter(p => !filters.structureId || 
                      p.structureIds.includes(parseInt(filters.structureId)))
                    .map(p => (
                      <MenuItem key={p.id} value={p.id}>{p.name}</MenuItem>
                    ))}
                </Select>
              </FormControl>
            </Grid>
            <Grid item xs={6} sm={3} md={2}>
              <TextField
                fullWidth
                label="フリーワード検索"
                value={keywordFilter}
                onChange={(e) => setKeywordFilter(e.target.value)}
                placeholder="値で検索..."
              />
            </Grid>
            <Grid item xs={6} sm={3} md={2}>
              <FormControl fullWidth>
                <InputLabel>グラフの種類</InputLabel>
                <Select
                  value={chartType}
                  onChange={handleChartTypeChange}
                >
                  <MenuItem value="bar">バーグラフ</MenuItem>
                  <MenuItem value="line">ラインチャート</MenuItem>
                  <MenuItem value="pie">円グラフ</MenuItem>
                  <MenuItem value="doughnut">ドーナツ</MenuItem>
                  <MenuItem value="radar">レーダー</MenuItem>
                  <MenuItem value="polarArea">ポーラー</MenuItem>
                </Select>
              </FormControl>
            </Grid>
            <Grid item xs={6} sm={3} md={2}>
              <Button 
                fullWidth 
                variant="outlined" 
                onClick={() => {
                  setPropertyFilter('');
                  setKeywordFilter('');
                  setFilters({ categoryId: '', structureId: '' });
                }}
              >
                フィルターをクリア
              </Button>
            </Grid>
          </Grid>
        </Box>
      </Box>
    </Box>
  );
};

/*---------------------------------------------------------
  4) ページネーション用フック
---------------------------------------------------------*/
function usePagination(allRows) {
  const [page, setPage] = useState(0);
  const [rowsPerPage, setRowsPerPage] = useState(10);

  const handleChangePage = useCallback((event, newPage) => setPage(newPage), []);
  const handleChangeRowsPerPage = useCallback((event) => {
    const val = parseInt(event.target.value, 10);
    setRowsPerPage(val);
    setPage(0);
  }, []);

  let pagedRows = [];
  if(rowsPerPage===-1) {
    pagedRows = allRows;
  } else {
    const start = page*rowsPerPage;
    const end = start+rowsPerPage;
    pagedRows = allRows.slice(start, end);
  }

  return {
    page,
    rowsPerPage,
    handleChangePage,
    handleChangeRowsPerPage,
    pagedRows
  };
}

/*---------------------------------------------------------
  5) DataManagement (6タブ)
---------------------------------------------------------*/

// カテゴリ行コンポーネント
const CategoryRow = memo(({ 
  cat, 
  editObj, 
  setEditingCategories, 
  saveEditCategory,
  startEditCategory,  // 追加
  structures  // 追加
}) => {
  const handleNameChange = useCallback((newValue) => {
    setEditingCategories(prev => ({
      ...prev,
      [cat.id]: { ...editObj, name: newValue }
    }));
  }, [cat.id, editObj, setEditingCategories]);

  return (
    <TableRow key={cat.id}>
      <TableCell>{cat.id}</TableCell>
      <TableCell>
        {editObj?.isEditing ? (
          <EditableTextField
            value={editObj.name}
            onChange={handleNameChange}
          />
        ) : (
          cat.name
        )}
      </TableCell>
      <TableCell>
        {/* 関連構造列を追加 */}
        {structures
          .filter(s => s.categoryId === cat.id)
          .map(s => s.name)
          .join(', ')}
      </TableCell>
      <TableCell>
        {editObj?.isEditing ? (
          <Button variant="contained" onClick={() => saveEditCategory(cat.id)}>
            保存
          </Button>
        ) : (
          <Button variant="contained" onClick={() => startEditCategory(cat.id, cat.name)}>
            編集
          </Button>
        )}
      </TableCell>
    </TableRow>
  );
});

// 構造行コンポーネント
const StructureRow = memo(({ 
  str, 
  editObj, 
  setEditingStructures, 
  saveEditStructure,
  startEditStructure,  // 追加
  categories,
  properties  // 追加
}) => {
  const handleNameChange = useCallback((value) => {
    setEditingStructures(prev => ({
      ...prev,
      [str.id]: { ...editObj, name: value }
    }));
  }, [setEditingStructures, str.id, editObj]);

  const handleCategoryChange = useCallback((value) => {
    setEditingStructures(prev => ({
      ...prev,
      [str.id]: { ...editObj, categoryId: value }
    }));
  }, [setEditingStructures, str.id, editObj]);

  return (
    <TableRow key={str.id}>
      <TableCell>{str.id}</TableCell>
      <TableCell>
        {editObj?.isEditing ? (
          <EditableTextField
            value={editObj.name}
            onChange={handleNameChange}
          />
        ) : (
          str.name
        )}
      </TableCell>
      <TableCell>
        {editObj?.isEditing ? (
          <FormControl size="small">
            <Select
              value={editObj.categoryId}
              onChange={(e) => handleCategoryChange(e.target.value)}
              sx={{ width:120 }}
            >
              {categories.map(cat2=>(
                <MenuItem key={cat2.id} value={cat2.id}>{cat2.name}</MenuItem>
              ))}
            </Select>
          </FormControl>
        ) : (
          categories.find(c => c.id === str.categoryId)?.name || '未分類'
        )}
      </TableCell>
      <TableCell>
        {/* 関連プロパティ列を追加 */}
        {properties
          .filter(p => p.structureIds.includes(str.id))
          .map(p => p.name)
          .join(', ')}
      </TableCell>
      <TableCell>
        {editObj?.isEditing ? (
          <Button variant="contained" onClick={() => saveEditStructure(str.id)}>
            保存
          </Button>
        ) : (
          <Button variant="contained" onClick={() => startEditStructure(str.id, str.name, str.categoryId)}>
            編集
          </Button>
        )}
      </TableCell>
    </TableRow>
  );
});

// プロパティ行コンポーネント
const PropertyRow = memo(({ 
  prop, 
  editObj, 
  setEditingProperties, 
  saveEditProperty,
  startEditProperty,  // 追加
  structures 
}) => {
  const handleNameChange = useCallback((value) => {
    setEditingProperties(prev => ({
      ...prev,
      [prop.id]: { ...editObj, name: value }
    }));
  }, [setEditingProperties, prop.id, editObj]);

  const handleStructureChange = useCallback((value) => {
    setEditingProperties(prev => ({
      ...prev,
      [prop.id]: { ...editObj, structureIds: value }
    }));
  }, [setEditingProperties, prop.id, editObj]);

  return (
    <TableRow key={prop.id}>
      <TableCell>{prop.id}</TableCell>
      <TableCell>
        {editObj?.isEditing ? (
          <EditableTextField
            value={editObj.name}
            onChange={handleNameChange}
          />
        ) : (
          prop.name
        )}
      </TableCell>
      <TableCell>
        {editObj?.isEditing ? (
          <FormControl size="small">
            <Select
              multiple
              value={editObj.structureIds}
              onChange={(e) => handleStructureChange(e.target.value)}
              input={<OutlinedInput />}
              sx={{ width:200 }}
              renderValue={(selected)=>{
                return selected
                  .map(id=> structures.find(s=> s.id===id)?.name || '?')
                  .join(', ');
              }}
            >
              {structures.map(s=>(
                <MenuItem key={s.id} value={s.id}>
                  <Checkbox checked={editObj.structureIds.indexOf(s.id)>-1} />
                  <ListItemText primary={s.name} />
                </MenuItem>
              ))}
            </Select>
          </FormControl>
        ) : (
          prop.structureIds
            .map(sid=> structures.find(s=> s.id===sid)?.name || '?')
            .join(', ')
        )}
      </TableCell>
      <TableCell>
        {editObj?.isEditing ? (
          <Button variant="contained" onClick={() => saveEditProperty(prop.id)}>
            保存
          </Button>
        ) : (
          <Button variant="contained" onClick={() => startEditProperty(prop.id, prop.name, prop.structureIds)}>
            編集
          </Button>
        )}
      </TableCell>
    </TableRow>
  );
});

// データレコード行コンポーネント
const DataRecordRow = memo(({ 
  rec, 
  structures, 
  properties, 
  editObj, 
  setEditingDataRecords, 
  saveEditDataRecord,
  startEditDataRecord  // 追加
}) => {
  const handleStructureChange = useCallback((newStrId) => {
    setEditingDataRecords(prev => ({
      ...prev,
      [rec.id]: {
        ...prev[rec.id],
        structureId: parseInt(newStrId, 10),
        values: {}
      }
    }));
  }, [setEditingDataRecords, rec.id]);

  const handleValueChange = useCallback((propId, newVal) => {
    setEditingDataRecords(prev => ({
      ...prev,
      [rec.id]: {
        ...prev[rec.id],
        values: {
          [propId]: newVal
        }
      }
    }));
  }, [setEditingDataRecords, rec.id]);

  const structure = structures.find(s => s.id === rec.structureId);

  return (
    <TableRow key={rec.id}>
      <TableCell>{rec.id}</TableCell>
      <TableCell>
        {editObj?.isEditing ? (
          <FormControl size="small">
            <Select
              value={editObj.structureId}
              onChange={(e) => handleStructureChange(e.target.value)}
              sx={{ width:130 }}
            >
              {structures.map(s=>(
                <MenuItem key={s.id} value={s.id}>{s.name}</MenuItem>
              ))}
            </Select>
          </FormControl>
        ) : (
          structure ? structure.name : '未分類'
        )}
      </TableCell>
      <TableCell>
        {editObj?.isEditing ? (
          (() => {
            const stId = editObj.structureId;
            const targetProps = properties.filter(p=> p.structureIds.includes(stId));
            return (
              <Box>
                {targetProps.map(tp => (
                  <EditableTextField
                    key={tp.id}
                    label={tp.name}
                    value={editObj.values[tp.id] || ''}
                    onChange={value => handleValueChange(tp.id, value)}
                    size="small"
                    sx={{ mt:1, mr:1, width:100 }}
                  />
                ))}
              </Box>
            );
          })()
        ) : (
          // 編集モードでない場合はJSON文字列を表示
          JSON.stringify(rec.values)
        )}
      </TableCell>
      <TableCell>
        {editObj?.isEditing ? (
          <Button variant="contained" onClick={() => saveEditDataRecord(rec.id)}>
            保存
          </Button>
        ) : (
          <Button variant="contained" onClick={() => startEditDataRecord(rec)}>
            編集
          </Button>
        )}
      </TableCell>
    </TableRow>
  );
});

const DataManagement = memo(({
  categories, setCategories,
  structures, setStructures,
  properties, setProperties,
  dataRecords, setDataRecords,
  filters
}) => {
  const [tabValue, setTabValue] = useState(0);

  // 新規追加用 State
  const [newCategory, setNewCategory] = useState('');
  const [newStructure, setNewStructure] = useState({ name:'', categoryId:'' });
  const [newProperty, setNewProperty] = useState({ name:'', structureIds:[] });
  const [newData, setNewData] = useState({ structureId:'', values:{} });

  // 編集用
  const [editingCategories, setEditingCategories] = useState({});
  const [editingStructures, setEditingStructures] = useState({});
  const [editingProperties, setEditingProperties] = useState({});
  const [editingDataRecords, setEditingDataRecords] = useState({});

  // CSV/SQLインポート用
  const fileInputRef = useRef(null);

  // ---- フィルター用 State ----
  const [categoryFilter, setCategoryFilter] = useState({ id:'', name:'', structure:'' }); // 追加: structure
  const [structureFilter, setStructureFilter] = useState({ id:'', name:'', category:'', property:'' }); // 追加: property
  const [propertyFilter, setPropertyFilter] = useState({ id:'', name:'', link:'' });
  const [dataFilter, setDataFilter] = useState({ id:'', structureId:'', values:'' });

  // フィルター更新をメモ化
  const handleCategoryFilterChange = useCallback((field, value) => {
    setCategoryFilter(prev => ({ ...prev, [field]: value }));
  }, []);

  const handleStructureFilterChange = useCallback((field, value) => {
    setStructureFilter(prev => ({ ...prev, [field]: value }));
  }, []);

  const handlePropertyFilterChange = useCallback((field, value) => {
    setPropertyFilter(prev => ({ ...prev, [field]: value }));
  }, []);

  const handleDataFilterChange = useCallback((field, value) => {
    setDataFilter(prev => ({ ...prev, [field]: value }));
  }, []);

  /* -------------------------------------------
   *   CSVインポート/エクスポート/SQL出力
   * ------------------------------------------- */
  const handleImportCsvClick = useCallback((tableName) => {
    fileInputRef.current.onchange = (evt) => {
      const file = evt.target.files[0];
      if(!file) return;
      importCsv(file, (rowObjects, headers) => {
        switch(tableName){
          case 'categories':
            setCategories(rowObjects.map(d=>({
              id: parseInt(d.id||'0',10),
              name: d.name||''
            })));
            break;
          case 'structures':
            setStructures(rowObjects.map(d=>({
              id: parseInt(d.id||'0',10),
              name: d.name||'',
              categoryId: parseInt(d.categoryId||'0',10)
            })));
            break;
          case 'properties':
            setProperties(rowObjects.map(d=>({
              id: parseInt(d.id||'0',10),
              name: d.name||'',
              structureIds: (d.structureIds||'').split('|').map(x=>parseInt(x,10)).filter(n=>!isNaN(n))
            })));
            break;
          case 'dataRecords':
            setDataRecords(rowObjects.map(d=>({
              id: parseInt(d.id||'0',10),
              structureId: parseInt(d.structureId||'0',10),
              values: d.values ? JSON.parse(d.values) : {}
            })));
            break;
          default: break;
        }
      });
    };
    fileInputRef.current.click();
  }, [setCategories, setStructures, setProperties, setDataRecords]);

  const handleExportCsv = useCallback((tableName) => {
    switch(tableName){
      case 'categories':
        exportCsv('categories.csv',['id','name'], categories);
        break;
      case 'structures':
        exportCsv('structures.csv',['id','name','categoryId'], structures);
        break;
      case 'properties': {
        const propRows = properties.map(p=>({
          id: p.id,
          name: p.name,
          structureIds: p.structureIds.join('|')
        }));
        exportCsv('properties.csv',['id','name','structureIds'], propRows);
        break;
      }
      case 'dataRecords': {
        const dr = dataRecords.map(d=>({
          id: d.id,
          structureId: d.structureId,
          values: JSON.stringify(d.values)
        }));
        exportCsv('dataRecords.csv',['id','structureId','values'], dr);
        break;
      }
      default: break;
    }
  }, [categories, structures, properties, dataRecords]);

  const handleExportSql = useCallback((tableName) => {
    switch(tableName){
      case 'categories':
        exportSql('categories.sql','categories',['id','name'], categories);
        break;
      case 'structures':
        exportSql('structures.sql','structures',['id','name','categoryId'], structures);
        break;
      case 'properties': {
        const propRows = properties.map(p=>({
          id: p.id,
          name: p.name,
          structureIds: p.structureIds.join('|')
        }));
        exportSql('properties.sql','properties',['id','name','structureIds'], propRows);
        break;
      }
      case 'dataRecords': {
        const dr = dataRecords.map(d=>({
          id: d.id,
          structureId: d.structureId,
          values: JSON.stringify(d.values)
        }));
        exportSql('dataRecords.sql','dataRecords',['id','structureId','values'], dr);
        break;
      }
      default: break;
    }
  }, [categories, structures, properties, dataRecords]);

  /* -------------------------------------------
   *   新規追加
   * ------------------------------------------- */
  const addCategory = useCallback(() => {
    if(newCategory.trim()==='') return;
    const newId = categories.length > 0 ? Math.max(...categories.map(c => c.id)) + 1 : 1;
    setCategories([...categories, { id: newId, name:newCategory }]);
    setNewCategory('');
  }, [newCategory, categories, setCategories]);

  const addStructure = useCallback(() => {
    if(newStructure.name.trim()==='' || newStructure.categoryId==='') return;
    const newId = structures.length > 0 ? Math.max(...structures.map(s => s.id)) + 1 : 1;
    setStructures([...structures, {
      id: newId,
      ...newStructure
    }]);
    setNewStructure({ name:'', categoryId:'' });
  }, [newStructure, structures, setStructures]);

  const addProperty = useCallback(() => {
    if(newProperty.name.trim()==='' || newProperty.structureIds.length===0) return;
    const newId = properties.length > 0 ? Math.max(...properties.map(p => p.id)) + 1 : 1;
    setProperties([...properties, {
      id: newId,
      name: newProperty.name,
      structureIds: newProperty.structureIds
    }]);
    setNewProperty({ name:'', structureIds:[] });
  }, [newProperty, properties, setProperties]);

  const addData = useCallback(() => {
    if(newData.structureId==='') return;
    const newId = dataRecords.length > 0 ? Math.max(...dataRecords.map(r => r.id)) + 1 : 1;
    setDataRecords([...dataRecords, {
      id: newId,
      ...newData
    }]);
    setNewData({ structureId:'', values:{} });
  }, [newData, dataRecords, setDataRecords]);

  /* -------------------------------------------
   *   編集 (カテゴリ/構造/プロパティ/データ)
   * ------------------------------------------- */
  // カテゴリ
  const startEditCategory = useCallback((catId, curName) => {
    setEditingCategories(prev=>({
      ...prev,
      [catId]: { name:curName, isEditing:true }
    }));
  }, []);

  const saveEditCategory = useCallback((catId) => {
    const editObj = editingCategories[catId];
    if(!editObj) return;
    const updated = categories.map(c=> c.id===catId
      ? {...c, name:editObj.name}
      : c
    );
    setCategories(updated);
    setEditingCategories(prev=>({
      ...prev,
      [catId]: { ...editObj, isEditing:false }
    }));
  }, [editingCategories, categories, setCategories]);

  // 構造
  const startEditStructure = useCallback((strId, curName, curCatId) => {
    setEditingStructures(prev=>({
      ...prev,
      [strId]: { name:curName, categoryId:curCatId, isEditing:true }
    }));
  }, []);

  const saveEditStructure = useCallback((strId) => {
    const editObj = editingStructures[strId];
    if(!editObj) return;
    const updated = structures.map(s=> s.id===strId
      ? {...s, name:editObj.name, categoryId:editObj.categoryId}
      : s
    );
    setStructures(updated);
    setEditingStructures(prev=>({
      ...prev,
      [strId]: { ...editObj, isEditing:false }
    }));
  }, [editingStructures, structures, setStructures]);

  // プロパティ
  const startEditProperty = useCallback((propId, curName, curStrIds) => {
    setEditingProperties(prev=>({
      ...prev,
      [propId]: { name:curName, structureIds:curStrIds, isEditing:true }
    }));
  }, []);

  const saveEditProperty = useCallback((propId) => {
    const editObj = editingProperties[propId];
    if(!editObj) return;
    const updated = properties.map(p=> p.id===propId
      ? {...p, name:editObj.name, structureIds:editObj.structureIds}
      : p
    );
    setProperties(updated);
    setEditingProperties(prev=>({
      ...prev,
      [propId]: { ...editObj, isEditing:false }
    }));
  }, [editingProperties, properties, setProperties]);

  // データ
  const startEditDataRecord = useCallback((rec) => {
    setEditingDataRecords(prev=>({
      ...prev,
      [rec.id]: {
        structureId:rec.structureId,
        values:{...rec.values},
        isEditing:true
      }
    }));
  }, []);

  const saveEditDataRecord = useCallback((recId) => {
    const editObj = editingDataRecords[recId];
    if(!editObj) return;
    const updated = dataRecords.map(r=> r.id===recId
      ? {...r, structureId:editObj.structureId, values:editObj.values}
      : r
    );
    setDataRecords(updated);
    setEditingDataRecords(prev=>({
      ...prev,
      [recId]: { ...editObj, isEditing:false }
    }));
  }, [editingDataRecords, dataRecords, setDataRecords]);

  /* -------------------------------------------
   *   フィルタリング関数
   * ------------------------------------------- */
  const getFilteredCategories = useCallback(() => {
    return categories.filter(cat => {
      if (categoryFilter.id && !cat.id.toString().includes(categoryFilter.id)) {
        return false;
      }
      if (categoryFilter.name && !cat.name.includes(categoryFilter.name)) {
        return false;
      }
      // 関連する構造でフィルター
      if (categoryFilter.structure) {
        const relatedStructures = structures
          .filter(s => s.categoryId === cat.id)
          .map(s => s.name)
          .join(', ');
        if (!relatedStructures.toLowerCase().includes(categoryFilter.structure.toLowerCase())) {
          return false;
        }
      }
      return true;
    });
  }, [categories, categoryFilter, structures]);

  const getFilteredStructures = useCallback(() => {
    return structures.filter(str => {
      if (structureFilter.id && !str.id.toString().includes(structureFilter.id)) {
        return false;
      }
      if (structureFilter.name && !str.name.includes(structureFilter.name)) {
        return false;
      }
      if (structureFilter.category) {
        const cat = categories.find(c=> c.id===str.categoryId);
        const catName = cat ? cat.name : '';
        if (!catName.includes(structureFilter.category)) {
          return false;
        }
      }
      // 関連するプロパティでフィルター
      if (structureFilter.property) {
        const relatedProperties = properties
          .filter(p => p.structureIds.includes(str.id))
          .map(p => p.name)
          .join(', ');
        if (!relatedProperties.toLowerCase().includes(structureFilter.property.toLowerCase())) {
          return false;
        }
      }
      return true;
    });
  }, [structures, structureFilter, categories, properties]);

  const getFilteredProperties = useCallback(() => {
    return properties.filter(prop => {
      if (propertyFilter.id && !prop.id.toString().includes(propertyFilter.id)) {
        return false;
      }
      if (propertyFilter.name && !prop.name.includes(propertyFilter.name)) {
        return false;
      }
      if (propertyFilter.link) {
        // 紐づく構造名をカンマ区切りにして検索
        const linkedNames = prop.structureIds
          .map(sid => structures.find(s=>s.id===sid)?.name || '')
          .join(',');
        if (!linkedNames.includes(propertyFilter.link)) {
          return false;
        }
      }
      return true;
    });
  }, [properties, propertyFilter, structures]);

  const getFilteredDataRecords = useCallback(() => {
    return dataRecords.filter(rec => {
      if (dataFilter.id && !rec.id.toString().includes(dataFilter.id)) {
        return false;
      }
      if (dataFilter.structureId && !rec.structureId.toString().includes(dataFilter.structureId)) {
        return false;
      }
      if (dataFilter.values) {
        const valStr = JSON.stringify(rec.values);
        if (!valStr.includes(dataFilter.values)) {
          return false;
        }
      }
      return true;
    });
  }, [dataRecords, dataFilter]);

  // 関連レコードタブ用のフィルター (カテゴリID, 構造ID)
  const getFilteredData = useCallback(() => {
    let filtered = dataRecords;
    if(filters.categoryId) {
      const strIds = structures
        .filter(s=> s.categoryId===parseInt(filters.categoryId))
        .map(s=> s.id);
      filtered = filtered.filter(r=> strIds.includes(r.structureId));
    }
    if(filters.structureId) {
      filtered = filtered.filter(r=> r.structureId===parseInt(filters.structureId));
    }
    return filtered;
  }, [filters, dataRecords, structures]);

  /* -------------------------------------------
   *   タブコンポーネント
   * ------------------------------------------- */

  // 0) 関連レコードタブ
  const RelatedRecordsTab = memo(() => {
    const filtered = getFilteredData();
    const {
      page, rowsPerPage, handleChangePage, handleChangeRowsPerPage, pagedRows
    } = usePagination(filtered);

    // 構造が1種類だけのときは、その構造に紐づくプロパティを列として出す
    const distinctStrIds = [...new Set(filtered.map(r=>r.structureId))];
    const isSingleStr = (distinctStrIds.length===1);
    let singleStrProps = [];
    if(isSingleStr) {
      const strId = distinctStrIds[0];
      singleStrProps = properties
        .filter(p=> p.structureIds.includes(strId))
        .sort((a,b)=> a.id-b.id);
    }

    // 複数構造の場合は最大プロパティ数だけ列を作り、セルに値を詰めていく
    let maxPropCount = 0;
    filtered.forEach(r=>{
      const c = Object.keys(r.values).length;
      if(c>maxPropCount) {
        maxPropCount = c;
      }
    });
    const propNameMap = {};
    properties.forEach(p=> { propNameMap[p.id] = p.name; });

    return (
      <Box mt={2}>
        <Box sx={{ mb:2 }}>
          <Button
            variant="contained"
            onClick={()=>handleImportCsvClick('dataRecords')}
            sx={{ mr:1 }}
          >
            CSVインポート
          </Button>
          <Button
            variant="contained"
            onClick={()=>handleExportCsv('dataRecords')}
            sx={{ mr:1 }}
          >
            CSVエクスポート
          </Button>
          <Button
            variant="contained"
            onClick={()=>handleExportSql('dataRecords')}
          >
            SQL出力
          </Button>
        </Box>

        <Typography variant="h6" gutterBottom>関連するデータレコード一覧</Typography>
        <TableContainer component={Paper}>
          <Table className="custom-table" size="small">
            <TableHead>
              <TableRow>
                <TableCell>ID</TableCell>
                <TableCell>構造</TableCell>
                {isSingleStr ? (
                  singleStrProps.map(prop => (
                    <TableCell key={prop.id}>{prop.name}</TableCell>
                  ))
                ) : (
                  [...Array(maxPropCount).keys()].map(i=>{
                    const colIdx = i+1;
                    return <TableCell key={`col-${colIdx}`}>{colIdx}</TableCell>;
                  })
                )}
              </TableRow>
            </TableHead>
            <TableBody>
              {pagedRows.map(rec=>{
                const structure = structures.find(s=> s.id===rec.structureId);

                if(isSingleStr){
                  // 単一構造
                  return (
                    <TableRow key={rec.id}>
                      <TableCell>{rec.id}</TableCell>
                      <TableCell>{structure? structure.name : '未分類'}</TableCell>
                      {singleStrProps.map(prop=>{
                        const val = rec.values[prop.id] || '';
                        return <TableCell key={prop.id}>{val}</TableCell>;
                      })}
                    </TableRow>
                  );
                } else {
                  // 複数構造
                  const recPropIds = Object.keys(rec.values).map(n=> parseInt(n,10)).sort((a,b)=>a-b);
                  return (
                    <TableRow key={rec.id}>
                      <TableCell>{rec.id}</TableCell>
                      <TableCell>{structure? structure.name : '未分類'}</TableCell>
                      {[...Array(maxPropCount).keys()].map(i=>{
                        const propId = recPropIds[i];
                        if(propId===undefined) {
                          return <TableCell key={`empty-${i}`} />;
                        } else {
                          const val = rec.values[propId];
                          const tooltipTitle = propNameMap[propId] || '不明';
                          return (
                            <TableCell key={propId}>
                              <Tooltip title={tooltipTitle} arrow>
                                <span>{val}</span>
                              </Tooltip>
                            </TableCell>
                          );
                        }
                      })}
                    </TableRow>
                  );
                }
              })}
            </TableBody>
          </Table>
        </TableContainer>

        <TablePagination
          rowsPerPageOptions={[10,20,30,{label:'All',value:-1}]}
          component="div"
          count={filtered.length}
          rowsPerPage={rowsPerPage}
          page={page}
          onPageChange={handleChangePage}
          onRowsPerPageChange={handleChangeRowsPerPage}
          labelRowsPerPage="表示件数"
        />
      </Box>
    );
  });

  // 1) データ登録タブ
  const DataRegisterTab = memo(() => {
    const filteredDataRecords = getFilteredDataRecords();
    const pager = usePagination(filteredDataRecords);
    const [wizardOpen, setWizardOpen] = useState(false);

    // ウィザードからの追加処理
    const handleWizardAdd = useCallback((formData) => {
      if (!formData.structureId) return;

      const newId = dataRecords.length > 0 
        ? Math.max(...dataRecords.map(r => r.id)) + 1 
        : 1;

      setDataRecords(prev => [...prev, {
        id: newId,
        structureId: parseInt(formData.structureId),
        values: Object.fromEntries(
          Object.entries(formData.values)
            .map(([k, v]) => [parseInt(k), v])
        )
      }]);
    }, [dataRecords, setDataRecords]);

    return (
      <Box mt={2}>
        {/* ヘッダー部分にウィザード起動ボタンを配置 */}
        <Box display="flex" justifyContent="space-between" alignItems="center" mb={2}>
          <Typography variant="h6">データ管理</Typography>
          <Button
            variant="contained"
            color="primary"
            startIcon={<span className="material-icons">add</span>}
            onClick={() => setWizardOpen(true)}
          >
            新規データ登録
          </Button>
        </Box>

        {/* ウィザードモーダル */}
        <DataRecordWizard
          open={wizardOpen}
          onClose={() => setWizardOpen(false)}
          onAdd={handleWizardAdd}
          structures={structures}
          properties={properties}
          dataRecords={dataRecords}
        />

        {/* CSVインポート/エクスポート/SQL出力ボタン */}
        <Box sx={{ mb:2 }}>
          <Button variant="contained" onClick={()=>handleImportCsvClick('dataRecords')} sx={{ mr:1 }}>
            CSVインポート
          </Button>
          <Button variant="contained" onClick={()=>handleExportCsv('dataRecords')} sx={{ mr:1 }}>
            CSVエクスポート
          </Button>
          <Button variant="contained" onClick={()=>handleExportSql('dataRecords')}>
            SQL出力
          </Button>
        </Box>

        {/* データ一覧テーブル */}
        <Box mt={4}>
          <Typography variant="subtitle1" gutterBottom>データ一覧 (編集可)</Typography>
          <TableContainer component={Paper}>
            <Table className="custom-table" size="small">
              <TableHead>
                <TableRow>
                  <TableCell>
                    <FilterTextField
                      placeholder="IDでフィルタ"
                      value={dataFilter.id}
                      onChange={(value) => handleDataFilterChange('id', value)}
                    />
                  </TableCell>
                  <TableCell>
                    <FilterTextField
                      placeholder="構造IDでフィルタ"
                      value={dataFilter.structureId}
                      onChange={(value) => handleDataFilterChange('structureId', value)}
                    />
                  </TableCell>
                  <TableCell>
                    <FilterTextField
                      placeholder="プロパティ(JSON)内で検索"
                      value={dataFilter.values}
                      onChange={(value) => handleDataFilterChange('values', value)}
                    />
                  </TableCell>
                  <TableCell>操作</TableCell>
                </TableRow>
                <TableRow>
                  <TableCell>ID</TableCell>
                  <TableCell>構造</TableCell>
                  <TableCell>プロパティ(JSON)</TableCell>
                  <TableCell>操作</TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {pager.pagedRows.map(rec => {
                  const editObj = editingDataRecords[rec.id];
                  return (
                    <DataRecordRow
                      key={rec.id}
                      rec={rec}
                      structures={structures}
                      properties={properties}
                      editObj={editObj}
                      setEditingDataRecords={setEditingDataRecords}
                      saveEditDataRecord={saveEditDataRecord}
                      startEditDataRecord={startEditDataRecord}  // 追加
                    />
                  );
                })}
              </TableBody>
            </Table>
          </TableContainer>

          <TablePagination
            rowsPerPageOptions={[10,20,30,{label:'All',value:-1}]}
            component="div"
            count={filteredDataRecords.length}
            rowsPerPage={pager.rowsPerPage}
            page={pager.page}
            onPageChange={pager.handleChangePage}
            onRowsPerPageChange={pager.handleChangeRowsPerPage}
            labelRowsPerPage="表示件数"
          />
        </Box>
      </Box>
    );
  });

// 2) カテゴリ管理タブ
const CategoryTab = memo(() => {
  const [wizardOpen, setWizardOpen] = useState(false);
  const filteredCategories = getFilteredCategories();
  const pager = usePagination(filteredCategories);

  // ウィザードからの追加処理
  const handleWizardAdd = useCallback((formData) => {
    if(formData.name.trim() === '') return;
    const newId = categories.length > 0 ? Math.max(...categories.map(c => c.id)) + 1 : 1;
    const newCategory = { id: newId, name: formData.name };
    setCategories(prev => [...prev, newCategory]);
  }, [categories, setCategories]);

  return (
    <Box mt={2}>
      {/* ヘッダー部分にウィザード起動ボタンを配置 */}
      <Box display="flex" justifyContent="space-between" alignItems="center" mb={2}>
        <Typography variant="h6">カテゴリ管理</Typography>
        <Button
          variant="contained"
          color="primary"
          startIcon={<span className="material-icons">add</span>}
          onClick={() => setWizardOpen(true)}
        >
          新規カテゴリ追加
        </Button>
      </Box>

      {/* ウィザードモーダル */}
      <CategoryWizard
        open={wizardOpen}
        onClose={() => setWizardOpen(false)}
        onAdd={handleWizardAdd}
        categories={categories}
      />

      {/* CSVインポート/エクスポート/SQL出力ボタン */}
      <Box sx={{ mb:2 }}>
        <Button variant="contained" onClick={()=>handleImportCsvClick('categories')} sx={{ mr:1 }}>
          CSVインポート
        </Button>
        <Button variant="contained" onClick={()=>handleExportCsv('categories')} sx={{ mr:1 }}>
          CSVエクスポート
        </Button>
        <Button variant="contained" onClick={()=>handleExportSql('categories')}>
          SQL出力
        </Button>
      </Box>

      {/* カテゴリ一覧 */}
      <Box mt={4}>
        <Typography variant="subtitle1" gutterBottom>カテゴリ一覧</Typography>
        <TableContainer component={Paper}>
          <Table className="custom-table" size="small">
            <TableHead>
              <TableRow>
                <TableCell>
                  <FilterTextField
                    placeholder="IDフィルタ"
                    value={categoryFilter.id}
                    onChange={(value) => handleCategoryFilterChange('id', value)}
                  />
                </TableCell>
                <TableCell>
                  <FilterTextField
                    placeholder="カテゴリ名フィルタ"
                    value={categoryFilter.name}
                    onChange={(value) => handleCategoryFilterChange('name', value)}
                  />
                </TableCell>
                <TableCell>
                  <FilterTextField
                    placeholder="関連する構造でフィルタ"
                    value={categoryFilter.structure}
                    onChange={(value) => handleCategoryFilterChange('structure', value)}
                  />
                </TableCell>
                <TableCell>操作</TableCell>
              </TableRow>
              <TableRow>
                <TableCell>ID</TableCell>
                <TableCell>カテゴリ名</TableCell>
                <TableCell>関連する構造</TableCell>
                <TableCell>操作</TableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              {pager.pagedRows.map(cat => {
                const editObj = editingCategories[cat.id];
                return (
                  <CategoryRow
                    key={cat.id}
                    cat={cat}
                    editObj={editObj}
                    setEditingCategories={setEditingCategories}
                    saveEditCategory={saveEditCategory}
                    startEditCategory={startEditCategory}
                    structures={structures}  // 追加
                  />
                );
              })}
            </TableBody>
          </Table>
        </TableContainer>

        <TablePagination
          rowsPerPageOptions={[10,20,30,{label:'All',value:-1}]}
          component="div"
          count={filteredCategories.length}
          rowsPerPage={pager.rowsPerPage}
          page={pager.page}
          onPageChange={pager.handleChangePage}
          onRowsPerPageChange={pager.handleChangeRowsPerPage}
          labelRowsPerPage="表示件数"
        />
      </Box>
    </Box>
  );
});

// 3) 構造管理タブ
const StructureTab = memo(() => {
  const [wizardOpen, setWizardOpen] = useState(false);
  const [editModalOpen, setEditModalOpen] = useState(false);
  const [selectedStructure, setSelectedStructure] = useState(null);
  const filteredStructures = getFilteredStructures();
  const pager = usePagination(filteredStructures);

  // ウィザードからの追加処理
  const handleWizardAdd = useCallback((formData) => {
    if(formData.name.trim() === '' || formData.categoryId === '') return;
    const newId = structures.length > 0 ? Math.max(...structures.map(s => s.id)) + 1 : 1;
    const newStructure = {
      id: newId,
      name: formData.name,
      categoryId: parseInt(formData.categoryId, 10),
      propertyIds: formData.propertyIds.map(id => parseInt(id, 10))
    };
    setStructures(prev => [...prev, newStructure]);
  }, [structures, setStructures]);

  // 編集モーダルを開く
  const handleEditClick = useCallback((structure) => {
    setSelectedStructure(structure);
    setEditModalOpen(true);
  }, []);

  // 編集を保存
  const handleEditSave = useCallback((formData) => {
    if (!selectedStructure) return;
    setStructures(prev => prev.map(s => 
      s.id === selectedStructure.id
        ? { ...s, name: formData.name, categoryId: formData.categoryId, propertyIds: formData.propertyIds }
        : s
    ));

    // プロパティの関連付けも更新
    properties.forEach(prop => {
      if (formData.propertyIds.includes(prop.id)) {
        if (!prop.structureIds.includes(selectedStructure.id)) {
          setProperties(prev => prev.map(p => 
            p.id === prop.id
              ? { ...p, structureIds: [...p.structureIds, selectedStructure.id] }
              : p
          ));
        }
      } else {
        if (prop.structureIds.includes(selectedStructure.id)) {
          setProperties(prev => prev.map(p => 
            p.id === prop.id
              ? { ...p, structureIds: p.structureIds.filter(id => id !== selectedStructure.id) }
              : p
          ));
        }
      }
    });
  }, [selectedStructure, setStructures, properties, setProperties]);

  return (
    <Box mt={2}>
      {/* ヘッダー部分にウィザード起動ボタンを配置 */}
      <Box display="flex" justifyContent="space-between" alignItems="center" mb={2}>
        <Typography variant="h6">構造管理</Typography>
        <Button
          variant="contained"
          color="primary"
          startIcon={<span className="material-icons">add</span>}
          onClick={() => setWizardOpen(true)}
        >
          新規構造追加
        </Button>
      </Box>

      {/* ウィザードモーダル */}
      <StructureWizard
        open={wizardOpen}
        onClose={() => setWizardOpen(false)}
        onAdd={handleWizardAdd}
        categories={categories}
        properties={properties}
        structures={structures} // 追加：重複チェック用
      />

      {/* 編集モーダル */}
      <StructureEditModal
        open={editModalOpen}
        onClose={() => setEditModalOpen(false)}
        structure={selectedStructure}
        onSave={handleEditSave}
        categories={categories}
        properties={properties}
      />

      {/* CSVインポート/エクスポート/SQL出力ボタン */}
      <Box sx={{ mb:2 }}>
        <Button variant="contained" onClick={()=>handleImportCsvClick('structures')} sx={{ mr:1 }}>
          CSVインポート
        </Button>
        <Button variant="contained" onClick={()=>handleExportCsv('structures')} sx={{ mr:1 }}>
          CSVエクスポート
        </Button>
        <Button variant="contained" onClick={()=>handleExportSql('structures')}>
          SQL出力
        </Button>
      </Box>

      {/* 構造一覧 */}
      <Box mt={4}>
        <Typography variant="subtitle1" gutterBottom>構造一覧 (編集可)</Typography>
        <TableContainer component={Paper}>
          <Table className="custom-table" size="small">
            <TableHead>
              <TableRow>
                <TableCell>
                  <FilterTextField
                    placeholder="IDフィルタ"
                    value={structureFilter.id}
                    onChange={(value) => handleStructureFilterChange('id', value)}
                  />
                </TableCell>
                <TableCell>
                  <FilterTextField
                    placeholder="構造名フィルタ"
                    value={structureFilter.name}
                    onChange={(value) => handleStructureFilterChange('name', value)}
                  />
                </TableCell>
                <TableCell>
                  <FilterTextField
                    placeholder="カテゴリ名フィルタ"
                    value={structureFilter.category}
                    onChange={(value) => handleStructureFilterChange('category', value)}
                  />
                </TableCell>
                <TableCell>
                  <FilterTextField
                    placeholder="関連するプロパティでフィルタ"
                    value={structureFilter.property}
                    onChange={(value) => handleStructureFilterChange('property', value)}
                  />
                </TableCell>
                <TableCell>操作</TableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              {pager.pagedRows.map(str => (
                <TableRow key={str.id}>
                  <TableCell>{str.id}</TableCell>
                  <TableCell>{str.name}</TableCell>
                  <TableCell>
                    {categories.find(c => c.id === str.categoryId)?.name || '未分類'}
                  </TableCell>
                  <TableCell>
                    {/* 関連プロパティ列を追加 */}
                    {properties
                      .filter(p => p.structureIds.includes(str.id))
                      .map(p => p.name)
                      .join(', ')}
                  </TableCell>
                  <TableCell>
                    <Button 
                      variant="contained"
                      onClick={() => handleEditClick(str)}
                    >
                      編集
                    </Button>
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </TableContainer>

        <TablePagination
          rowsPerPageOptions={[10,20,30,{label:'All',value:-1}]}
          component="div"
          count={filteredStructures.length}
          rowsPerPage={pager.rowsPerPage}
          page={pager.page}
          onPageChange={pager.handleChangePage}
          onRowsPerPageChange={pager.handleChangeRowsPerPage}
          labelRowsPerPage="表示件数"
        />
      </Box>
    </Box>
  );
});

// プロパティ編集モーダルコンポーネントを追加
const PropertyEditModal = memo(({ 
  open, 
  onClose, 
  property,
  onSave,
  structures 
}) => {
  const [formData, setFormData] = useState({ name: '', structureIds: [] });

  // プロパティデータが変更されたらフォームを更新
  useEffect(() => {
    if (property) {
      setFormData({
        name: property.name,
        structureIds: property.structureIds
      });
    }
  }, [property]);

  const handleSave = () => {
    if (formData.name.trim() === '' || formData.structureIds.length === 0) {
      alert('名前と構造を選択してください');
      return;
    }
    onSave(formData);
    onClose();
  };

  return (
    <Dialog open={open} onClose={onClose} maxWidth="sm" fullWidth>
      <DialogTitle>プロパティ編集</DialogTitle>
      <DialogContent>
        <Box sx={{ pt: 2 }}>
          <TextField
            label="プロパティ名"
            value={formData.name}
            onChange={e => setFormData(prev => ({ ...prev, name: e.target.value }))}
            fullWidth
            sx={{ mb: 2 }}
          />
          <FormControl fullWidth>
            <InputLabel>紐づける構造</InputLabel>
            <Select
              multiple
              value={formData.structureIds}
              onChange={e => setFormData(prev => ({ ...prev, structureIds: e.target.value }))}
              input={<OutlinedInput />}
              renderValue={selected => {
                return selected
                  .map(id => structures.find(s => s.id === id)?.name || '?')
                  .join(', ');
              }}
            >
              {structures.map(str => (
                <MenuItem key={str.id} value={str.id}>
                  <Checkbox checked={formData.structureIds.indexOf(str.id) > -1} />
                  <ListItemText primary={str.name} />
                </MenuItem>
              ))}
            </Select>
          </FormControl>
        </Box>
      </DialogContent>
      <DialogActions>
        <Button onClick={onClose}>キャンセル</Button>
        <Button onClick={handleSave} variant="contained">保存</Button>
      </DialogActions>
    </Dialog>
  );
});

// PropertyTab コンポーネントを修正
const PropertyTab = memo(() => {
  const [wizardOpen, setWizardOpen] = useState(false);
  const [editModalOpen, setEditModalOpen] = useState(false);
  const [selectedProperty, setSelectedProperty] = useState(null);
  const filteredProperties = getFilteredProperties();
  const pager = usePagination(filteredProperties);

  // ウィザードからの追加処理
  const handleWizardAdd = useCallback((formData) => {
    if(formData.name.trim() === '' || formData.structureIds.length === 0) return;
    const newId = properties.length > 0 ? Math.max(...properties.map(p => p.id)) + 1 : 1;
    const newProperty = {
      id: newId,
      name: formData.name,
      structureIds: formData.structureIds.map(id => parseInt(id, 10))
    };
    setProperties(prev => [...prev, newProperty]);
  }, [properties, setProperties]);

  // 編集モーダルを開く
  const handleEditClick = useCallback((property) => {
    setSelectedProperty(property);
    setEditModalOpen(true);
  }, []);

  // 編集を保存
  const handleEditSave = useCallback((formData) => {
    if (!selectedProperty) return;
    setProperties(prev => prev.map(p => 
      p.id === selectedProperty.id
        ? { ...p, name: formData.name, structureIds: formData.structureIds }
        : p
    ));
  }, [selectedProperty, setProperties]);

  return (
    <Box mt={2}>
      <Box display="flex" justifyContent="space-between" alignItems="center" mb={2}>
        <Typography variant="h6">プロパティ管理</Typography>
        <Button
          variant="contained"
          color="primary"
          startIcon={<span className="material-icons">add</span>}
          onClick={() => setWizardOpen(true)}
        >
          新規プロパティ追加
        </Button>
      </Box>

      {/* ウィザードモーダル */}
      <PropertyWizard
        open={wizardOpen}
        onClose={() => setWizardOpen(false)}
        onAdd={handleWizardAdd}
        structures={structures}
        properties={properties}
      />

      {/* 編集モーダル */}
      <PropertyEditModal
        open={editModalOpen}
        onClose={() => setEditModalOpen(false)}
        property={selectedProperty}
        onSave={handleEditSave}
        structures={structures}
      />

      {/* CSVインポート/エクスポート/SQL出力ボタン */}
      <Box sx={{ mb:2 }}>
        <Button variant="contained" onClick={()=>handleImportCsvClick('properties')} sx={{ mr:1 }}>
          CSVインポート
        </Button>
        <Button variant="contained" onClick={()=>handleExportCsv('properties')} sx={{ mr:1 }}>
          CSVエクスポート
        </Button>
        <Button variant="contained" onClick={()=>handleExportSql('properties')}>
          SQL出力
        </Button>
      </Box>

      {/* プロパティ一覧 */}
      <Box mt={4}>
        <Typography variant="subtitle1" gutterBottom>プロパティ一覧</Typography>
        <TableContainer component={Paper}>
          <Table className="custom-table" size="small">
            <TableHead>
              <TableRow>
                <TableCell>
                  <FilterTextField
                    placeholder="IDフィルタ"
                    value={propertyFilter.id}
                    onChange={(value) => handlePropertyFilterChange('id', value)}
                  />
                </TableCell>
                <TableCell>
                  <FilterTextField
                    placeholder="プロパティ名フィルタ"
                    value={propertyFilter.name}
                    onChange={(value) => handlePropertyFilterChange('name', value)}
                  />
                </TableCell>
                <TableCell>
                  <FilterTextField
                    placeholder="構造名フィルタ"
                    value={propertyFilter.link}
                    onChange={(value) => handlePropertyFilterChange('link', value)}
                  />
                </TableCell>
                <TableCell>操作</TableCell>
              </TableRow>
              <TableRow>
                <TableCell>ID</TableCell>
                <TableCell>プロパティ名</TableCell>
                <TableCell>紐づける構造</TableCell>
                <TableCell>操作</TableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              {pager.pagedRows.map(prop => (
                <TableRow key={prop.id}>
                  <TableCell>{prop.id}</TableCell>
                  <TableCell>{prop.name}</TableCell>
                  <TableCell>
                    {prop.structureIds
                      .map(sid => structures.find(s => s.id === sid)?.name || '?')
                      .join(', ')}
                  </TableCell>
                  <TableCell>
                    <Button 
                      variant="contained"
                      onClick={() => handleEditClick(prop)}
                    >
                      編集
                    </Button>
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </TableContainer>

        <TablePagination
          rowsPerPageOptions={[10,20,30,{label:'All',value:-1}]}
          component="div"
          count={filteredProperties.length}
          rowsPerPage={pager.rowsPerPage}
          page={pager.page}
          onPageChange={pager.handleChangePage}
          onRowsPerPageChange={pager.handleChangeRowsPerPage}
          labelRowsPerPage="表示件数"
        />
      </Box>
    </Box>
  );
});

// 5) 確認タブ
const ConfirmTab = memo(() => {
  const catPager = usePagination(categories);
  const strPager = usePagination(structures);
  const propPager = usePagination(properties);
  const dataPager = usePagination(dataRecords);

  return (
    <Box mt={2}>
      <Typography variant="h6" gutterBottom>カテゴリ一覧</Typography>
      <TableContainer component={Paper} sx={{ mb:4 }}>
        <Table className="custom-table" size="small">
          <TableHead>
            <TableRow>
              <TableCell>ID</TableCell>
              <TableCell>カテゴリ名</TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {catPager.pagedRows.map(cat=>(
              <TableRow key={cat.id}>
                <TableCell>{cat.id}</TableCell>
                <TableCell>{cat.name}</TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </TableContainer>
      <TablePagination
        rowsPerPageOptions={[10,20,30,{label:'All',value:-1}]}
        component="div"
        count={categories.length}
        rowsPerPage={catPager.rowsPerPage}
        page={catPager.page}
        onPageChange={catPager.handleChangePage}
        onRowsPerPageChange={catPager.handleChangeRowsPerPage}
        labelRowsPerPage="表示件数"
      />

      <Typography variant="h6" gutterBottom>構造一覧</Typography>
      <TableContainer component={Paper} sx={{ mb:4 }}>
        <Table className="custom-table" size="small">
          <TableHead>
            <TableRow>
              <TableCell>ID</TableCell>
              <TableCell>構造名</TableCell>
              <TableCell>カテゴリ</TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {strPager.pagedRows.map(str=>{
              const cat = categories.find(c=> c.id===str.categoryId);
              return (
                <TableRow key={str.id}>
                  <TableCell>{str.id}</TableCell>
                  <TableCell>{str.name}</TableCell>
                  <TableCell>{cat ? cat.name : '未分類'}</TableCell>
                </TableRow>
              );
            })}
          </TableBody>
        </Table>
      </TableContainer>
      <TablePagination
        rowsPerPageOptions={[10,20,30,{label:'All',value:-1}]}
        component="div"
        count={structures.length}
        rowsPerPage={strPager.rowsPerPage}
        page={strPager.page}
        onPageChange={strPager.handleChangePage}
        onRowsPerPageChange={strPager.handleChangeRowsPerPage}
        labelRowsPerPage="表示件数"
      />

      <Typography variant="h6" gutterBottom>プロパティ一覧</Typography>
      <TableContainer component={Paper} sx={{ mb:4 }}>
        <Table className="custom-table" size="small">
          <TableHead>
            <TableRow>
              <TableCell>ID</TableCell>
              <TableCell>プロパティ名</TableCell>
              <TableCell>紐づく構造</TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {propPager.pagedRows.map(prop=>(
              <TableRow key={prop.id}>
                <TableCell>{prop.id}</TableCell>
                <TableCell>{prop.name}</TableCell>
                <TableCell>
                  {prop.structureIds
                    .map(sid=> structures.find(ss=> ss.id===sid)?.name || '?')
                    .join(', ')
                  }
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </TableContainer>
      <TablePagination
        rowsPerPageOptions={[10,20,30,{label:'All',value:-1}]}
        component="div"
        count={properties.length}
        rowsPerPage={propPager.rowsPerPage}
        page={propPager.page}
        onPageChange={propPager.handleChangePage}
        onRowsPerPageChange={propPager.handleChangeRowsPerPage}
        labelRowsPerPage="表示件数"
      />

      <Typography variant="h6" gutterBottom>データレコード一覧</Typography>
      <TableContainer component={Paper}>
        <Table className="custom-table" size="small">
          <TableHead>
            <TableRow>
              <TableCell>ID</TableCell>
              <TableCell>構造名</TableCell>
              <TableCell>プロパティ(JSON)</TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {dataPager.pagedRows.map(rec=>{
              const str = structures.find(s=> s.id===rec.structureId);
              return (
                <TableRow key={rec.id}>
                  <TableCell>{rec.id}</TableCell>
                  <TableCell>{str? str.name : '未分類'}</TableCell>
                  <TableCell>{JSON.stringify(rec.values)}</TableCell>
                </TableRow>
              );
            })}
          </TableBody>
        </Table>
      </TableContainer>
      <TablePagination
        rowsPerPageOptions={[10,20,30,{label:'All',value:-1}]}
        component="div"
        count={dataRecords.length}
        rowsPerPage={dataPager.rowsPerPage}
        page={dataPager.page}
        onPageChange={dataPager.handleChangePage}
        onRowsPerPageChange={dataPager.handleChangeRowsPerPage}
        labelRowsPerPage="表示件数"
      />
    </Box>
  );
});

  /* -------------------------------------------
   *   タブ切り替え
   * ------------------------------------------- */

  const handleTabChangeLocal = useCallback((e, newVal) => setTabValue(newVal), []);

  return (
    <Box my={3}>
      {/* CSVインポート用 ファイル入力 */}
      <input
        type="file"
        ref={fileInputRef}
        style={{ display:'none' }}
      />

      {/* タブ */}
      <Tabs
        value={tabValue}
        onChange={handleTabChangeLocal}
        textColor="primary"
        indicatorColor="primary"
      >
        <Tab label="関連レコード" />
        <Tab label="データ登録" />
        <Tab label="カテゴリ管理" />
        <Tab label="構造管理" />
        <Tab label="プロパティ管理" />
        <Tab label="確認" />
      </Tabs>

      {tabValue===0 && <RelatedRecordsTab />}
      {tabValue===1 && <DataRegisterTab />}
      {tabValue===2 && <CategoryTab />}
      {tabValue===3 && <StructureTab />}
      {tabValue===4 && <PropertyTab />}
      {tabValue===5 && <ConfirmTab />}
    </Box>
  );
});

/*---------------------------------------------------------
  6) ルート(App)コンポーネント
---------------------------------------------------------*/
const App = memo(() => {
  // カテゴリ
  const [categories, setCategories] = useState([
    { id:1, name:'電子機器' },
    { id:2, name:'家具' },
  ]);

  // 構造
  const [structures, setStructures] = useState([
    { id:1, name:'スマートフォン', categoryId:1 },
    { id:2, name:'ソファ', categoryId:2 },
  ]);

  // プロパティ (多対多)
  const [properties, setProperties] = useState([
    { id:1, name:'ブランド', structureIds:[1] },
    { id:2, name:'価格', structureIds:[1] },
    { id:3, name:'素材', structureIds:[2] },
  ]);

  // データレコード
  const [dataRecords, setDataRecords] = useState([
    { id:1, structureId:1, values:{1:'Apple', 2:'120000'} },
    { id:2, structureId:2, values:{3:'レザー'} },
  ]);

  // グラフ用 フィルター (カテゴリ/構造)
  const [filters, setFilters] = useState({
    categoryId:'',
    structureId:'',
  });

  return (
    <Box display="flex" flexDirection="column" minHeight="100vh">
      <AppBarComponent />

      <Container>
        {/* ビジュアライズ */}
        <DataVisualization
          categories={categories}
          structures={structures}
          properties={properties}
          dataRecords={dataRecords}
          filters={filters}
          setFilters={setFilters}
        />

        {/* DataManagement (6タブ) */}
        <DataManagement
          categories={categories} setCategories={setCategories}
          structures={structures} setStructures={setStructures}
          properties={properties} setProperties={setProperties}
          dataRecords={dataRecords} setDataRecords={setDataRecords}
          filters={filters}
        />
      </Container>

      <FooterComponent />
    </Box>
  );
});

// レンダリング開始
ReactDOM.render(<App />, document.getElementById('root'));
</script>
</body>
</html>
