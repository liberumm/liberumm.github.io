<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>MRビューサンプル</title>
  <!-- Material UI CSS -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons" />
  <!-- A-Frame -->
  <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
  <!-- A-Frame Physics System -->
  <script src="https://cdn.jsdelivr.net/npm/aframe-physics-system@4.0.1/dist/aframe-physics-system.min.js"></script>
  <!-- React -->
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <!-- Babel -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!-- Material UI -->
  <script src="https://unpkg.com/@mui/material@5.14.4/umd/material-ui.development.js" crossorigin></script>
  <!-- NippleJS (ジョイスティックライブラリ) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.9.0/nipplejs.min.js"></script>
  <!-- super-hands -->
  <script src="https://cdn.jsdelivr.net/npm/aframe-super-hands@4.0.5/dist/aframe-super-hands.min.js"></script>
  <style>
    body, html, #root {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      font-family: 'Roboto', sans-serif;
      overflow: hidden; /* Prevent scroll */
    }
    .app-bar {
      position: fixed; /* fixedに変更 */
      top: 0;
      width: 100%;
      z-index: 10;
    }
    .content {
      margin-top: 64px; /* Height of AppBar */
      height: calc(100% - 64px);
    }
    /* A-Frameシーンの高さを100%に設定 */
    a-scene {
      height: 100%;
      width: 100%;
    }
    /* ジョイスティックのコンテナスタイル */
    .joystick-container {
      position: fixed;
      bottom: 20px;
      width: 100px;
      height: 100px;
      z-index: 20; /* AppBarより上に表示 */
    }
    #joystick-move-container {
      left: 20px; /* 左下に配置 */
    }
    #joystick-height-container {
      right: 20px; /* 右下に配置 */
    }
    /* 座標入力フィールドのコンテナスタイル */
    .input-container {
      position: fixed;
      top: 80px;
      right: 20px;
      z-index: 15;
      background-color: rgba(255,255,255,0.8);
      padding: 16px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
      max-width: 300px;
    }
    .input-field {
      margin-bottom: 16px;
    }
    /* モード表示のスタイル */
    .mode-indicator {
      position: fixed;
      top: 70px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 15;
      background-color: rgba(255,255,255,0.9);
      padding: 8px 16px;
      border-radius: 4px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
      display: none; /* 初期状態は非表示 */
    }
    /* Material Iconsのスタイル調整（必要に応じて） */
    .material-icons {
      font-size: 24px;
      vertical-align: middle;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <!-- ジョイスティック用のコンテナ -->
  <div id="joystick-move-container" class="joystick-container"></div>
  <div id="joystick-height-container" class="joystick-container"></div>

  <!-- モード表示用の要素 -->
  <div id="mode-indicator" class="mode-indicator">
    移動モード: 有効
  </div>

  <!-- カスタムドラッグコンポーネントを定義 -->
  <script>
  AFRAME.registerComponent('move', {
    init: function () {
      const el = this.el;
      let isMove = false;
      let selectedObject = null;
      
      const mouse = new THREE.Vector2();
      const camera = this.el.sceneEl.camera;
      const raycaster = new THREE.Raycaster();
      
      // 移動モード表示要素
      var modeIndicator = document.getElementById("mode-indicator");

      // シーン内の移動平面
      const plane = document.getElementById('plane1');
      
      //クリックイベント
      el.addEventListener('click', (evt) => {
        isMove = !isMove;
        selectedObject = isMove ? el : null;
        modeIndicator.style.display = isMove ? 'block' : 'none';
        if (isMove) {
            // オブジェクトを半透明にする
            el.setAttribute('material', 'opacity', 0.5);
            el.setAttribute('material', 'transparent', true);
            //el.setAttribute('material', 'color', "#EF2D5E");
          } else {
            // オブジェクトの不透明度を元に戻す
            el.setAttribute('material', 'opacity', 1.0);
            el.setAttribute('material', 'transparent', false);
          }
      });

      // 平面上でマウスが移動したときにオブジェクトを移動
      plane.addEventListener('mouseenter', (evt) => {
        if(isMove && selectedObject) {
          // 交点の位置を取得
          const intersection = evt.detail.intersection;
          if (intersection) {
            const point = intersection.point;
            // オブジェクトの高さを考慮してy座標を調整
            const objectHeight = selectedObject.getAttribute('height') || selectedObject.getAttribute('radius') || 1;
            point.y += objectHeight / 2;
            selectedObject.setAttribute('position', {
              x: point.x.toFixed(2),
              y: point.y.toFixed(2),
              z: point.z.toFixed(2)
            });
            //console.log(`オブジェクト移動: x=${point.x.toFixed(2)}, y=${point.y.toFixed(2)}, z=${point.z.toFixed(2)}`);
          }
        }
      });

      window.addEventListener("dblclick", (event) => {
        if (!isMove || !selectedObject) return;

        // マウス座標を正規化デバイス座標に変換
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        // レイキャスターを更新
        raycaster.setFromCamera(mouse, camera);

        // 平面との交点を取得
        const intersects = raycaster.intersectObject(plane.getObject3D('mesh'));

        if (intersects.length > 0) {
          currentIntersection = intersects[0].point;

          // オブジェクトの高さを考慮してy座標を調整
          const objectHeight = selectedObject.getAttribute('height') || selectedObject.getAttribute('radius') || 0.75;
          const newPosition = {
            x: currentIntersection.x.toFixed(2),
            y: (currentIntersection.y + objectHeight / 2).toFixed(2),
            z: currentIntersection.z.toFixed(2)
          };

          // オブジェクトの位置を更新
          selectedObject.setAttribute('position', newPosition);
        }
      });
    }
  });
  </script>

  <script type="text/babel">
    const {
      AppBar,
      Toolbar,
      Typography,
      Button,
      Container,
      TextField,
      Drawer,
      List,
      ListItem,
      ListItemButton,
      ListItemText,
      IconButton,
    } = MaterialUI;

    // Material Icons フォントを使用してアイコンを表示する関数
    const MaterialIcon = ({ iconName }) => (
      <span className="material-icons">{iconName}</span>
    );

    function App() {
      const [boxColor, setBoxColor] = React.useState('#4CC3D9');
      const [cameraHeight, setCameraHeight] = React.useState(1.6);
      const [cameraPosition, setCameraPosition] = React.useState({ x: 0.00, y: 1.60, z: 0.00 });
      const [inputPosition, setInputPosition] = React.useState({ x: 0.00, y: 1.60, z: 0.00 });
      const cameraRef = React.useRef(null); // カメラエンティティへの参照

      // ジョイスティックの移動速度
      const moveSpeed = 0.05;
      const heightSpeed = 0.05;

      // 移動方向を保持するオブジェクト
      const movement = React.useRef({
        forward: false,
        backward: false,
        left: false,
        right: false
      }).current;

      // 高さ調整方向を保持するオブジェクト
      const heightAdjustment = React.useRef({
        up: false,
        down: false
      }).current;

      // ジョイスティックの初期化
      React.useEffect(() => {
        console.log('Initializing joysticks');
        
        // 移動ジョイスティック
        const joystickMoveZone = document.getElementById('joystick-move-container');
        if (!joystickMoveZone) {
          console.error('Move Joystick container not found!');
          return;
        }

        const joystickMove = nipplejs.create({
          zone: joystickMoveZone,
          mode: 'static',
          position: { left: '50%', top: '50%' },
          color: 'blue',
          size: 100,
          restOpacity: 0.5
        });

        joystickMove.on('move', function(evt, data) {
          // 移動ジョイスティックの処理
          let dir = 'none';
          if (data.direction && data.direction.code) {
            dir = data.direction.code;
          } else if (data.angle && data.angle.degree !== undefined) {
            const degree = data.angle.degree;
            if (degree >= 45 && degree < 135) {
              dir = 'up';
            } else if (degree >= 135 && degree < 225) {
              dir = 'left';
            } else if (degree >= 225 && degree < 315) {
              dir = 'down';
            } else {
              dir = 'right';
            }
          }

          if (dir !== 'none') {
            // 移動フラグをリセット
            movement.forward = false;
            movement.backward = false;
            movement.left = false;
            movement.right = false;

            // 方向に応じてフラグを立てる
            switch(dir) {
              case 'up':
                movement.forward = true;
                break;
              case 'down':
                movement.backward = true;
                break;
              case 'left':
                movement.left = true;
                break;
              case 'right':
                movement.right = true;
                break;
              default:
                break;
            }
          }
        });

        joystickMove.on('end', function(evt, data) {
          // ジョイスティックが離されたときに移動フラグをリセット
          movement.forward = false;
          movement.backward = false;
          movement.left = false;
          movement.right = false;
        });

        // 高さ調整ジョイスティック
        const joystickHeightZone = document.getElementById('joystick-height-container');
        if (!joystickHeightZone) {
          console.error('Height Joystick container not found!');
          return;
        }

        const joystickHeight = nipplejs.create({
          zone: joystickHeightZone,
          mode: 'static',
          position: { left: '50%', top: '50%' },
          color: 'green',
          size: 100,
          restOpacity: 0.5
        });

        joystickHeight.on('move', function(evt, data) {
          // 高さ調整ジョイスティックの処理
          let dir = 'none';
          if (data.direction && data.direction.code) {
            dir = data.direction.code;
          } else if (data.angle && data.angle.degree !== undefined) {
            const degree = data.angle.degree;
            if (degree >= 45 && degree < 135) {
              dir = 'up';
            } else if (degree >= 225 && degree < 315) {
              dir = 'down';
            }
          }

          if (dir !== 'none') {
            // 高さ調整フラグをリセット
            heightAdjustment.up = false;
            heightAdjustment.down = false;

            // 方向に応じてフラグを立てる
            switch(dir) {
              case 'up':
                heightAdjustment.up = true;
                break;
              case 'down':
                heightAdjustment.down = true;
                break;
              default:
                break;
            }
          }
        });

        joystickHeight.on('end', function(evt, data) {
          // ジョイスティックが離されたときに高さ調整フラグをリセット
          heightAdjustment.up = false;
          heightAdjustment.down = false;
        });

        // アニメーションフレームでカメラを移動・高さ調整
        const animate = () => {
          if (cameraRef.current) {
            const position = cameraRef.current.object3D.position;
            let x = position.x;
            let y = position.y;
            let z = position.z;
            let moved = false;

            // 移動処理
            if (movement.forward) {
              z -= moveSpeed;
              moved = true;
            }
            if (movement.backward) {
              z += moveSpeed;
              moved = true;
            }
            if (movement.left) {
              x -= moveSpeed;
              moved = true;
            }
            if (movement.right) {
              x += moveSpeed;
              moved = true;
            }

            // 高さ調整処理
            if (heightAdjustment.up) {
              y += heightSpeed;
              moved = true;
            }
            if (heightAdjustment.down) {
              y -= heightSpeed;
              moved = true;
            }

            if (moved) {
              cameraRef.current.object3D.position.set(x, y, z);
              setCameraPosition({ x: x.toFixed(2), y: y.toFixed(2), z: z.toFixed(2) }); // 状態を更新
              setCameraHeight(y); // カメラ高さの状態も更新
              //console.log(`Camera Position Updated: x=${x.toFixed(2)}, y=${y.toFixed(2)}, z=${z.toFixed(2)}`);
            }
          }
          requestAnimationFrame(animate);
        };

        animate();

        // クリーンアップ
        return () => {
          joystickMove.destroy();
          joystickHeight.destroy();
          console.log('Joysticks destroyed');
        };
      }, []);

      // モデルとカメラの状態
      const [drawerOpen, setDrawerOpen] = React.useState(false);
      const [models, setModels] = React.useState([
        { id: 1, type: 'box', position: { x: -1, y: 1, z: -3 }, color: '#4CC3D9' },
        { id: 2, type: 'sphere', position: { x: 0, y: 1.25, z: -5 }, color: '#EF2D5E' },
        { id: 3, type: 'cylinder', position: { x: 1, y: 0.75, z: -3 }, color: '#FFC65D' },
      ]);

      // メニューの開閉トグル
      const toggleDrawer = (open) => () => {
        setDrawerOpen(open);
      };

      // モデル追加関数
      const addModel = (modelType) => {
        const newModel = {
          id: Date.now(),
          type: modelType,
          position: { x: 0, y: 1, z: -3 },
          color: getRandomColor(),
        };
        setModels([...models, newModel]);
      };

      // ランダムな色を生成するヘルパー関数
      const getRandomColor = () => {
        const letters = '0123456789ABCDEF';
        let color = '#';
        for (let i = 0; i < 6; i++) {
          color += letters[Math.floor(Math.random() * 16)];
        }
        return color;
      };

      // モデルクリックで色変更または削除
      const handleBoxClick = (modelId) => {
        if (modelId) {
          // 削除
          handleDeleteModel(modelId);
        } else {
          // 既存のボックス色変更
          setBoxColor(prevColor => prevColor === '#4CC3D9' ? '#EF2D5E' : '#4CC3D9');
        }
      };

      const handleDeleteModel = (modelId) => {
        const updatedModels = models.filter(model => model.id !== modelId);
        setModels(updatedModels);
      };

      // カメラ位置の変更
      const handleInputChange = (event) => {
        const { name, value } = event.target;
        setInputPosition(prev => ({
          ...prev,
          [name]: parseFloat(value)
        }));
      };

      const handleSetPosition = () => {
        if (cameraRef.current) {
          const { x, y, z } = inputPosition;
          cameraRef.current.object3D.position.set(x, y, z);
          setCameraPosition({ x: x.toFixed(2), y: y.toFixed(2), z: z.toFixed(2) });
          setCameraHeight(y);
          //console.log(`Camera Position Set to: x=${x.toFixed(2)}, y=${y.toFixed(2)}, z=${z.toFixed(2)}`);
        }
      };

      // レイアウト保存
      const handleSaveLayout = () => {
        const layout = {
          models: models.map(model => ({
            type: model.type,
            position: model.position,
            color: model.color,
          })),
          camera: cameraPosition,
        };

        const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(layout, null, 2));
        const downloadAnchorNode = document.createElement('a');
        downloadAnchorNode.setAttribute("href", dataStr);
        downloadAnchorNode.setAttribute("download", "3d_layout.json");
        document.body.appendChild(downloadAnchorNode);
        downloadAnchorNode.click();
        downloadAnchorNode.remove();
      };

      // レイアウト読み込み
      const handleLoadLayout = (event) => {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const layout = JSON.parse(e.target.result);
            if (layout.models) {
              // モデルの読み込み
              const loadedModels = layout.models.map((model, index) => ({
                id: Date.now() + index,
                type: model.type,
                position: model.position,
                color: model.color,
              }));
              setModels(loadedModels);
            }
            if (layout.camera) {
              // カメラの位置設定
              cameraRef.current.object3D.position.set(
                layout.camera.x,
                layout.camera.y,
                layout.camera.z
              );
              setCameraPosition({ 
                x: layout.camera.x.toFixed(2), 
                y: layout.camera.y.toFixed(2), 
                z: layout.camera.z.toFixed(2) 
              });
              setInputPosition({ 
                x: parseFloat(layout.camera.x.toFixed(2)), 
                y: parseFloat(layout.camera.y.toFixed(2)), 
                z: parseFloat(layout.camera.z.toFixed(2)) 
              });
            }
            alert('レイアウトを正常に読み込みました。');
          } catch (error) {
            console.error('レイアウト読み込みエラー:', error);
            alert('レイアウトの読み込みに失敗しました。正しいJSONファイルを選択してください。');
          }
        };
        reader.readAsText(file);
      };

      return (
        <div>
          {/* AppBarからメニューアイコンを追加 */}
          <AppBar position="fixed" className="app-bar">
            <Toolbar>
              <IconButton 
                edge="start" 
                color="inherit" 
                aria-label="menu" 
                onClick={toggleDrawer(true)}
                sx={{ mr: 2 }}
              >
                <MaterialIcon iconName="menu" />
              </IconButton>
              <Typography variant="h6" component="div" sx={{ flexGrow: 1 }}>
                MRビューサンプル
              </Typography>
              <Button color="inherit">ログイン</Button>
            </Toolbar>
          </AppBar>

          {/* ドロワーメニュー */}
          <Drawer
            anchor="left"
            open={drawerOpen}
            onClose={toggleDrawer(false)}
          >
            <List sx={{ width: 250 }}>
              <ListItem>
                <Typography variant="h6">3Dモデル追加</Typography>
              </ListItem>
              <ListItemButton onClick={() => addModel('box')}>
                <ListItemText primary="ボックス" />
              </ListItemButton>
              <ListItemButton onClick={() => addModel('sphere')}>
                <ListItemText primary="スフィア" />
              </ListItemButton>
              <ListItemButton onClick={() => addModel('cylinder')}>
                <ListItemText primary="シリンダー" />
              </ListItemButton>
              {/* レイアウト読み込み */}
              <ListItemButton component="label">
                <input type="file" accept=".json" hidden onChange={handleLoadLayout} />
                <ListItemText primary="レイアウト読み込み" />
              </ListItemButton>
            </List>
          </Drawer>

          {/* 座標入力フィールド */}
          <div className="input-container">
            <Typography gutterBottom>カメラ座標入力</Typography>
            <TextField
              className="input-field"
              label="X座標"
              variant="outlined"
              size="small"
              type="number"
              name="x"
              value={inputPosition.x}
              onChange={handleInputChange}
              fullWidth
            />
            <TextField
              className="input-field"
              label="Y座標"
              variant="outlined"
              size="small"
              type="number"
              name="y"
              value={inputPosition.y}
              onChange={handleInputChange}
              fullWidth
            />
            <TextField
              className="input-field"
              label="Z座標"
              variant="outlined"
              size="small"
              type="number"
              name="z"
              value={inputPosition.z}
              onChange={handleInputChange}
              fullWidth
            />
            <Button variant="contained" color="primary" onClick={handleSetPosition} fullWidth>
              設定
            </Button>
            
            {/* 保存ボタンの追加 */}
            <Button 
              variant="contained" 
              color="secondary" 
              startIcon={<MaterialIcon iconName="save" />} 
              onClick={handleSaveLayout} 
              fullWidth
              sx={{ marginTop: 2 }}
            >
              レイアウト保存
            </Button>
          </div>

          {/* A-Frame Scene */}
          <div className="content">
            <a-scene 
              physics="debug: false" 
              stats 
              loading-screen="dotsColor: gray; backgroundColor: lightgray">
              
              {/* 移動平面 */}
              <a-plane 
                id="plane1"
                position="0 0 -4" 
                rotation="-90 0 0" 
                width="10" 
                height="10" 
                color="#7BC8A4" 
                opacity="0.0" 
                shadow
                static-body>
              </a-plane>

              {/* カメラの位置を調整 */}
              <a-camera
                cursor="rayOrigin: mouse;"
                ref={cameraRef}
                wasd-controls="acceleration: 200; fly: false" 
                look-controls
                super-hands="colliderEvent: raycaster-intersection; colliderEventProperty: els">
              </a-camera>

              {/* 照明 */}
              <a-entity light="type: ambient; color: #BBB"></a-entity>
              <a-entity light="type: directional; intensity: 0.5" position="1 1 0"></a-entity>

              {/* インタラクティブな既存のオブジェクト */}
              <a-box 
                position="-1 1 -3" 
                rotation="0 45 0" 
                color={boxColor} 
                shadow
                class="clickable"
                move
                dynamic-body
                event-set__enter="_event: mouseenter; color: #24CAFF"
                event-set__leave="_event: mouseleave; color: #4CC3D9"
                onClick={() => handleBoxClick()}
                animation="property: rotation; to: 0 405 0; loop: true; dur: 10000">
              </a-box>

              <a-sphere 
                position="0 1.25 -5" 
                radius="1.25" 
                color="#EF2D5E" 
                shadow 
                class="clickable" 
                move
                dynamic-body>
              </a-sphere>
              <a-cylinder 
                position="1 0.75 -3" 
                radius="0.5" 
                height="1.5" 
                color="#FFC65D" 
                shadow 
                class="clickable" 
                move
                dynamic-body>
              </a-cylinder>
              
              {/* 追加されたモデルをレンダリング */}
              {models.map(model => {
                switch(model.type) {
                  case 'box':
                    return (
                      <a-box 
                        key={model.id}
                        position={`${model.position.x} ${model.position.y} ${model.position.z}`} 
                        rotation="0 45 0" 
                        color={model.color} 
                        shadow
                        class="clickable"
                        move
                        dynamic-body
                        event-set__enter="_event: mouseenter; color: #24CAFF"
                        event-set__leave="_event: mouseleave; color: #4CC3D9"
                        onClick={() => handleBoxClick(model.id)}
                        animation="property: rotation; to: 0 405 0; loop: true; dur: 10000">
                      </a-box>
                    );
                  case 'sphere':
                    return (
                      <a-sphere 
                        key={model.id}
                        position={`${model.position.x} ${model.position.y} ${model.position.z}`} 
                        radius="1.25" 
                        color={model.color} 
                        shadow 
                        class="clickable" 
                        move
                        dynamic-body>
                      </a-sphere>
                    );
                  case 'cylinder':
                    return (
                      <a-cylinder 
                        key={model.id}
                        position={`${model.position.x} ${model.position.y} ${model.position.z}`} 
                        radius="0.5" 
                        height="1.5" 
                        color={model.color} 
                        shadow 
                        class="clickable" 
                        move
                        dynamic-body>
                      </a-cylinder>
                    );
                  // 他のモデルタイプも追加可能
                  default:
                    return null;
                }
              })}

              {/* グリッドヘルパー（必要に応じて削除） */}
              <a-grid-helper></a-grid-helper>
            </a-scene>
          </div>
        </div>
      )
    }

    // Render the App component into the DOM
    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
