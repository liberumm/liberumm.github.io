<!DOCTYPE html>
<html>
<head>
  <title>All Features: React + Leaflet + MUI</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0">

  <!-- React / ReactDOM / Babel -->
  <script src="https://cdn.jsdelivr.net/npm/react@18/umd/react.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.21.0/babel.min.js"></script>

  <!-- MUI (Material UI) + Emotion -->
  <script src="https://cdn.jsdelivr.net/npm/@mui/material@5.11.15/umd/material-ui.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@emotion/react@11.11.0/dist/emotion-react.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@emotion/styled@11.11.0/dist/emotion-styled.umd.min.js"></script>

  <!-- Leaflet CSS/JS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

  <!-- osmtogeojson, turf.js -->
  <script src="https://cdn.jsdelivr.net/npm/osmtogeojson@3.0.0-beta.5/osmtogeojson.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

  <!-- SheetJS, PapaParse for file I/O -->
  <script src="https://cdn.sheetjs.com/xlsx-0.19.3/package/dist/xlsx.full.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.0/papaparse.min.js"></script>

  <style>
    /* スタイルをMUIのテーマに合わせて更新 */
    .map-section {
      height: calc(100vh - 128px); /* AppBarの高さを考慮 */
      padding: 16px;
      background-color: #f5f5f5;
    }

    .map-container {
      border-radius: 4px;
      overflow: hidden;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    /* 検索コントロールをMUIスタイルに */
    .search-controls {
      background-color: white;
      padding: 16px;
      border-radius: 4px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    /* テーブルスタイルの改善 */
    .compact-table .MuiTableCell-root {
      padding: 8px;
    }

    .compact-table .MuiTableCell-head {
      background-color: #f5f5f5;
      font-weight: bold;
    }

    /* Adjust the width of specific columns for better readability */
    .col-checkbox {
      width: 50px;
    }

    .col-move {
      width: 80px;
    }

    .col-name {
      width: 150px;
    }

    .col-address {
      width: 200px;
    }

    .col-coord {
      width: 100px;
    }

    .col-date {
      width: 120px;
    }

    .col-number {
      width: 100px;
    }

    .col-radius {
      width: 150px;
    }

    .col-action {
      width: 80px;
    }
  </style>
</head>
<body>
<div id="root"></div>

<script type="text/babel">
const {
  createTheme,
  ThemeProvider,
  CssBaseline,
  AppBar,
  Toolbar,
  Typography,
  Box,
  Button,
  TextField,
  Radio,
  RadioGroup,
  FormControlLabel,
  FormControl,
  Tabs,
  Tab,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  IconButton,
  Paper,
  Checkbox,
  TablePagination,
  Dialog,
  DialogTitle,
  DialogContent,
  Divider,
} = MaterialUI;

/**
 * 全機能フルコード:
 *  - 初期渋谷駅のプロット
 *  - 住所/座標検索 → テーブル追加 (名称/住所/lat/lon)
 *  - テーブル編集で即マップ反映
 *  - ダブルクリックで新規ポイント
 *  - 半径一括適用
 *  - Overpass APIでポリゴン表示
 *  - GSIジオコーディング
 *  - CSV/Excelインポート/エクスポート
 *  - ポリゴンタブ(町丁目データ)もインポート/エクスポート、地図に反映(例)
 */
function App() {
  const theme = createTheme({
    palette: {
      primary: {
        main: '#1976d2',
      },
      secondary: {
        main: '#9c27b0',
      },
      background: {
        default: '#f5f5f5',
      },
    },
    components: {
      MuiButton: {
        styleOverrides: {
          root: {
            textTransform: 'none',
          },
        },
      },
      MuiTextField: {
        defaultProps: {
          size: 'small',
          variant: 'outlined',
        },
      },
      MuiTableCell: {
        styleOverrides: {
          root: {
            padding: '8px',
          },
        },
      },
    },
  });

  // --------- 検索関連state ---------
  const [searchType, setSearchType] = React.useState('address');
  const [address, setAddress] = React.useState('');
  const [latInput, setLatInput] = React.useState('');
  const [lonInput, setLonInput] = React.useState('');
  const [message, setMessage] = React.useState(null);

  // --------- タブ関連 ---------
  const [tabValue, setTabValue] = React.useState(0);

  // --------- 半径一括適用 ---------
  const [globalRadius1, setGlobalRadius1] = React.useState(500);
  const [globalColor1, setGlobalColor1] = React.useState('#1976d2');
  const [globalRadius2, setGlobalRadius2] = React.useState(1000);
  const [globalColor2, setGlobalColor2] = React.useState('#9c27b0');
  const [globalRadius3, setGlobalRadius3] = React.useState(1500);
  const [globalColor3, setGlobalColor3] = React.useState('#ff9800');

  // --------- プロット地点テーブル ---------
  // 1行目: 渋谷駅
  const [plotsData, setPlotsData] = React.useState([
    {
      selected: false,
      name: '渋谷駅',
      address: '東京都渋谷区道玄坂2丁目',
      lat: 35.6580,
      lon: 139.7016,
      startDate: '',
      endDate: '',
      sales: '',
      customers: '',
      area: '',
      radius1: 500,
      color1: '#1976d2',
      radius2: 1000,
      color2: '#9c27b0',
      radius3: 1500,
      color3: '#ff9800'
    }
  ]);

  // --------- ポリゴンタブ用データ ---------
  const [polygonsData, setPolygonsData] = React.useState([]);

  // Leaflet関連
  const mapRef = React.useRef(null);
  const [mapInstance, setMapInstance] = React.useState(null);
  const [polygonLayer, setPolygonLayer] = React.useState(null);
  const [markers, setMarkers] = React.useState([]);
  const [circles, setCircles] = React.useState([]);

  // Overpass API キャッシュ
  const overpassCache = React.useRef(new Map());

  const [isCollapsed, setIsCollapsed] = React.useState(false);
  const [plotsPageSize, setPlotsPageSize] = React.useState(20);
  const [plotsPage, setPlotsPage] = React.useState(0);
  const [polygonsPageSize, setPolygonsPageSize] = React.useState(20);
  const [polygonsPage, setPolygonsPage] = React.useState(0);

  // ページ変更ハンドラー
  const handlePlotsPageChange = (event, newPage) => {
    setPlotsPage(newPage);
  };

  const handlePlotsPageSizeChange = (event) => {
    setPlotsPageSize(parseInt(event.target.value, 10));
    setPlotsPage(0);
  };

  const handlePolygonsPageChange = (event, newPage) => {
    setPolygonsPage(newPage);
  };

  const handlePolygonsPageSizeChange = (event) => {
    setPolygonsPageSize(parseInt(event.target.value, 10));
    setPolygonsPage(0);
  };

  // 検索コントロールのドラッグ&ドロップ用state
  const [controlPosition, setControlPosition] = React.useState({ x: 16, y: 16 });
  const [isDragging, setIsDragging] = React.useState(false);
  const dragStartPos = React.useRef({ x: 0, y: 0 });
  const dragOffset = React.useRef({ x: 0, y: 0 });

  // ドラッグ処理ハンドラー
  const handleDragStart = (e) => {
    setIsDragging(true);
    const rect = e.currentTarget.getBoundingClientRect();
    dragOffset.current = {
      x: e.clientX - rect.left,
      y: e.clientY - rect.top
    };
  };

  const handleDrag = (e) => {
    if (!isDragging) return;
    
    const x = e.clientX - dragOffset.current.x;
    const y = e.clientY - dragOffset.current.y;
    
    // 画面範囲内に制限
    const maxX = window.innerWidth - 280; // コントロールの幅を考慮
    const maxY = window.innerHeight - 100; // 適当なマージン
    
    setControlPosition({
      x: Math.min(Math.max(0, x), maxX),
      y: Math.min(Math.max(0, y), maxY)
    });
  };

  const handleDragEnd = () => {
    setIsDragging(false);
  };

  // ドラッグ中のイベントリスナー
  React.useEffect(() => {
    if (isDragging) {
      document.addEventListener('mousemove', handleDrag);
      document.addEventListener('mouseup', handleDragEnd);
    }
    return () => {
      document.removeEventListener('mousemove', handleDrag);
      document.removeEventListener('mouseup', handleDragEnd);
    };
  }, [isDragging]);

  // モーダル制御用のstate
  const [modalOpen, setModalOpen] = React.useState(false);

  // モーダルの開閉ハンドラ
  const handleModalOpen = () => setModalOpen(true);
  const handleModalClose = () => setModalOpen(false);

  // =====================================
  // 1. 地図初期化 (渋谷駅を中心)
  // =====================================
  React.useEffect(() => {
    if (!mapRef.current || mapInstance) return;
    const Lmap = L.map(mapRef.current).setView([35.6580, 139.7016], 14);
    L.tileLayer('https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png', {
      attribution: '© 国土地理院'
    }).addTo(Lmap);

    // マップダブルクリック → 新規行
    Lmap.on('dblclick', (e) => {
      const lt = parseFloat(e.latlng.lat.toFixed(6));
      const ln = parseFloat(e.latlng.lng.toFixed(6));
      setPlotsData(prev => [
        ...prev,
        {
          selected: false,
          name: '新規ポイント',
          address: '',
          lat: lt,
          lon: ln,
          startDate: '',
          endDate: '',
          sales: '',
          customers: '',
          area: '',
          radius1: globalRadius1,
          color1: globalColor1,
          radius2: globalRadius2,
          color2: globalColor2,
          radius3: globalRadius3,
          color3: globalColor3
        }
      ]);
    });

    setMapInstance(Lmap);
  }, [mapRef, mapInstance]);

  // =====================================
  // 2. プロットテーブル変更 → マップ再描画
  // =====================================
  React.useEffect(() => {
    if (mapInstance) {
      applyPlotsData(mapInstance);
    }
  }, [plotsData, mapInstance]); 
  // plotsDataが変わるたびに地図を再描画

  // =====================================
  // 3. 初回に渋谷駅周辺ポリゴン表示
  // =====================================
  React.useEffect(() => {
    if (!mapInstance) return;
    showPolygons(35.6580, 139.7016);
  }, [mapInstance]);

  // =====================================
  // Overpass API / osmtogeojson
  // =====================================
  function generateOverpassQuery(lat, lon, radius) {
    return `
[out:json][timeout:25];
(
  way["boundary"="administrative"]["admin_level"~"^(8|9|10)$"](around:${radius},${lat},${lon});
  relation["boundary"="administrative"]["admin_level"~"^(8|9|10)$"](around:${radius},${lat},${lon});
);
out body;
>;
out skel qt;`;
  }

  async function fetchOverpassData(lat, lon, radius) {
    const key = `${lat},${lon},${radius}`;
    if (overpassCache.current.has(key)) {
      return overpassCache.current.get(key);
    }
    const query = generateOverpassQuery(lat, lon, radius);
    const res = await fetch('https://overpass-api.de/api/interpreter', {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: 'data=' + encodeURIComponent(query)
    });
    if (!res.ok) {
      throw new Error('Overpass APIエラー');
    }
    const data = await res.json();
    const geojson = osmtogeojson(data);
    overpassCache.current.set(key, geojson);
    return geojson;
  }

  function renderGeoJSON(geojson) {
    if (!mapInstance) return;
    if (polygonLayer) {
      mapInstance.removeLayer(polygonLayer);
    }
    const newLayer = L.geoJSON(geojson, {
      style: {
        fillColor: '#2196f3',
        fillOpacity: 0.3,
        color: '#1976d2',
        weight: 2,
      },
      onEachFeature: (feature, layer) => {
        const name = feature.properties?.tags?.name || '不明';
        const admin = feature.properties?.tags?.admin_level || '不明';
        let content = `<strong>${name}</strong> (admin:${admin})`;
        // 中心座標
        try {
          const centroid = turf.centroid(feature);
          const lat = centroid.geometry.coordinates[1].toFixed(6);
          const lon = centroid.geometry.coordinates[0].toFixed(6);
          content += `<br>中心: lat=${lat}, lon=${lon}`;
        } catch(e){}
        layer.bindPopup(content);
      }
    }).addTo(mapInstance);
    setPolygonLayer(newLayer);
    updatePolygonStats(geojson);
  }

  function updatePolygonStats(geojson) {
    const statsDiv = document.getElementById('statsContainer');
    if (!statsDiv) return;
    const count = geojson.features.length;
    statsDiv.style.display = 'block';
    statsDiv.innerHTML = `取得ポリゴン数: ${count}`;
  }

  async function showPolygons(lat, lon) {
    if (!mapInstance) return;
    try {
      const data = await fetchOverpassData(lat, lon, 1500);
      renderGeoJSON(data);
    } catch (err) {
      showError(`ポリゴン取得失敗: ${err.message}`);
    }
  }

  window.showPolygons = (lat, lon) => showPolygons(lat, lon);

  // =====================================
  // GSI ジオコーディング (住所→座標)
  // =====================================
  async function geocodeAddressGSI(addr) {
    const url = `https://msearch.gsi.go.jp/address-search/AddressSearch?q=${encodeURIComponent(addr)}`;
    const res = await fetch(url);
    if (!res.ok) {
      throw new Error('ジオコーディングAPIエラー');
    }
    const data = await res.json();
    if (!data || data.length === 0) {
      throw new Error('住所が見つかりませんでした');
    }
    const tokyo = data.filter(d => d.address && d.address.includes('東京都'));
    const selected = tokyo.length > 0 ? tokyo[0] : data[0];
    const coords = selected.geometry.coordinates; // [lon, lat]
    return {
      lat: coords[1],
      lon: coords[0],
      displayName: selected.address || addr
    };
  }

  // =====================================
  // 検索でテーブルに追加 (名称/住所/lat/lon)
  // =====================================
  async function handleSearch() {
    try {
      setMessage(null);
      if (!mapInstance) return;

      let latVal, lonVal, label;
      if (searchType === 'address') {
        if (!address.trim()) throw new Error('住所を入力してください');
        const result = await geocodeAddressGSI(address.trim());
        latVal = result.lat;
        lonVal = result.lon;
        label = result.displayName; 
      } else {
        // 座標
        latVal = parseFloat(latInput);
        lonVal = parseFloat(lonInput);
        if (isNaN(latVal) || isNaN(lonVal)) {
          throw new Error('緯度経度を正しく入力してください');
        }
        label = `座標指定(${latVal},${lonVal})`;
      }

      // マップ移動 & ポリゴン表示
      mapInstance.setView([latVal, lonVal], 14);
      await showPolygons(latVal, lonVal);

      // テーブルに追加
      setPlotsData(prev => [
        ...prev,
        {
          selected: false,
          name: label,
          address: label,
          lat: latVal,
          lon: lonVal,
          startDate: '',
          endDate: '',
          sales: '',
          customers: '',
          area: '',
          radius1: globalRadius1,
          color1: globalColor1,
          radius2: globalRadius2,
          color2: globalColor2,
          radius3: globalRadius3,
          color3: globalColor3
        }
      ]);
      showSuccess('検索完了: テーブルに追加しました');
    } catch (err) {
      showError(err.message);
    }
  }

  // =====================================
  // メッセージ表示
  // =====================================
  function showError(msg) {
    setMessage(<Box sx={{ color:'error.main', mt:1 }}>{msg}</Box>);
  }
  function showSuccess(msg) {
    setMessage(<Box sx={{ color:'success.main', mt:1 }}>{msg}</Box>);
  }

  // =====================================
  // plotsData → 地図に反映
  // =====================================
  function applyPlotsData(m = mapInstance) {
    if (!m) return;
    // 既存のマーカー/サークル削除
    circles.forEach(c => m.removeLayer(c));
    markers.forEach(mark => m.removeLayer(mark));
    setCircles([]);
    setMarkers([]);

    const newCircles = [];
    const newMarkers = [];

    plotsData.forEach(row => {
      const lt = parseFloat(row.lat);
      const ln = parseFloat(row.lon);
      if (isNaN(lt) || isNaN(ln)) return;

      // 円3つ
      [1,2,3].forEach(i => {
        const r = parseFloat(row[`radius${i}`]);
        const c = row[`color${i}`];
        if (!isNaN(r) && r>0) {
          const circle = L.circle([lt, ln], {
            radius: r,
            color: c,
            fillColor: c,
            fillOpacity: 0.2 - (i*0.05),
          }).addTo(m);
          newCircles.push(circle);
        }
      });

      // マーカー
      const marker = L.marker([lt, ln], {
        icon: L.divIcon({
          className: 'custom-marker',
          html: '📍',
          iconSize: [25,25],
          iconAnchor: [12,25]
        })
      }).addTo(m);

      // マーカークリック → ポリゴン再表示
      marker.on('click', async () => {
        const popupHtml = `
          <div style="min-width:220px">
            <h3>${row.name||'名称未設定'}</h3>
            <p>住所: ${row.address||''}</p>
            <p>緯度: ${lt}</p>
            <p>経度: ${ln}</p>
            <p>売上: ${row.sales||''}</p>
            <p>客数: ${row.customers||''}</p>
            <p>面積: ${row.area||''}</p>
            <p>期間: ${row.startDate||''} ~ ${row.endDate||''}</p>
          </div>
        `;
        marker.bindPopup(popupHtml).openPopup();

        // 地図移動 + ポリゴン
        m.setView([lt, ln], 14);
        await showPolygons(lt, ln);
      });

      newMarkers.push(marker);
    });

    setCircles(newCircles);
    setMarkers(newMarkers);
  }

  // =====================================
  // plotsData テーブル操作
  // =====================================
  function handlePlotsFieldChange(i, field, value) {
    setPlotsData(prev => {
      const cp = [...prev];
      cp[i] = { ...cp[i], [field]: value };
      return cp;
    });
  }
  function handleDeletePlotRow(i) {
    setPlotsData(prev => prev.filter((_, idx) => idx!==i));
  }

  // 半径一括適用
  function handleApplyGlobalRadius() {
    setPlotsData(prev =>
      prev.map(item =>
        item.selected
        ? {
            ...item,
            radius1: globalRadius1,
            color1: globalColor1,
            radius2: globalRadius2,
            color2: globalColor2,
            radius3: globalRadius3,
            color3: globalColor3
          }
        : item
      )
    );
  }

  // =====================================
  // ポリゴンタブ
  // =====================================
  function handleTabChange(e, val) {
    setTabValue(val);
  }

  function handlePolygonFieldChange(i, field, value) {
    setPolygonsData(prev => {
      const cp = [...prev];
      cp[i] = { ...cp[i], [field]: value };
      return cp;
    });
  }
  function handleAddPolygonRow() {
    setPolygonsData(prev => [
      ...prev,
      { name:'', polygonData:'', color:'#1976d2' }
    ]);
  }
  function handleDeletePolygonRow(i) {
    setPolygonsData(prev => prev.filter((_, idx)=> idx!==i));
  }

  // ポリゴンを地図に反映(例: polygonDataをGeoJSONとして読み込む想定)
  function applyPolygonsToMap() {
    if (!mapInstance) return;
    if (polygonLayer) {
      mapInstance.removeLayer(polygonLayer);
    }
    // polygonDataを JSON.parse するなどして読み込み、L.geoJSON(...) で表示する例
    // 簡易実装なので、各行の polygonData が有効なGeoJSON形式であることを想定
    let features = [];
    polygonsData.forEach(row => {
      try {
        if (!row.polygonData) return;
        const geo = JSON.parse(row.polygonData); 
        // color
        features.push({
          ...geo,
          properties: {
            color: row.color||'#1976d2',
            name: row.name||''
          }
        });
      } catch(e){}
    });
    const geojson = {
      type: 'FeatureCollection',
      features: features
    };
    const newLayer = L.geoJSON(geojson, {
      style: (feature) => ({
        color: feature.properties.color||'#1976d2',
        fillColor: feature.properties.color||'#1976d2',
        fillOpacity:0.2,
        weight:2
      }),
      onEachFeature:(feature, layer) => {
        let popup = `<strong>${feature.properties.name||'名称不明'}</strong>`;
        layer.bindPopup(popup);
      }
    }).addTo(mapInstance);
    setPolygonLayer(newLayer);
  }

  // =====================================
  // CSV/Excelインポート・エクスポート
  // =====================================
  function exportData(type, data) {
    const ws = XLSX.utils.json_to_sheet(data);
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, 'Data');
    const buffer = XLSX.write(wb, {bookType:'xlsx', type:'array'});
    const blob = new Blob([buffer], {
      type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `${type}_data.xlsx`;
    link.click();
    URL.revokeObjectURL(url);
  }

  function processImportedData(jsonData, type) {
    if (type === 'plots') {
      const rows = jsonData.map(item => ({
        selected: false,
        name: item.name || '',
        address: item.address || '',
        lat: item.lat || '',
        lon: item.lon || '',
        startDate: item.startDate || '',
        endDate: item.endDate || '',
        sales: item.sales || '',
        customers: item.customers || '',
        area: item.area || '',
        radius1: item.radius1 || 500,
        color1: item.color1 || '#1976d2',
        radius2: item.radius2 || 1000,
        color2: item.color2 || '#9c27b0',
        radius3: item.radius3 || 1500,
        color3: item.color3 || '#ff9800'
      }));
      setPlotsData(prev => [...prev, ...rows]);
    } else {
      // polygons
      const rows = jsonData.map(item => ({
        name: item.name || '',
        polygonData: item.polygonData || '',
        color: item.color || '#1976d2'
      }));
      setPolygonsData(prev => [...prev, ...rows]);
    }
  }

  // =====================================
  // Map Centering Function
  // =====================================
  function handleMoveToMarker(lat, lon) {
    if (mapInstance) {
      mapInstance.setView([lat, lon], 16); // Zoom level can be adjusted
    }
  }

  // =====================================
  // Import Data Function
  // =====================================
  function importData(file, type) {
    const reader = new FileReader();
    reader.onload = (e) => {
      const content = e.target.result;
      let jsonData = [];
      if (file.name.endsWith('.csv')) {
        jsonData = Papa.parse(content, { header: true }).data;
      } else {
        const workbook = XLSX.read(content, { type: 'binary' });
        const sheetName = workbook.SheetNames[0];
        jsonData = XLSX.utils.sheet_to_json(workbook.Sheets[sheetName]);
      }
      processImportedData(jsonData, type);
      showSuccess('インポート完了');
    };
    if (file.name.endsWith('.csv')) {
      reader.readAsText(file);
    } else {
      reader.readAsBinaryString(file);
    }
  }

  // =====================================
  // レンダリング
  // =====================================
  return (
    <ThemeProvider theme={theme}>
      <CssBaseline />
      
      <Box sx={{ display: 'flex', flexDirection: 'column', minHeight: '100vh' }}>
        {/* AppBar with Search & Settings Button */}
        <AppBar position="static" elevation={0}>
          <Toolbar>
            <Typography variant="h6" sx={{ flexGrow: 1 }}>
              All Features: React + Leaflet + MUI
            </Typography>
            {/* Search & Settings Button */}
            <Button 
              color="inherit" 
              onClick={handleModalOpen}
              startIcon={<span>🔍</span>}
            >
              検索＆設定
            </Button>
          </Toolbar>
        </AppBar>

        {/* メインコンテンツ */}
        <Box sx={{ flex: 1, display: 'flex', flexDirection: 'column', gap: 2, p: 2 }}>
          {/* マップセクション */}
          <Paper elevation={1} sx={{ height: '60vh', position: 'relative' }}>
            <div id="map" ref={mapRef} style={{ height: '100%' }}></div>
          </Paper>

          {/* タブセクション */}
          <Paper elevation={1}>
            <Tabs 
              value={tabValue} 
              onChange={handleTabChange}
              sx={{ borderBottom: 1, borderColor: 'divider' }}
            >
              <Tab label="プロット地点" />
              <Tab label="町丁目ポリゴン" />
            </Tabs>
            
            {/* タブパネル内容は既存コードを維持 */}
            {tabValue===0 && (
              <Box sx={{ p:2, overflow:'auto' }}>
                <Box sx={{ display:'flex', gap:1, mb:2 }}>
                  <Button variant="contained" onClick={()=>exportData('plots',plotsData)}>
                    エクスポート
                  </Button>
                  <input
                    id="importPlotsFile"
                    type="file"
                    accept=".csv,.xlsx"
                    style={{ display:'none' }}
                    onChange={(e)=>{
                      if(e.target.files?.[0]) importData(e.target.files[0],'plots');
                    }}
                  />
                  <Button variant="contained" onClick={()=>document.getElementById('importPlotsFile').click()}>
                    インポート
                  </Button>
                </Box>
                <TableContainer 
                  component={Paper} 
                  sx={{ 
                    maxHeight: 'calc(100vh - 300px)',
                    '& .MuiTable-root': {
                      borderCollapse: 'collapse',
                      width: 'max-content',
                      minWidth: '100%'
                    }
                  }}
                >
                  <Table className="compact-table" size="small" stickyHeader>
                    <TableHead>
                      <TableRow>
                        <TableCell className="col-checkbox" padding="checkbox"></TableCell>
                        {/* New Move Column Header */}
                        <TableCell className="col-move">移動</TableCell>
                        <TableCell className="col-name">名称</TableCell>
                        <TableCell className="col-address">住所</TableCell>
                        <TableCell className="col-coord">緯度</TableCell>
                        <TableCell className="col-coord">経度</TableCell>
                        <TableCell className="col-date">開始日</TableCell>
                        <TableCell className="col-date">終了日</TableCell>
                        <TableCell className="col-number">売上</TableCell>
                        <TableCell className="col-number">客数</TableCell>
                        <TableCell className="col-number">面積</TableCell>
                        <TableCell className="col-radius">半径1&色</TableCell>
                        <TableCell className="col-radius">半径2&色</TableCell>
                        <TableCell className="col-radius">半径3&色</TableCell>
                        <TableCell className="col-action">操作</TableCell>
                      </TableRow>
                    </TableHead>
                    <TableBody>
                      {plotsData
                        .slice(plotsPage * plotsPageSize, plotsPage * plotsPageSize + plotsPageSize)
                        .map((row, i) => (
                        <TableRow key={i}>
                          <TableCell padding="checkbox">
                            <Checkbox
                              checked={row.selected||false}
                              onChange={(e)=>
                                handlePlotsFieldChange(i,'selected',e.target.checked)
                              }
                            />
                          </TableCell>
                          {/* New Move Button Column */}
                          <TableCell>
                            <Button 
                              variant="outlined" 
                              size="small"
                              onClick={() => handleMoveToMarker(row.lat, row.lon)}
                            >
                              移動
                            </Button>
                          </TableCell>
                          <TableCell>
                            <TextField
                              variant="outlined" size="small"
                              value={row.name||''}
                              onChange={(e)=>handlePlotsFieldChange(i,'name',e.target.value)}
                            />
                          </TableCell>
                          <TableCell>
                            <TextField
                              variant="outlined" size="small"
                              value={row.address||''}
                              onChange={(e)=>handlePlotsFieldChange(i,'address',e.target.value)}
                            />
                          </TableCell>
                          <TableCell>
                            <TextField
                              type="number" variant="outlined" size="small"
                              value={row.lat||''}
                              onChange={(e)=>handlePlotsFieldChange(i,'lat',e.target.value)}
                            />
                          </TableCell>
                          <TableCell>
                            <TextField
                              type="number" variant="outlined" size="small"
                              value={row.lon||''}
                              onChange={(e)=>handlePlotsFieldChange(i,'lon',e.target.value)}
                            />
                          </TableCell>
                          <TableCell>
                            <TextField
                              type="date" variant="outlined" size="small"
                              value={row.startDate||''}
                              onChange={(e)=>handlePlotsFieldChange(i,'startDate',e.target.value)}
                            />
                          </TableCell>
                          <TableCell>
                            <TextField
                              type="date" variant="outlined" size="small"
                              value={row.endDate||''}
                              onChange={(e)=>handlePlotsFieldChange(i,'endDate',e.target.value)}
                            />
                          </TableCell>
                          <TableCell>
                            <TextField
                              type="number" variant="outlined" size="small"
                              value={row.sales||''}
                              onChange={(e)=>handlePlotsFieldChange(i,'sales',e.target.value)}
                            />
                          </TableCell>
                          <TableCell>
                            <TextField
                              type="number" variant="outlined" size="small"
                              value={row.customers||''}
                              onChange={(e)=>handlePlotsFieldChange(i,'customers',e.target.value)}
                            />
                          </TableCell>
                          <TableCell>
                            <TextField
                              type="number" variant="outlined" size="small"
                              value={row.area||''}
                              onChange={(e)=>handlePlotsFieldChange(i,'area',e.target.value)}
                            />
                          </TableCell>
                          <TableCell>
                            <Box sx={{ display:'flex', gap:1, alignItems:'center' }}>
                              <TextField
                                type="number" variant="outlined" size="small"
                                sx={{ width:60 }}
                                value={row.radius1||500}
                                onChange={(e)=>handlePlotsFieldChange(i,'radius1',e.target.value)}
                              />
                              <input
                                type="color"
                                value={row.color1||'#1976d2'}
                                onChange={(e)=>handlePlotsFieldChange(i,'color1',e.target.value)}
                                style={{ width:'40px', height:'30px', border:'none' }}
                              />
                            </Box>
                          </TableCell>
                          <TableCell>
                            <Box sx={{ display:'flex', gap:1, alignItems:'center' }}>
                              <TextField
                                type="number" variant="outlined" size="small"
                                sx={{ width:60 }}
                                value={row.radius2||1000}
                                onChange={(e)=>handlePlotsFieldChange(i,'radius2',e.target.value)}
                              />
                              <input
                                type="color"
                                value={row.color2||'#9c27b0'}
                                onChange={(e)=>handlePlotsFieldChange(i,'color2',e.target.value)}
                                style={{ width:'40px', height:'30px', border:'none' }}
                              />
                            </Box>
                          </TableCell>
                          <TableCell>
                            <Box sx={{ display:'flex', gap:1, alignItems:'center' }}>
                              <TextField
                                type="number" variant="outlined" size="small"
                                sx={{ width:60 }}
                                value={row.radius3||1500}
                                onChange={(e)=>handlePlotsFieldChange(i,'radius3',e.target.value)}
                              />
                              <input
                                type="color"
                                value={row.color3||'#ff9800'}
                                onChange={(e)=>handlePlotsFieldChange(i,'color3',e.target.value)}
                                style={{ width:'40px', height:'30px', border:'none' }}
                              />
                            </Box>
                          </TableCell>
                          <TableCell>
                            <IconButton size="small" onClick={()=>handleDeletePlotRow(i)}>
                              🗑️
                            </IconButton>
                          </TableCell>
                        </TableRow>
                      ))}
                    </TableBody>
                  </Table>
                </TableContainer>
                <Box sx={{ display: 'flex', alignItems: 'center', gap: 2, mt: 2 }}>
                  <TablePagination
                    component="div"
                    count={plotsData.length}
                    page={plotsPage}
                    onPageChange={handlePlotsPageChange}
                    rowsPerPage={plotsPageSize}
                    onRowsPerPageChange={handlePlotsPageSizeChange}
                    rowsPerPageOptions={[10, 20, 30, { label: '全て', value: -1 }]}
                    labelRowsPerPage="表示件数:"
                  />
                </Box>
              </Box>
            )}

            {/* ポリゴンタブ */}
            {tabValue===1 && (
              <Box sx={{ p:2, overflowX:'auto' }}>
                <Box sx={{ display:'flex', gap:1, mb:2 }}>
                  <Button variant="contained" onClick={handleAddPolygonRow}>
                    新規追加
                  </Button>
                  <Button variant="contained" onClick={applyPolygonsToMap}>
                    地図に反映
                  </Button>
                  <Button variant="contained" onClick={()=>exportData('polygons', polygonsData)}>
                    エクスポート
                  </Button>
                  <input
                    id="importPolygonsFile"
                    type="file"
                    accept=".csv,.xlsx"
                    style={{ display:'none' }}
                    onChange={(e)=>{
                      if(e.target.files?.[0]) importData(e.target.files[0], 'polygons');
                    }}
                  />
                  <Button variant="contained" onClick={()=>document.getElementById('importPolygonsFile').click()}>
                    インポート
                  </Button>
                </Box>

                <TableContainer component={Paper} sx={{ maxHeight: 'calc(100vh - 350px)' }}>
                  <Table className="compact-table" size="small" stickyHeader>
                    <TableHead>
                      <TableRow>
                        <TableCell>町丁目名</TableCell>
                        <TableCell>ポリゴンデータ(JSON)</TableCell>
                        <TableCell>色</TableCell>
                        <TableCell>操作</TableCell>
                      </TableRow>
                    </TableHead>
                    <TableBody>
                      {polygonsData
                        .slice(polygonsPage * polygonsPageSize, polygonsPage * polygonsPageSize + polygonsPageSize)
                        .map((row, i) => (
                        <TableRow key={i}>
                          <TableCell>
                            <TextField
                              variant="outlined" size="small"
                              value={row.name||''}
                              onChange={(e)=>handlePolygonFieldChange(i,'name',e.target.value)}
                            />
                          </TableCell>
                          <TableCell>
                            <TextField
                              variant="outlined" size="small" fullWidth
                              placeholder='{"type":"Feature","geometry":{...}}'
                              value={row.polygonData||''}
                              onChange={(e)=>handlePolygonFieldChange(i,'polygonData',e.target.value)}
                            />
                          </TableCell>
                          <TableCell>
                            <input
                              type="color"
                              value={row.color||'#1976d2'}
                              onChange={(e)=>handlePolygonFieldChange(i,'color',e.target.value)}
                              style={{ width:'40px', height:'30px', border:'none' }}
                            />
                          </TableCell>
                          <TableCell>
                            <IconButton size="small" onClick={()=>handleDeletePolygonRow(i)}>
                              🗑️
                            </IconButton>
                          </TableCell>
                        </TableRow>
                      ))}
                    </TableBody>
                  </Table>
                </TableContainer>
                <Box sx={{ display: 'flex', alignItems: 'center', gap: 2, mt: 2 }}>
                  <TablePagination
                    component="div"
                    count={polygonsData.length}
                    page={polygonsPage}
                    onPageChange={handlePolygonsPageChange}
                    rowsPerPage={polygonsPageSize}
                    onRowsPerPageChange={handlePolygonsPageSizeChange}
                    rowsPerPageOptions={[10, 20, 30, { label: '全て', value: -1 }]}
                    labelRowsPerPage="表示件数:"
                  />
                </Box>
              </Box>
            )}
          </Paper>
        </Box>

        {/* フッター */}
        <Box component="footer" sx={{ 
          py: 2, 
          px: 3, 
          mt: 'auto', 
          backgroundColor: 'background.paper',
          borderTop: 1,
          borderColor: 'divider'
        }}>
          <Typography variant="body2" color="text.secondary" align="center">
            © 2023 Map Application
          </Typography>
        </Box>
      </Box>

      {/* モーダルダイアログ */}
      <Dialog 
        open={modalOpen} 
        onClose={handleModalClose}
        maxWidth="sm"
        fullWidth
        PaperProps={{
          elevation: 2,
          sx: { borderRadius: 2 }
        }}
      >
        <DialogTitle>
          <Box className="modal-header" sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
            検索＆設定
            <IconButton 
              className="close-button"
              onClick={handleModalClose}
            >
              ✖
            </IconButton>
          </Box>
        </DialogTitle>
        <DialogContent className="modal-content">
          {/* 検索セクション */}
          <Box className="modal-section" sx={{ mb: 4 }}>
            <Typography variant="subtitle1" className="modal-section-title">
              🔍 地点検索
            </Typography>
            <FormControl>
              <RadioGroup row value={searchType} onChange={(e)=>setSearchType(e.target.value)}>
                <FormControlLabel value="address" control={<Radio/>} label="住所検索"/>
                <FormControlLabel value="coords" control={<Radio/>} label="座標検索"/>
              </RadioGroup>
            </FormControl>
            
            {searchType==='address' ? (
              <TextField
                label="住所"
                variant="outlined"
                size="small"
                fullWidth
                value={address}
                onChange={(e)=>setAddress(e.target.value)}
                sx={{ mt:1 }}
              />
            ) : (
              <Box sx={{ display:'flex', gap:1, mt:1 }}>
                <TextField
                  label="緯度"
                  variant="outlined"
                  size="small"
                  fullWidth
                  value={latInput}
                  onChange={(e)=>setLatInput(e.target.value)}
                />
                <TextField
                  label="経度"
                  variant="outlined"
                  size="small"
                  fullWidth
                  value={lonInput}
                  onChange={(e)=>setLonInput(e.target.value)}
                />
              </Box>
            )}
            <Box className="modal-actions" sx={{ mt:2 }}>
              <Button 
                variant="contained" 
                onClick={() => {
                  handleSearch();
                  handleModalClose();
                }}
                startIcon={<span>🔍</span>}
              >
                検索して追加
              </Button>
            </Box>
            {message && <Box sx={{mt:2}}>{message}</Box>}
          </Box>

          {/* 半径設定セクション */}
          <Box className="modal-section">
            <Typography variant="subtitle1" className="modal-section-title">
              ⭕ 半径設定の一括適用
            </Typography>
            <Box sx={{ display:'flex', flexDirection:'column', gap:2, mt:1 }}>
              <Box sx={{ display:'flex', gap:1, alignItems:'center' }}>
                <TextField
                  label="半径1"
                  type="number"
                  size="small"
                  value={globalRadius1}
                  onChange={(e)=>setGlobalRadius1(e.target.value)}
                  sx={{ width:120 }}
                />
                <input
                  type="color"
                  value={globalColor1}
                  onChange={(e)=>setGlobalColor1(e.target.value)}
                  style={{ width:'40px', height:'30px', border:'none' }}
                />
                <Typography variant="body2" color="text.secondary">m</Typography>
              </Box>
              <Box sx={{ display:'flex', gap:1, alignItems:'center' }}>
                <TextField
                  label="半径2"
                  type="number"
                  size="small"
                  value={globalRadius2}
                  onChange={(e)=>setGlobalRadius2(e.target.value)}
                  sx={{ width:120 }}
                />
                <input
                  type="color"
                  value={globalColor2}
                  onChange={(e)=>setGlobalColor2(e.target.value)}
                  style={{ width:'40px', height:'30px', border:'none' }}
                />
                <Typography variant="body2" color="text.secondary">m</Typography>
              </Box>
              <Box sx={{ display:'flex', gap:1, alignItems:'center' }}>
                <TextField
                  label="半径3"
                  type="number"
                  size="small"
                  value={globalRadius3}
                  onChange={(e)=>setGlobalRadius3(e.target.value)}
                  sx={{ width:120 }}
                />
                <input
                  type="color"
                  value={globalColor3}
                  onChange={(e)=>setGlobalColor3(e.target.value)}
                  style={{ width:'40px', height:'30px', border:'none' }}
                />
                <Typography variant="body2" color="text.secondary">m</Typography>
              </Box>
            </Box>
            <Box className="modal-actions" sx={{ display:'flex', justifyContent: 'flex-end', gap:1, mt:2 }}>
              <Button 
                variant="outlined" 
                onClick={handleModalClose}
                startIcon={<span>✖</span>}
              >
                キャンセル
              </Button>
              <Button 
                variant="contained" 
                color="primary"
                onClick={() => {
                  handleApplyGlobalRadius();
                  handleModalClose();
                }}
                startIcon={<span>✓</span>}
              >
                選択項目に適用
              </Button>
            </Box>
          </Box>
        </DialogContent>
      </Dialog>

    </ThemeProvider>
  );
}

ReactDOM.createRoot(document.getElementById('root')).render(<App />);
</script>
</body>
</html>
