<!DOCTYPE html>
<html>
<head>
  <title>React Leaflet with GSI Tiles</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

  <!-- osmtogeojson JS (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/osmtogeojson@3.0.0-beta.5/osmtogeojson.min.js"></script>

  <!-- turf.js for spatial operations -->
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

  <!-- SheetJS for Excel handling -->
  <script src="https://cdn.sheetjs.com/xlsx-0.19.3/package/dist/xlsx.full.min.js"></script>
  <!-- PapaParse for CSV handling -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.0/papaparse.min.js"></script>

  <style>
    body { margin: 0; padding: 0; font-family: Arial, sans-serif; }
    #map { width: 100%; height: 55vh; }
    #controls {
      width: 100%;
      height: 15vh;
      background: #f9f9f9;
      padding: 10px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      border-bottom: 1px solid #ccc;
    }
    .input-group {
      margin: 5px 0;
      display: flex;
      align-items: center;
    }
    .input-group label {
      margin-right: 10px;
      font-weight: bold;
    }
    #addressInput, #latInput, #lonInput {
      width: 300px;
      padding: 8px;
      font-size: 16px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    #latInput, #lonInput {
      width: 140px;
    }
    #searchButton {
      padding: 8px 16px;
      margin-top: 10px;
      font-size: 16px;
      border: none;
      border-radius: 4px;
      background-color: #66c2a5;
      color: white;
      cursor: pointer;
    }
    #searchButton:hover {
      background-color: #559f8f;
    }
    #info {
      position: absolute;
      top: 60px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 255, 255, 0.9);
      padding: 10px;
      border-radius: 5px;
      z-index: 1000;
      font-size: 14px;
      display: none;
      max-width: 80%;
      word-wrap: break-word;
    }
    .radio-group {
      margin: 10px 0;
      display: flex;
      align-items: center;
    }
    .radio-group input {
      margin-right: 5px;
    }
    .loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 255, 255, 0.9);
      padding: 20px;
      border-radius: 5px;
      z-index: 1000;
    }
    #resultStats {
      margin-top: 10px;
      font-size: 0.9em;
      color: #666;
    }
    .error {
      color: #d32f2f;
      background: #ffebee;
      padding: 10px;
      border-radius: 4px;
      margin-top: 10px;
    }
    #dataEditor {
      width: 100%;
      height: 30vh;
      background: #ffffff;
      padding: 10px;
      box-sizing: border-box;
      border-top: 1px solid #ccc;
    }
    .data-grid {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
    }
    .data-grid th, .data-grid td {
      border: 1px solid #ddd;
      padding: 4px;
      text-align: left;
      font-size: 12px;
    }
    .data-grid input {
      width: 90%;
      padding: 2px;
      font-size: 12px;
    }
    .data-grid th {
      background-color: #f5f5f5;
    }
    .data-actions {
      margin: 10px 0;
    }
    .data-actions button {
      margin-right: 10px;
      padding: 5px 10px;
      background-color: #66c2a5;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    .delete-row {
      color: #d32f2f;
      cursor: pointer;
    }
    .search-address-btn {
      padding: 2px 4px;
      margin-left: 4px;
      background: #66c2a5;
      color: white;
      border: none;
      border-radius: 3px;
      cursor: pointer;
    }
    .data-grid tr:hover {
      background-color: #f5f5f5;
      cursor: pointer;
    }
    /* タブ用スタイル */
    .tab-container {
      width: 100%;
      margin-top: 10px;
    }
    
    .tab-buttons {
      display: flex;
      border-bottom: 1px solid #ccc;
    }
    
    .tab-button {
      padding: 10px 20px;
      border: none;
      background: none;
      cursor: pointer;
    }
    
    .tab-button.active {
      border-bottom: 2px solid #66c2a5;
      font-weight: bold;
    }
    
    .tab-content {
      display: none;
      padding: 15px;
    }
    
    .tab-content.active {
      display: block;
    }

    /* 統計情報表示の改善 */
    #statsContainer {
      position: fixed;
      top: 10px;
      right: 10px;
      background: rgba(255, 255, 255, 0.9);
      padding: 10px;
      border-radius: 5px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      z-index: 1000;
    }

    /* エクスポート/インポートボタン */
    .data-actions {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
    }

    .action-button {
      padding: 5px 10px;
      background: #66c2a5;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    .action-button:hover {
      background: #559f8f;
    }

    /* テーブル列幅の調整 */
    .data-grid th, .data-grid td {
      padding: 4px;
      font-size: 12px;
    }
    .data-grid th:nth-child(1), .data-grid td:nth-child(1) { width: 150px; } /* 名称 */
    .data-grid th:nth-child(2), .data-grid td:nth-child(2) { width: 100px; } /* 開始日 */
    .data-grid th:nth-child(3), .data-grid td:nth-child(3) { width: 100px; } /* 終了日 */
    .data-grid th:nth-child(4), .data-grid td:nth-child(4) { width: 80px; } /* 売上 */
    .data-grid th:nth-child(5), .data-grid td:nth-child(5) { width: 80px; } /* 客数 */
    .data-grid th:nth-child(6), .data-grid td:nth-child(6) { width: 80px; } /* 面積 */
    .data-grid th:nth-child(7), .data-grid td:nth-child(7) { width: 200px; } /* 住所 */
    .data-grid th:nth-child(8), .data-grid td:nth-child(8) { width: 90px; } /* 緯度 */
    .data-grid th:nth-child(9), .data-grid td:nth-child(9) { width: 90px; } /* 経度 */
    .data-grid th:nth-child(10), .data-grid td:nth-child(10) { width: 70px; } /* 半径1 */
    .data-grid th:nth-child(11), .data-grid td:nth-child(11) { width: 70px; } /* 半径2 */
    .data-grid th:nth-child(12), .data-grid td:nth-child(12) { width: 70px; } /* 半径3 */
    .data-grid th:nth-child(13), .data-grid td:nth-child(13) { width: 70px; } /* 色 */
    .data-grid th:nth-child(14), .data-grid td:nth-child(14) { width: 50px; } /* 操作 */

    /* マーカーポップアップのスタイル */
    .marker-popup {
      min-width: 300px;
    }
    .marker-popup h3 {
      margin: 0 0 10px 0;
      color: #333;
    }
    .marker-popup-content {
      margin-bottom: 10px;
    }
    .marker-popup-links {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }
    .marker-popup-links a {
      padding: 5px 10px;
      background: #66c2a5;
      color: white;
      text-decoration: none;
      border-radius: 3px;
    }
    .marker-popup-links a:hover {
      background: #559f8f;
    }
  </style>
</head>
<body>
  <div id="controls">
    <div class="radio-group">
      <input type="radio" id="searchByAddress" name="searchType" value="address" checked>
      <label for="searchByAddress">住所で検索</label>
      <input type="radio" id="searchByCoords" name="searchType" value="coords" style="margin-left: 20px;">
      <label for="searchByCoords">緯度経度で検索</label>
    </div>
    <div class="input-group" id="addressGroup">
      <label for="addressInput">住所:</label>
      <input type="text" id="addressInput" placeholder="住所を入力してください" />
    </div>
    <div class="input-group" id="coordsGroup" style="display: none;">
      <label for="latInput">緯度:</label>
      <input type="text" id="latInput" placeholder="例: 35.6871682" />
      <label for="lonInput" style="margin-left: 10px;">経度:</label>
      <input type="text" id="lonInput" placeholder="例: 139.710645" />
    </div>
    <button id="searchButton">検索</button>
    <div id="resultStats"></div>
  </div>
  <div id="loading" class="loading" style="display: none;">データを取得中...</div>
  <div id="info">Loading data...</div>
  <div id="map"></div>
  <div id="dataEditor">
    <div class="tab-container">
      <div class="tab-buttons">
        <button class="tab-button active" data-tab="plots">プロット地点</button>
        <button class="tab-button" data-tab="polygons">町丁目ポリゴン</button>
      </div>
      
      <!-- プロット地点タブ -->
      <div id="plotsTab" class="tab-content active">
        <div class="data-actions">
          <button class="action-button" id="addPlotRow">新規追加</button>
          <button class="action-button" id="applyPlots">地図に反映</button>
          <button class="action-button" id="exportPlots">エクスポート</button>
          <input type="file" id="importPlots" accept=".csv,.xlsx" style="display: none;">
          <button class="action-button" onclick="document.getElementById('importPlots').click()">インポート</button>
        </div>
        <table class="data-grid">
          <thead>
            <tr>
              <th>名称</th>
              <th>開始日</th>
              <th>終了日</th>
              <th>売上</th>
              <th>客数</th>
              <th>面積</th>
              <th>住所</th>
              <th>緯度</th>
              <th>経度</th>
              <th>半径1</th>
              <th>半径2</th>
              <th>半径3</th>
              <th>色</th>
              <th>操作</th>
            </tr>
          </thead>
          <tbody id="plotsGrid"></tbody>
        </table>
      </div>
      
      <!-- 町丁目ポリゴンタブ -->
      <div id="polygonsTab" class="tab-content">
        <div class="data-actions">
          <button class="action-button" id="addPolygonRow">新規追加</button>
          <button class="action-button" id="applyPolygons">地図に反映</button>
          <button class="action-button" id="exportPolygons">エクスポート</button>
          <input type="file" id="importPolygons" accept=".csv,.xlsx" style="display: none;">
          <button class="action-button" onclick="document.getElementById('importPolygons').click()">インポート</button>
        </div>
        <table class="data-grid">
          <thead>
            <tr>
              <th>町丁目名</th>
              <th>ポリゴンデータ</th>
              <th>色</th>
              <th>操作</th>
            </tr>
          </thead>
          <tbody id="polygonsGrid"></tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- 統計情報表示用の要素 -->
  <div id="statsContainer" style="display: none;">
    <div id="polygonStats"></div>
  </div>

  <script>
    // 初期設定（渋谷）
    let centerLat = 35.6580;
    let centerLon = 139.7016;
    const radius = 1500; // 半径1500m

    // 初期ポイントのデータ
    const defaultPoint = {
      name: '渋谷駅',
      lat: 35.6580,
      lon: 139.7016,
      radius: 1500,
      color: '#66c2a5'
    };

    // 地図の初期化
    const map = L.map('map').setView([centerLat, centerLon], 14);

    // 背景地図：国土地理院の地理院地図
    L.tileLayer('https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png', {
      attribution: '&copy; <a href="https://maps.gsi.go.jp/">国土地理院</a>'
    }).addTo(map);

    // 初期円の描画
    let searchCircle = L.circle([centerLat, centerLon], {
      radius: radius, // 半径1500m
      color: 'blue', // 境界線の色
      weight: 2,     // 境界線の太さ
      fillOpacity: 0.1 // 塗りつぶしの透明度
    }).addTo(map);

    // キャッシュを導入してAPI呼び出しを最適化
    const cache = new Map();
    
    // デバウンス関数
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    // Overpass APIクエリを生成する関数
    function generateOverpassQuery(lat, lon, radius) {
      return `
[out:json][timeout:25];
(
  relation["admin_level"~"^(8|9|10)$"](around:${radius},${lat},${lon});
  way["admin_level"~"^(8|9|10)$"](around:${radius},${lat},${lon});
);
out geom;`;
    }

    const overpassApiUrl = 'https://overpass-api.de/api/interpreter';

    // 情報表示用要素
    const infoDiv = document.getElementById('info');

    // ポリゴンレイヤーの初期化
    let polygonLayer = null;

    // 検索した住所のマーカーを保持
    let addressMarker = null;

    // GeoJSONデータの描画
    function renderGeoJSON(geojsonData) {
      // デバッグ: 取得したポリゴンの数を表示
      console.log('取得したポリゴンの数:', geojsonData.features.length);

      // フィルタリングを解除してすべてのポリゴンを表示
      const filteredFeatures = geojsonData.features;

      // デバッグ: フィルタリング後のポリゴン数を表示
      console.log('表示されるポリゴンの数:', filteredFeatures.length);

      // 既存のポリゴンレイヤーを削除
      if (polygonLayer && map.hasLayer(polygonLayer)) {
        map.removeLayer(polygonLayer);
      }

      // フィルタリングされたポリゴンをGeoJSONとしてまとめる
      const filteredGeoJSON = {
        type: "FeatureCollection",
        features: filteredFeatures
      };

      // GeoJSONを地図に追加
      polygonLayer = L.geoJSON(filteredGeoJSON, {
        style: function(feature) {
          return {
            fillColor: '#66c2a5', // 塗りつぶし色
            fillOpacity: 0.4,     // 塗りつぶし透明度
            color: '#1b7837',     // 境界線の色
            weight: 1.5           // 境界線の太さ
          };
        },
        onEachFeature: function(feature, layer) {
          const name = feature.properties && feature.properties.tags && feature.properties.tags.name
                       ? feature.properties.tags.name
                       : '不明';
          const adminLevel = feature.properties && feature.properties.tags && feature.properties.tags.admin_level
                             ? feature.properties.tags.admin_level
                             : '不明';
          let popupContent = `<b>町または字:</b> ${name}<br><b>Admin Level:</b> ${adminLevel}`;
          
          // Turf.jsを使用してポリゴンのセントロイドを計算
          try {
            const centroid = turf.centroid(feature);
            const centroidCoords = centroid.geometry.coordinates;
            const lat = centroidCoords[1].toFixed(6);
            const lon = centroidCoords[0].toFixed(6);
            popupContent += `<br><b>セントロイド緯度:</b> ${lat}<br><b>セントロイド経度:</b> ${lon}`;
          } catch (error) {
            console.error('セントロイド計算エラー:', error, 'Feature:', feature);
            popupContent += `<br><b>セントロイド緯度:</b> 不明<br><b>セントロイド経度:</b> 不明`;
          }

          layer.bindPopup(popupContent);
        }
      }).addTo(map);
    }

    // Overpass APIからデータを取得する関数
    async function fetchOverpassData(lat, lon, radius) {
      const cacheKey = `${lat},${lon},${radius}`;
      if (cache.has(cacheKey)) {
        return cache.get(cacheKey);
      }

      const loading = document.getElementById('loading');
      loading.style.display = 'block';

      try {
        const response = await fetch(overpassApiUrl, {
          method: 'POST',
          headers: {'Content-Type': 'application/x-www-form-urlencoded'},
          body: 'data=' + encodeURIComponent(generateOverpassQuery(lat, lon, radius))
        });

        if (!response.ok) throw new Error('Network response was not ok');
        
        const data = await response.json();
        const geojsonData = osmtogeojson(data);
        cache.set(cacheKey, geojsonData);
        
        return geojsonData;
      } catch (error) {
        throw new Error('データの取得に失敗しました: ' + error.message);
      } finally {
        loading.style.display = 'none';
      }
    }

    // 国土地理院のジオコーディングAPIを使用して住所から緯度経度を取得する関数
    function geocodeAddressGSI(address) {
      // 国土地理院のジオコーディングAPIエンドポイント
      const gsiGeocoderUrl = `https://msearch.gsi.go.jp/address-search/AddressSearch?q=${encodeURIComponent(address)}`;

      console.log('GSI ジオコーディングリクエスト URL:', gsiGeocoderUrl); // デバッグログ

      return fetch(gsiGeocoderUrl)
        .then(response => {
          if (!response.ok) {
            throw new Error('Network response was not ok: ' + response.statusText);
          }
          return response.json();
        })
        .then(data => {
          // デバッグ用ログ
          console.log('取得したGSIジオコーディングデータ:', data);

          if (!data || data.length === 0) {
            throw new Error('住所が見つかりませんでした。');
          }

          // 「東京都」を含む結果を優先的にフィルタリング
          const tokyoResults = data.filter(result => {
            return result.address && result.address.includes('東京都');
          });

          let selectedResult;

          if (tokyoResults.length > 0) {
            // 「東京都」を含む最初の結果を選択
            selectedResult = tokyoResults[0];
          } else {
            // 「東京都」を含まない場合は最初の結果を使用
            selectedResult = data[0];
          }

          const coordinates = selectedResult.geometry.coordinates; // [経度, 緯度]

          // displayNameの取得方法を修正
          const displayName = selectedResult.address || address;

          console.log('ジオコーディング結果:', coordinates, displayName); // デバッグログ

          return {
            lat: coordinates[1],
            lon: coordinates[0],
            displayName: displayName
          };
        });
    }

    // 緯度経度を使用して地図を更新する関数
    const updateMapWithCoords = debounce(async (lat, lon, displayName = '指定座標') => {
      try {
        // 既存のレイヤーをクリア（カスタムレイヤーは維持）
        if (searchCircle) map.removeLayer(searchCircle);
        if (addressMarker) map.removeLayer(addressMarker);
        if (polygonLayer) map.removeLayer(polygonLayer);

        // 新しい表示要素を追加
        searchCircle = L.circle([lat, lon], {
          radius,
          color: 'blue',
          weight: 2,
          fillOpacity: 0.1
        }).addTo(map);

        addressMarker = L.marker([lat, lon])
          .bindPopup(`<b>検索結果:</b> ${displayName}<br><b>緯度:</b> ${lat.toFixed(6)}<br><b>経度:</b> ${lon.toFixed(6)}`)
          .addTo(map);

        // データ取得と描画
        const geojsonData = await fetchOverpassData(lat, lon, radius);
        renderGeoJSON(geojsonData);

        // 統計情報を更新
        updateStats(geojsonData);

        map.setView([lat, lon], 14);
      } catch (error) {
        showError(error.message);
      }
    }, 500);

    // 統計情報の更新
    function updateStats(geojsonData) {
      const stats = document.getElementById('polygonStats');
      const count = geojsonData.features.length;
      stats.innerHTML = `
        <strong>ポリゴン統計:</strong><br>
        取得: ${count}件<br>
        表示: ${count}件
      `;
      document.getElementById('statsContainer').style.display = 'block';
    }

    // エラー表示
    function showError(message) {
      const stats = document.getElementById('resultStats');
      stats.innerHTML = `<div class="error">${message}</div>`;
    }

    // イベントリスナーを最適化
    function initEventListeners() {
      document.getElementById('searchButton').addEventListener('click', handleSearch);
      
      ['addressInput', 'latInput', 'lonInput'].forEach(id => {
        document.getElementById(id).addEventListener('keypress', e => {
          if (e.key === 'Enter') handleSearch();
        });
      });

      // ラジオボタンの切り替え
      document.querySelectorAll('input[name="searchType"]').forEach(radio => {
        radio.addEventListener('change', () => {
          document.getElementById('addressGroup').style.display = 
            radio.value === 'address' ? 'flex' : 'none';
          document.getElementById('coordsGroup').style.display = 
            radio.value === 'coords' ? 'flex' : 'none';
        });
      });
    }

    // 検索ハンドラを統合
    async function handleSearch() {
      const searchType = document.querySelector('input[name="searchType"]:checked').value;
      
      try {
        if (searchType === 'address') {
          const address = document.getElementById('addressInput').value.trim();
          if (!address) throw new Error('住所を入力してください');
          
          const result = await geocodeAddressGSI(address);
          updateMapWithCoords(result.lat, result.lon, result.displayName);
          // 検索結果をプロット地点に追加
          addSearchResultToPlots(result.lat, result.lon, result.displayName);
        } else {
          const lat = parseFloat(document.getElementById('latInput').value);
          const lon = parseFloat(document.getElementById('lonInput').value);
          
          if (isNaN(lat) || isNaN(lon)) throw new Error('有効な緯度経度を入力してください');
          if (lat < -90 || lat > 90) throw new Error('緯度は -90 から 90 の範囲で入力してください');
          if (lon < -180 || lon > 180) throw new Error('経度は -180 から 180 の範囲で入力してください');
          
          updateMapWithCoords(lat, lon);
          // 検索結果をプロット地点に追加
          addSearchResultToPlots(lat, lon, '座標指定地点');
        }
      } catch (error) {
        showError(error.message);
      }
    }

    // ファイル選択ハンドラ
    function handleFileSelect(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function(e) {
        const data = new Uint8Array(e.target.result);
        const workbook = XLSX.read(data, { type: 'array' });
        const firstSheetName = workbook.SheetNames[0];
        const worksheet = workbook.Sheets[firstSheetName];
        const json = XLSX.utils.sheet_to_json(worksheet, { header: 1 });

        // CSVファイルの場合
        if (file.type === 'text/csv') {
          Papa.parse(file, {
            complete: function(results) {
              console.log('CSVデータ:', results.data);
              // CSVデータの処理
            }
          });
        } else {
          console.log('Excelデータ:', json);
          // Excelデータの処理
        }
      };
      reader.readAsArrayBuffer(file);
    }

    // データ管理用の配列
    let customData = [];

    // 新規行の追加
    function addNewRow(data = null) {
      const row = document.createElement('tr');
      const fields = [
        { name: 'name', type: 'text' },
        { name: 'startDate', type: 'date' },
        { name: 'endDate', type: 'date' },
        { name: 'sales', type: 'number' },
        { name: 'customers', type: 'number' },
        { name: 'area', type: 'number' },
        { name: 'address', type: 'text' },
        { name: 'lat', type: 'number' },
        { name: 'lon', type: 'number' },
        { name: 'radius1', type: 'number' },
        { name: 'radius2', type: 'number' },
        { name: 'radius3', type: 'number' },
        { name: 'color', type: 'color' }
      ];
      
      fields.forEach(field => {
        const td = document.createElement('td');
        const input = document.createElement('input');
        input.type = field.type;
        input.className = `field-${field.name}`;
        
        // デフォルト値の設定
        if (data && data[field.name]) {
          input.value = data[field.name];
        } else {
          switch (field.name) {
            case 'radius1': input.value = '500'; break;
            case 'radius2': input.value = '1000'; break;
            case 'radius3': input.value = '1500'; break;
            case 'color': input.value = '#66c2a5'; break;
          }
        }
        
        td.appendChild(input);
        
        // 住所フィールドの場合、検索ボタンを追加
        if (field.name === 'address') {
          const searchBtn = document.createElement('button');
          searchBtn.textContent = '🔍';
          searchBtn.className = 'search-address-btn';
          searchBtn.onclick = async (e) => {
            e.stopPropagation(); // 行のクリックイベントを防止
            const addressInput = td.querySelector('input');
            const nameInput = row.querySelector('.field-name');
            const address = addressInput.value.trim();
            const name = nameInput.value.trim();
            
            try {
              let result;
              if (address) {
                result = await geocodeAddressGSI(address);
              } else if (name) {
                result = await geocodeAddressGSI(name);
              } else {
                throw new Error('住所または名称を入力してください');
              }
              
              // 緯度経度を更新
              row.querySelector('.field-lat').value = result.lat;
              row.querySelector('.field-lon').value = result.lon;
              
              // 地図を更新
              updateMapWithCoords(result.lat, result.lon, result.displayName);
            } catch (error) {
              showError(error.message);
            }
          };
          td.appendChild(searchBtn);
        }
        
        row.appendChild(td);
      });
      
      // 削除ボタンの追加
      const actionTd = document.createElement('td');
      const deleteBtn = document.createElement('span');
      deleteBtn.innerHTML = '🗑️';
      deleteBtn.className = 'delete-row';
      deleteBtn.onclick = (e) => {
        e.stopPropagation(); // 行のクリックイベントを防止
        row.remove();
        applyCustomData();
      };
      actionTd.appendChild(deleteBtn);
      row.appendChild(actionTd);
      
      // 行クリック時のイベント
      row.addEventListener('click', () => {
        const lat = parseFloat(row.querySelector('.field-lat').value);
        const lon = parseFloat(row.querySelector('.field-lon').value);
        const name = row.querySelector('.field-name').value;
        
        if (!isNaN(lat) && !isNaN(lon)) {
          map.setView([lat, lon], 14);
        }
      });
      
      document.getElementById('plotsGrid').appendChild(row);
    }

    // データを地図に反映
    function applyCustomData() {
      // 既存のカスタムレイヤーとマーカーをクリア
      if (window.customLayers) {
        window.customLayers.forEach(layer => map.removeLayer(layer));
      }
      window.customLayers = [];
      markers.forEach(marker => map.removeLayer(marker));
      markers = [];

      const rows = document.querySelectorAll('#plotsGrid tr');
      const newData = [];
      
      rows.forEach(row => {
        try {
          const data = {
            name: row.querySelector('.field-name').value,
            startDate: row.querySelector('.field-startDate').value,
            endDate: row.querySelector('.field-endDate').value,
            sales: parseFloat(row.querySelector('.field-sales').value),
            customers: parseInt(row.querySelector('.field-customers').value),
            area: parseFloat(row.querySelector('.field-area').value),
            address: row.querySelector('.field-address').value,
            lat: parseFloat(row.querySelector('.field-lat').value),
            lon: parseFloat(row.querySelector('.field-lon').value),
            radius1: parseInt(row.querySelector('.field-radius1').value),
            radius2: parseInt(row.querySelector('.field-radius2').value),
            radius3: parseInt(row.querySelector('.field-radius3').value),
            color: row.querySelector('.field-color').value
          };
          
          if (!isNaN(data.lat) && !isNaN(data.lon)) {
            newData.push(data);
            
            // 3つの円を描画
            [data.radius1, data.radius2, data.radius3].forEach((radius, index) => {
              if (!isNaN(radius) && radius > 0) {
                const circle = L.circle([data.lat, data.lon], {
                  radius: radius,
                  color: data.color,
                  fillColor: data.color,
                  fillOpacity: 0.2 - (index * 0.05)
                }).addTo(map);
                window.customLayers.push(circle);
              }
            });
            
            // マーカーを追加
            const marker = createMarker(data.lat, data.lon, data);
            marker.addTo(map);
            markers.push(marker);
          }
        } catch (error) {
          console.error('行のデータ処理エラー:', error);
        }
      });
      
      customData = newData;
    }

    // マーカーを管理する配列
    let markers = [];

    // マーカーの作成と追加
    function createMarker(lat, lon, data) {
      const marker = L.marker([lat, lon]);
      
      marker.on('click', async () => {
        // ポップアップコンテンツの作成
        const popupContent = `
          <div class="marker-popup">
            <h3>${data.name}</h3>
            <div class="marker-popup-content">
              <p><strong>住所:</strong> ${data.address || '未設定'}</p>
              <p><strong>緯度:</strong> ${lat}</p>
              <p><strong>経度:</strong> ${lon}</p>
              <p><strong>売上:</strong> ${data.sales ? data.sales.toLocaleString() : '未設定'}</p>
              <p><strong>客数:</strong> ${data.customers ? data.customers.toLocaleString() : '未設定'}</p>
              <p><strong>面積:</strong> ${data.area ? data.area + 'm²' : '未設定'}</p>
              <p><strong>期間:</strong> ${data.startDate || '未設定'} ～ ${data.endDate || '未設定'}</p>
            </div>
            <div class="marker-popup-links">
              <a href="https://www.google.com/maps/search/?api=1&query=${lat},${lon}" target="_blank">Google Mapで開く</a>
              <a href="#" onclick="showPolygons(${lat}, ${lon}); return false;">周辺ポリゴン表示</a>
            </div>
          </div>
        `;
        
        marker.bindPopup(popupContent).openPopup();
        
        // 周辺ポリゴンを取得して表示
        await showPolygons(lat, lon);
      });
      
      return marker;
    }

    // 周辺ポリゴンを表示する関数
    async function showPolygons(lat, lon) {
      try {
        const geojsonData = await fetchOverpassData(lat, lon, 1500);
        renderGeoJSON(geojsonData);
      } catch (error) {
        console.error('ポリゴン取得エラー:', error);
      }
    }

    // マップのダブルクリックイベントを設定
    map.on('dblclick', function(e) {
      const lat = e.latlng.lat.toFixed(6);
      const lng = e.latlng.lng.toFixed(6);
      
      addNewRow({
        name: '新規ポイント',
        lat: lat,
        lon: lng,
        radius1: '500',
        radius2: '1000',
        radius3: '1500',
        color: '#66c2a5'
      });
    });

    // データ行選択時のイベント処理を更新
    function addRowClickHandler(row, data) {
      row.addEventListener('click', async () => {
        const lat = parseFloat(data.lat);
        const lon = parseFloat(data.lon);
        
        if (!isNaN(lat) && !isNaN(lon)) {
          map.setView([lat, lon], 14);
          await showPolygons(lat, lon);
          
          // 既存のマーカーを探して、クリックイベントをトリガー
          markers.forEach(marker => {
            if (marker.getLatLng().lat === lat && marker.getLatLng().lng === lon) {
              marker.fire('click');
            }
          });
        }
      });
    }

    // データのエクスポート処理
    function exportData(type, data) {
      const worksheet = XLSX.utils.json_to_sheet(data);
      const workbook = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(workbook, worksheet, 'Data');
      
      // Excel形式でエクスポート
      const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
      const blob = new Blob([excelBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `${type}_data.xlsx`;
      link.click();
    }

    // データのインポート処理
    function importData(file, type) {
      const reader = new FileReader();
      reader.onload = function(e) {
        if (file.name.endsWith('.csv')) {
          Papa.parse(file, {
            complete: function(results) {
              processImportedData(results.data, type);
            }
          });
        } else {
          const data = new Uint8Array(e.target.result);
          const workbook = XLSX.read(data, { type: 'array' });
          const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
          const jsonData = XLSX.utils.sheet_to_json(firstSheet);
          processImportedData(jsonData, type);
        }
      };
      reader.readAsArrayBuffer(file);
    }

    // イベントリスナーの追加
    document.getElementById('exportPlots').addEventListener('click', () => {
      exportData('plots', customData);
    });

    document.getElementById('exportPolygons').addEventListener('click', () => {
      exportData('polygons', polygonData);
    });

    document.getElementById('importPlots').addEventListener('change', (e) => {
      importData(e.target.files[0], 'plots');
    });

    document.getElementById('importPolygons').addEventListener('change', (e) => {
      importData(e.target.files[0], 'polygons');
    });

    // 検索結果をプロット地点テーブルに追加する関数
    function addSearchResultToPlots(lat, lon, displayName = '検索地点') {
      // プロットタブをアクティブにする
      document.querySelector('[data-tab="plots"]').click();
      
      // プロット地点として追加
      addNewRow({
        name: displayName,
        lat: lat,
        lon: lon,
        radius: '1500',
        color: '#66c2a5'
      });
      
      // テーブルに追加後、地図に反映
      applyCustomData();
    }

    // 初期化処理を更新
    async function initialize() {
      try {
        // 地図の初期表示
        await updateMapWithCoords(centerLat, centerLon, '渋谷駅');
        
        // プロット地点タブに渋谷駅を追加
        addNewRow(defaultPoint);
        
        // プロット地点を地図に反映
        applyCustomData();
        
        // イベントリスナーの初期化
        initEventListeners();
        initializeEventListeners();
      } catch (error) {
        console.error('初期化エラー:', error);
        showError(error.message);
      }
    }

    // イベントリスナーの追加を修正
    function initializeEventListeners() {
      // プロット関連のイベントリスナー
      const addRowButton = document.getElementById('addPlotRow');
      const applyButton = document.getElementById('applyPlots');
      
      if (addRowButton) {
        addRowButton.addEventListener('click', () => addNewRow());
      }
      
      if (applyButton) {
        applyButton.addEventListener('click', applyCustomData);
      }

      // マップクリックイベント
      map.on('click', function(e) {
        const lat = e.latlng.lat.toFixed(6);
        const lng = e.latlng.lng.toFixed(6);
        
        addNewRow({
          name: '新規ポイント',
          lat: lat,
          lon: lng,
          radius: '1500',
          color: '#66c2a5'
        });
      });
    }

    // DOMContentLoadedイベントで初期化を実行
    document.addEventListener('DOMContentLoaded', initialize);

    // イベントリスナーの初期化を一本化
    function initializeEventListeners() {
      // 検索関連
      const searchButton = document.getElementById('searchButton');
      if (searchButton) {
        searchButton.addEventListener('click', handleSearch);
      }

      // 入力フィールドのEnterキーイベント
      ['addressInput', 'latInput', 'lonInput'].forEach(id => {
        const element = document.getElementById(id);
        if (element) {
          element.addEventListener('keypress', e => {
            if (e.key === 'Enter') handleSearch();
          });
        }
      });

      // ラジオボタンの切り替え
      document.querySelectorAll('input[name="searchType"]').forEach(radio => {
        radio.addEventListener('change', () => {
          const addressGroup = document.getElementById('addressGroup');
          const coordsGroup = document.getElementById('coordsGroup');
          if (addressGroup && coordsGroup) {
            addressGroup.style.display = radio.value === 'address' ? 'flex' : 'none';
            coordsGroup.style.display = radio.value === 'coords' ? 'flex' : 'none';
          }
        });
      });

      // プロット関連
      const addPlotRowButton = document.getElementById('addPlotRow');
      const applyPlotsButton = document.getElementById('applyPlots');
      const exportPlotsButton = document.getElementById('exportPlots');
      const importPlotsInput = document.getElementById('importPlots');

      if (addPlotRowButton) {
        addPlotRowButton.addEventListener('click', () => addNewRow());
      }

      if (applyPlotsButton) {
        applyPlotsButton.addEventListener('click', applyCustomData);
      }

      if (exportPlotsButton) {
        exportPlotsButton.addEventListener('click', () => exportData('plots', customData));
      }

      if (importPlotsInput) {
        importPlotsInput.addEventListener('change', (e) => importData(e.target.files[0], 'plots'));
      }

      // ファイル入力
      const fileInput = document.getElementById('fileInput');
      if (fileInput) {
        fileInput.addEventListener('change', handleFileSelect);
      }

      // タブ切り替え
      document.querySelectorAll('.tab-button').forEach(button => {
        button.addEventListener('click', () => {
          document.querySelectorAll('.tab-button').forEach(b => b.classList.remove('active'));
          document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
          
          button.classList.add('active');
          const tabId = `${button.dataset.tab}Tab`;
          const tabContent = document.getElementById(tabId);
          if (tabContent) {
            tabContent.classList.add('active');
          }
        });
      });

      // マップクリックイベント
      map.on('click', function(e) {
        const lat = e.latlng.lat.toFixed(6);
        const lng = e.latlng.lng.toFixed(6);
        
        addNewRow({
          name: '新規ポイント',
          lat: lat,
          lon: lng,
          radius: '1500',
          color: '#66c2a5'
        });
      });
    }
  </script>
</body>
</html>
