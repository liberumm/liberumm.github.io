<!DOCTYPE html>
<html>
<head>
  <title>All Features: React + Leaflet + MUI</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0">

  <!-- React / ReactDOM / Babel -->
  <script src="https://cdn.jsdelivr.net/npm/react@18/umd/react.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.21.0/babel.min.js"></script>

  <!-- MUI (Material UI) + Emotion -->
  <script src="https://cdn.jsdelivr.net/npm/@mui/material@5.11.15/umd/material-ui.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@emotion/react@11.11.0/dist/emotion-react.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@emotion/styled@11.11.0/dist/emotion-styled.umd.min.js"></script>

  <!-- Leaflet CSS/JS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

  <!-- osmtogeojson, turf.js -->
  <script src="https://cdn.jsdelivr.net/npm/osmtogeojson@3.0.0-beta.5/osmtogeojson.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

  <!-- SheetJS, PapaParse for file I/O -->
  <script src="https://cdn.sheetjs.com/xlsx-0.19.3/package/dist/xlsx.full.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.0/papaparse.min.js"></script>

  <style>
    /* 必要最低限のスタイル */
    body, html {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: 'Roboto','Helvetica','Arial',sans-serif;
    }
    #root {
      display: flex;
      flex-direction: column;
      width: 100%;
      height: 100%;
    }
    .map-container {
      width: 100%;
      height: 60vh;
      position: relative;
    }
    #map {
      width: 100%;
      height: 100%;
    }
    #statsContainer {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(255, 255, 255, 0.9);
      padding: 10px;
      border-radius: 4px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.15);
      display: none;
      z-index: 1000;
    }
    .custom-marker {
      font-size: 24px;
    }
  </style>
</head>
<body>
<div id="root"></div>

<script type="text/babel">
const {
  createTheme,
  ThemeProvider,
  CssBaseline,
  AppBar,
  Toolbar,
  Typography,
  Box,
  Button,
  TextField,
  Radio,
  RadioGroup,
  FormControlLabel,
  FormControl,
  Tabs,
  Tab,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  IconButton,
  Paper,
  Checkbox
} = MaterialUI;

/**
 * 全機能フルコード:
 *  - 初期渋谷駅のプロット
 *  - 住所/座標検索 → テーブル追加 (名称/住所/lat/lon)
 *  - テーブル編集で即マップ反映
 *  - ダブルクリックで新規ポイント
 *  - 半径一括適用
 *  - Overpass APIでポリゴン表示
 *  - GSIジオコーディング
 *  - CSV/Excelインポート/エクスポート
 *  - ポリゴンタブ(町丁目データ)もインポート/エクスポート、地図に反映(例)
 */
function App() {
  // MUIデフォルトテーマ
  const theme = createTheme();

  // --------- 検索関連state ---------
  const [searchType, setSearchType] = React.useState('address');
  const [address, setAddress] = React.useState('');
  const [latInput, setLatInput] = React.useState('');
  const [lonInput, setLonInput] = React.useState('');
  const [message, setMessage] = React.useState(null);

  // --------- タブ関連 ---------
  const [tabValue, setTabValue] = React.useState(0);

  // --------- 半径一括適用 ---------
  const [globalRadius1, setGlobalRadius1] = React.useState(500);
  const [globalColor1, setGlobalColor1] = React.useState('#1976d2');
  const [globalRadius2, setGlobalRadius2] = React.useState(1000);
  const [globalColor2, setGlobalColor2] = React.useState('#9c27b0');
  const [globalRadius3, setGlobalRadius3] = React.useState(1500);
  const [globalColor3, setGlobalColor3] = React.useState('#ff9800');

  // --------- プロット地点テーブル ---------
  // 1行目: 渋谷駅
  const [plotsData, setPlotsData] = React.useState([
    {
      selected: false,
      name: '渋谷駅',
      address: '東京都渋谷区道玄坂2丁目',
      lat: 35.6580,
      lon: 139.7016,
      startDate: '',
      endDate: '',
      sales: '',
      customers: '',
      area: '',
      radius1: 500,
      color1: '#1976d2',
      radius2: 1000,
      color2: '#9c27b0',
      radius3: 1500,
      color3: '#ff9800'
    }
  ]);

  // --------- ポリゴンタブ用データ ---------
  const [polygonsData, setPolygonsData] = React.useState([]);

  // Leaflet関連
  const mapRef = React.useRef(null);
  const [mapInstance, setMapInstance] = React.useState(null);
  const [polygonLayer, setPolygonLayer] = React.useState(null);
  const [markers, setMarkers] = React.useState([]);
  const [circles, setCircles] = React.useState([]);

  // Overpass API キャッシュ
  const overpassCache = React.useRef(new Map());

  // =====================================
  // 1. 地図初期化 (渋谷駅を中心)
  // =====================================
  React.useEffect(() => {
    if (!mapRef.current || mapInstance) return;
    const Lmap = L.map(mapRef.current).setView([35.6580, 139.7016], 14);
    L.tileLayer('https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png', {
      attribution: '© 国土地理院'
    }).addTo(Lmap);

    // マップダブルクリック → 新規行
    Lmap.on('dblclick', (e) => {
      const lt = parseFloat(e.latlng.lat.toFixed(6));
      const ln = parseFloat(e.latlng.lng.toFixed(6));
      setPlotsData(prev => [
        ...prev,
        {
          selected: false,
          name: '新規ポイント',
          address: '',
          lat: lt,
          lon: ln,
          startDate: '',
          endDate: '',
          sales: '',
          customers: '',
          area: '',
          radius1: globalRadius1,
          color1: globalColor1,
          radius2: globalRadius2,
          color2: globalColor2,
          radius3: globalRadius3,
          color3: globalColor3
        }
      ]);
    });

    setMapInstance(Lmap);
  }, [mapRef, mapInstance]);

  // =====================================
  // 2. プロットテーブル変更 → マップ再描画
  // =====================================
  React.useEffect(() => {
    if (mapInstance) {
      applyPlotsData(mapInstance);
    }
  }, [plotsData, mapInstance]); 
  // plotsDataが変わるたびに地図を再描画

  // =====================================
  // 3. 初回に渋谷駅周辺ポリゴン表示
  // =====================================
  React.useEffect(() => {
    if (!mapInstance) return;
    showPolygons(35.6580, 139.7016);
  }, [mapInstance]);

  // =====================================
  // Overpass API / osmtogeojson
  // =====================================
  function generateOverpassQuery(lat, lon, radius) {
    return `
[out:json][timeout:25];
(
  way["boundary"="administrative"]["admin_level"~"^(8|9|10)$"](around:${radius},${lat},${lon});
  relation["boundary"="administrative"]["admin_level"~"^(8|9|10)$"](around:${radius},${lat},${lon});
);
out body;
>;
out skel qt;`;
  }

  async function fetchOverpassData(lat, lon, radius) {
    const key = `${lat},${lon},${radius}`;
    if (overpassCache.current.has(key)) {
      return overpassCache.current.get(key);
    }
    const query = generateOverpassQuery(lat, lon, radius);
    const res = await fetch('https://overpass-api.de/api/interpreter', {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: 'data=' + encodeURIComponent(query)
    });
    if (!res.ok) {
      throw new Error('Overpass APIエラー');
    }
    const data = await res.json();
    const geojson = osmtogeojson(data);
    overpassCache.current.set(key, geojson);
    return geojson;
  }

  function renderGeoJSON(geojson) {
    if (!mapInstance) return;
    if (polygonLayer) {
      mapInstance.removeLayer(polygonLayer);
    }
    const newLayer = L.geoJSON(geojson, {
      style: {
        fillColor: '#2196f3',
        fillOpacity: 0.3,
        color: '#1976d2',
        weight: 2,
      },
      onEachFeature: (feature, layer) => {
        const name = feature.properties?.tags?.name || '不明';
        const admin = feature.properties?.tags?.admin_level || '不明';
        let content = `<strong>${name}</strong> (admin:${admin})`;
        // 中心座標
        try {
          const centroid = turf.centroid(feature);
          const lat = centroid.geometry.coordinates[1].toFixed(6);
          const lon = centroid.geometry.coordinates[0].toFixed(6);
          content += `<br>中心: lat=${lat}, lon=${lon}`;
        } catch(e){}
        layer.bindPopup(content);
      }
    }).addTo(mapInstance);
    setPolygonLayer(newLayer);
    updatePolygonStats(geojson);
  }

  function updatePolygonStats(geojson) {
    const statsDiv = document.getElementById('statsContainer');
    if (!statsDiv) return;
    const count = geojson.features.length;
    statsDiv.style.display = 'block';
    statsDiv.innerHTML = `取得ポリゴン数: ${count}`;
  }

  async function showPolygons(lat, lon) {
    if (!mapInstance) return;
    try {
      const data = await fetchOverpassData(lat, lon, 1500);
      renderGeoJSON(data);
    } catch (err) {
      showError(`ポリゴン取得失敗: ${err.message}`);
    }
  }

  window.showPolygons = (lat, lon) => showPolygons(lat, lon);

  // =====================================
  // GSI ジオコーディング (住所→座標)
  // =====================================
  async function geocodeAddressGSI(addr) {
    const url = `https://msearch.gsi.go.jp/address-search/AddressSearch?q=${encodeURIComponent(addr)}`;
    const res = await fetch(url);
    if (!res.ok) {
      throw new Error('ジオコーディングAPIエラー');
    }
    const data = await res.json();
    if (!data || data.length === 0) {
      throw new Error('住所が見つかりませんでした');
    }
    const tokyo = data.filter(d => d.address && d.address.includes('東京都'));
    const selected = tokyo.length > 0 ? tokyo[0] : data[0];
    const coords = selected.geometry.coordinates; // [lon, lat]
    return {
      lat: coords[1],
      lon: coords[0],
      displayName: selected.address || addr
    };
  }

  // =====================================
  // 検索でテーブルに追加 (名称/住所/lat/lon)
  // =====================================
  async function handleSearch() {
    try {
      setMessage(null);
      if (!mapInstance) return;

      let latVal, lonVal, label;
      if (searchType === 'address') {
        if (!address.trim()) throw new Error('住所を入力してください');
        const result = await geocodeAddressGSI(address.trim());
        latVal = result.lat;
        lonVal = result.lon;
        label = result.displayName; 
      } else {
        // 座標
        latVal = parseFloat(latInput);
        lonVal = parseFloat(lonInput);
        if (isNaN(latVal) || isNaN(lonVal)) {
          throw new Error('緯度経度を正しく入力してください');
        }
        label = `座標指定(${latVal},${lonVal})`;
      }

      // マップ移動 & ポリゴン表示
      mapInstance.setView([latVal, lonVal], 14);
      await showPolygons(latVal, lonVal);

      // テーブルに追加
      setPlotsData(prev => [
        ...prev,
        {
          selected: false,
          name: label,
          address: label,
          lat: latVal,
          lon: lonVal,
          startDate: '',
          endDate: '',
          sales: '',
          customers: '',
          area: '',
          radius1: globalRadius1,
          color1: globalColor1,
          radius2: globalRadius2,
          color2: globalColor2,
          radius3: globalRadius3,
          color3: globalColor3
        }
      ]);
      showSuccess('検索完了: テーブルに追加しました');
    } catch (err) {
      showError(err.message);
    }
  }

  // =====================================
  // メッセージ表示
  // =====================================
  function showError(msg) {
    setMessage(<Box sx={{ color:'error.main', mt:1 }}>{msg}</Box>);
  }
  function showSuccess(msg) {
    setMessage(<Box sx={{ color:'success.main', mt:1 }}>{msg}</Box>);
  }

  // =====================================
  // plotsData → 地図に反映
  // =====================================
  function applyPlotsData(m = mapInstance) {
    if (!m) return;
    // 既存のマーカー/サークル削除
    circles.forEach(c => m.removeLayer(c));
    markers.forEach(mark => m.removeLayer(mark));
    setCircles([]);
    setMarkers([]);

    const newCircles = [];
    const newMarkers = [];

    plotsData.forEach(row => {
      const lt = parseFloat(row.lat);
      const ln = parseFloat(row.lon);
      if (isNaN(lt) || isNaN(ln)) return;

      // 円3つ
      [1,2,3].forEach(i => {
        const r = parseFloat(row[`radius${i}`]);
        const c = row[`color${i}`];
        if (!isNaN(r) && r>0) {
          const circle = L.circle([lt, ln], {
            radius: r,
            color: c,
            fillColor: c,
            fillOpacity: 0.2 - (i*0.05),
          }).addTo(m);
          newCircles.push(circle);
        }
      });

      // マーカー
      const marker = L.marker([lt, ln], {
        icon: L.divIcon({
          className: 'custom-marker',
          html: '📍',
          iconSize: [25,25],
          iconAnchor: [12,25]
        })
      }).addTo(m);

      // マーカークリック → ポリゴン再表示
      marker.on('click', async () => {
        const popupHtml = `
          <div style="min-width:220px">
            <h3>${row.name||'名称未設定'}</h3>
            <p>住所: ${row.address||''}</p>
            <p>緯度: ${lt}</p>
            <p>経度: ${ln}</p>
            <p>売上: ${row.sales||''}</p>
            <p>客数: ${row.customers||''}</p>
            <p>面積: ${row.area||''}</p>
            <p>期間: ${row.startDate||''} ~ ${row.endDate||''}</p>
          </div>
        `;
        marker.bindPopup(popupHtml).openPopup();

        // 地図移動 + ポリゴン
        m.setView([lt, ln], 14);
        await showPolygons(lt, ln);
      });

      newMarkers.push(marker);
    });

    setCircles(newCircles);
    setMarkers(newMarkers);
  }

  // =====================================
  // plotsData テーブル操作
  // =====================================
  function handlePlotsFieldChange(i, field, value) {
    setPlotsData(prev => {
      const cp = [...prev];
      cp[i] = { ...cp[i], [field]: value };
      return cp;
    });
  }
  function handleDeletePlotRow(i) {
    setPlotsData(prev => prev.filter((_, idx) => idx!==i));
  }

  // 半径一括適用
  function handleApplyGlobalRadius() {
    setPlotsData(prev =>
      prev.map(item =>
        item.selected
        ? {
            ...item,
            radius1: globalRadius1,
            color1: globalColor1,
            radius2: globalRadius2,
            color2: globalColor2,
            radius3: globalRadius3,
            color3: globalColor3
          }
        : item
      )
    );
  }

  // =====================================
  // ポリゴンタブ
  // =====================================
  function handleTabChange(e, val) {
    setTabValue(val);
  }

  function handlePolygonFieldChange(i, field, value) {
    setPolygonsData(prev => {
      const cp = [...prev];
      cp[i] = { ...cp[i], [field]: value };
      return cp;
    });
  }
  function handleAddPolygonRow() {
    setPolygonsData(prev => [
      ...prev,
      { name:'', polygonData:'', color:'#1976d2' }
    ]);
  }
  function handleDeletePolygonRow(i) {
    setPolygonsData(prev => prev.filter((_, idx)=> idx!==i));
  }

  // ポリゴンを地図に反映(例: polygonDataをGeoJSONとして読み込む想定)
  function applyPolygonsToMap() {
    if (!mapInstance) return;
    if (polygonLayer) {
      mapInstance.removeLayer(polygonLayer);
    }
    // polygonDataを JSON.parse するなどして読み込み、L.geoJSON(...) で表示する例
    // 簡易実装なので、各行の polygonData が有効なGeoJSON形式であることを想定
    let features = [];
    polygonsData.forEach(row => {
      try {
        if (!row.polygonData) return;
        const geo = JSON.parse(row.polygonData); 
        // color
        features.push({
          ...geo,
          properties: {
            color: row.color||'#1976d2',
            name: row.name||''
          }
        });
      } catch(e){}
    });
    const geojson = {
      type: 'FeatureCollection',
      features: features
    };
    const newLayer = L.geoJSON(geojson, {
      style: (feature) => ({
        color: feature.properties.color||'#1976d2',
        fillColor: feature.properties.color||'#1976d2',
        fillOpacity:0.2,
        weight:2
      }),
      onEachFeature:(feature, layer) => {
        let popup = `<strong>${feature.properties.name||'名称不明'}</strong>`;
        layer.bindPopup(popup);
      }
    }).addTo(mapInstance);
    setPolygonLayer(newLayer);
  }

  // =====================================
  // CSV/Excelインポート・エクスポート
  // =====================================
  function exportData(type, data) {
    const ws = XLSX.utils.json_to_sheet(data);
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, 'Data');
    const buffer = XLSX.write(wb,{bookType:'xlsx',type:'array'});
    const blob = new Blob([buffer],{type:'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'});
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `${type}_data.xlsx`;
    link.click();
  }

  function importData(file, type) {
    const reader = new FileReader();
    reader.onload = (e) => {
      if (file.name.endsWith('.csv')) {
        Papa.parse(file,{
          header:true,
          complete:(results)=>{
            processImportedData(results.data, type);
          }
        });
      } else {
        // Excel
        const data = new Uint8Array(e.target.result);
        const wb = XLSX.read(data,{type:'array'});
        const firstSheet = wb.Sheets[wb.SheetNames[0]];
        const jsonData = XLSX.utils.sheet_to_json(firstSheet);
        processImportedData(jsonData, type);
      }
    };
    reader.readAsArrayBuffer(file);
  }

  function processImportedData(jsonData, type) {
    if (type==='plots') {
      const rows = jsonData.map(item=>({
        selected: false,
        name: item.name||'',
        address: item.address||'',
        lat: item.lat||'',
        lon: item.lon||'',
        startDate: item.startDate||'',
        endDate: item.endDate||'',
        sales: item.sales||'',
        customers: item.customers||'',
        area: item.area||'',
        radius1: item.radius1||500,
        color1: item.color1||'#1976d2',
        radius2: item.radius2||1000,
        color2: item.color2||'#9c27b0',
        radius3: item.radius3||1500,
        color3: item.color3||'#ff9800'
      }));
      setPlotsData(prev => [...prev, ...rows]);
    } else {
      // polygons
      const rows = jsonData.map(item=>({
        name: item.name||'',
        polygonData: item.polygonData||'',
        color: item.color||'#1976d2'
      }));
      setPolygonsData(prev => [...prev, ...rows]);
    }
  }

  // =====================================
  // レンダリング
  // =====================================
  return (
    <ThemeProvider theme={theme}>
      <CssBaseline />

      <AppBar position="static">
        <Toolbar>
          <Typography variant="h6" sx={{ flexGrow:1 }}>
            All Features: React + Leaflet + MUI
          </Typography>
        </Toolbar>
      </AppBar>

      <Box sx={{ flex:1, display:'flex', flexDirection:'column' }}>
        {/* マップ */}
        <Box className="map-container">
          <div id="map" ref={mapRef}></div>
          <div id="statsContainer"></div>

          {/* 検索コントロール */}
          <Box sx={{
            position:'absolute', top:16, left:16, p:2,
            borderRadius:2, boxShadow:2, bgcolor:'background.paper',
            maxWidth:300, zIndex:1000
          }}>
            <FormControl>
              <RadioGroup row value={searchType} onChange={(e)=>setSearchType(e.target.value)}>
                <FormControlLabel value="address" control={<Radio/>} label="住所検索"/>
                <FormControlLabel value="coords" control={<Radio/>} label="座標検索"/>
              </RadioGroup>
            </FormControl>
            {searchType==='address'?(
              <TextField
                label="住所"
                variant="outlined"
                size="small"
                fullWidth
                value={address}
                onChange={(e)=>setAddress(e.target.value)}
                sx={{ mt:1 }}
              />
            ):(
              <Box sx={{ display:'flex', gap:1, mt:1 }}>
                <TextField
                  label="緯度"
                  variant="outlined"
                  size="small"
                  value={latInput}
                  onChange={(e)=>setLatInput(e.target.value)}
                />
                <TextField
                  label="経度"
                  variant="outlined"
                  size="small"
                  value={lonInput}
                  onChange={(e)=>setLonInput(e.target.value)}
                />
              </Box>
            )}
            <Button variant="contained" onClick={handleSearch} sx={{ mt:1 }}>
              検索
            </Button>
            {message && <Box>{message}</Box>}

            {/* 半径一括適用 */}
            <Typography variant="subtitle2" sx={{ mt:2 }}>
              選択行に一括適用
            </Typography>
            <Box sx={{ display:'flex', gap:1, mt:1 }}>
              <TextField
                label="半径1"
                type="number"
                size="small"
                value={globalRadius1}
                onChange={(e)=>setGlobalRadius1(e.target.value)}
                sx={{ width:80 }}
              />
              <input
                type="color"
                value={globalColor1}
                onChange={(e)=>setGlobalColor1(e.target.value)}
                style={{ width:'40px', height:'30px', border:'none' }}
              />
            </Box>
            <Box sx={{ display:'flex', gap:1, mt:1 }}>
              <TextField
                label="半径2"
                type="number"
                size="small"
                value={globalRadius2}
                onChange={(e)=>setGlobalRadius2(e.target.value)}
                sx={{ width:80 }}
              />
              <input
                type="color"
                value={globalColor2}
                onChange={(e)=>setGlobalColor2(e.target.value)}
                style={{ width:'40px', height:'30px', border:'none' }}
              />
            </Box>
            <Box sx={{ display:'flex', gap:1, mt:1 }}>
              <TextField
                label="半径3"
                type="number"
                size="small"
                value={globalRadius3}
                onChange={(e)=>setGlobalRadius3(e.target.value)}
                sx={{ width:80 }}
              />
              <input
                type="color"
                value={globalColor3}
                onChange={(e)=>setGlobalColor3(e.target.value)}
                style={{ width:'40px', height:'30px', border:'none' }}
              />
            </Box>
            <Button variant="contained" sx={{ mt:1 }} onClick={handleApplyGlobalRadius}>
              一括適用
            </Button>
          </Box>
        </Box>

        {/* タブエリア */}
        <Box sx={{ flex:1, display:'flex', flexDirection:'column' }}>
          <Tabs value={tabValue} onChange={handleTabChange} sx={{ borderBottom:1, borderColor:'divider' }}>
            <Tab label="プロット地点"/>
            <Tab label="町丁目ポリゴン"/>
          </Tabs>

          {/* プロット地点タブ */}
          {tabValue===0 && (
            <Box sx={{ p:2, overflowX:'auto' }}>
              <Box sx={{ display:'flex', gap:1, mb:2 }}>
                <Button variant="contained" onClick={()=>exportData('plots',plotsData)}>
                  エクスポート
                </Button>
                <input
                  id="importPlotsFile"
                  type="file"
                  accept=".csv,.xlsx"
                  style={{ display:'none' }}
                  onChange={(e)=>{
                    if(e.target.files?.[0]) importData(e.target.files[0],'plots');
                  }}
                />
                <Button variant="contained" onClick={()=>document.getElementById('importPlotsFile').click()}>
                  インポート
                </Button>
              </Box>
              <TableContainer component={Paper}>
                <Table size="small" sx={{ minWidth:1300 }}>
                  <TableHead>
                    <TableRow>
                      <TableCell padding="checkbox"></TableCell>
                      <TableCell>名称</TableCell>
                      <TableCell>住所</TableCell>
                      <TableCell>緯度</TableCell>
                      <TableCell>経度</TableCell>
                      <TableCell>開始日</TableCell>
                      <TableCell>終了日</TableCell>
                      <TableCell>売上</TableCell>
                      <TableCell>客数</TableCell>
                      <TableCell>面積</TableCell>
                      <TableCell>半径1&色</TableCell>
                      <TableCell>半径2&色</TableCell>
                      <TableCell>半径3&色</TableCell>
                      <TableCell>操作</TableCell>
                    </TableRow>
                  </TableHead>
                  <TableBody>
                    {plotsData.map((row,i)=>(
                      <TableRow key={i}>
                        <TableCell padding="checkbox">
                          <Checkbox
                            checked={row.selected||false}
                            onChange={(e)=>
                              handlePlotsFieldChange(i,'selected',e.target.checked)
                            }
                          />
                        </TableCell>
                        <TableCell>
                          <TextField
                            variant="outlined" size="small"
                            value={row.name||''}
                            onChange={(e)=>handlePlotsFieldChange(i,'name',e.target.value)}
                          />
                        </TableCell>
                        <TableCell>
                          <TextField
                            variant="outlined" size="small"
                            value={row.address||''}
                            onChange={(e)=>handlePlotsFieldChange(i,'address',e.target.value)}
                          />
                        </TableCell>
                        <TableCell>
                          <TextField
                            type="number" variant="outlined" size="small"
                            value={row.lat||''}
                            onChange={(e)=>handlePlotsFieldChange(i,'lat',e.target.value)}
                          />
                        </TableCell>
                        <TableCell>
                          <TextField
                            type="number" variant="outlined" size="small"
                            value={row.lon||''}
                            onChange={(e)=>handlePlotsFieldChange(i,'lon',e.target.value)}
                          />
                        </TableCell>
                        <TableCell>
                          <TextField
                            type="date" variant="outlined" size="small"
                            value={row.startDate||''}
                            onChange={(e)=>handlePlotsFieldChange(i,'startDate',e.target.value)}
                          />
                        </TableCell>
                        <TableCell>
                          <TextField
                            type="date" variant="outlined" size="small"
                            value={row.endDate||''}
                            onChange={(e)=>handlePlotsFieldChange(i,'endDate',e.target.value)}
                          />
                        </TableCell>
                        <TableCell>
                          <TextField
                            type="number" variant="outlined" size="small"
                            value={row.sales||''}
                            onChange={(e)=>handlePlotsFieldChange(i,'sales',e.target.value)}
                          />
                        </TableCell>
                        <TableCell>
                          <TextField
                            type="number" variant="outlined" size="small"
                            value={row.customers||''}
                            onChange={(e)=>handlePlotsFieldChange(i,'customers',e.target.value)}
                          />
                        </TableCell>
                        <TableCell>
                          <TextField
                            type="number" variant="outlined" size="small"
                            value={row.area||''}
                            onChange={(e)=>handlePlotsFieldChange(i,'area',e.target.value)}
                          />
                        </TableCell>
                        <TableCell>
                          <Box sx={{ display:'flex', gap:1, alignItems:'center' }}>
                            <TextField
                              type="number" variant="outlined" size="small"
                              sx={{ width:60 }}
                              value={row.radius1||500}
                              onChange={(e)=>handlePlotsFieldChange(i,'radius1',e.target.value)}
                            />
                            <input
                              type="color"
                              value={row.color1||'#1976d2'}
                              onChange={(e)=>handlePlotsFieldChange(i,'color1',e.target.value)}
                              style={{ width:'40px', height:'30px', border:'none' }}
                            />
                          </Box>
                        </TableCell>
                        <TableCell>
                          <Box sx={{ display:'flex', gap:1, alignItems:'center' }}>
                            <TextField
                              type="number" variant="outlined" size="small"
                              sx={{ width:60 }}
                              value={row.radius2||1000}
                              onChange={(e)=>handlePlotsFieldChange(i,'radius2',e.target.value)}
                            />
                            <input
                              type="color"
                              value={row.color2||'#9c27b0'}
                              onChange={(e)=>handlePlotsFieldChange(i,'color2',e.target.value)}
                              style={{ width:'40px', height:'30px', border:'none' }}
                            />
                          </Box>
                        </TableCell>
                        <TableCell>
                          <Box sx={{ display:'flex', gap:1, alignItems:'center' }}>
                            <TextField
                              type="number" variant="outlined" size="small"
                              sx={{ width:60 }}
                              value={row.radius3||1500}
                              onChange={(e)=>handlePlotsFieldChange(i,'radius3',e.target.value)}
                            />
                            <input
                              type="color"
                              value={row.color3||'#ff9800'}
                              onChange={(e)=>handlePlotsFieldChange(i,'color3',e.target.value)}
                              style={{ width:'40px', height:'30px', border:'none' }}
                            />
                          </Box>
                        </TableCell>
                        <TableCell>
                          <IconButton size="small" onClick={()=>handleDeletePlotRow(i)}>
                            🗑️
                          </IconButton>
                        </TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              </TableContainer>
            </Box>
          )}

          {/* ポリゴンタブ */}
          {tabValue===1 && (
            <Box sx={{ p:2, overflowX:'auto' }}>
              <Box sx={{ display:'flex', gap:1, mb:2 }}>
                <Button variant="contained" onClick={handleAddPolygonRow}>
                  新規追加
                </Button>
                <Button variant="contained" onClick={applyPolygonsToMap}>
                  地図に反映
                </Button>
                <Button variant="contained" onClick={()=>exportData('polygons', polygonsData)}>
                  エクスポート
                </Button>
                <input
                  id="importPolygonsFile"
                  type="file"
                  accept=".csv,.xlsx"
                  style={{ display:'none' }}
                  onChange={(e)=>{
                    if(e.target.files?.[0]) importData(e.target.files[0], 'polygons');
                  }}
                />
                <Button variant="contained" onClick={()=>document.getElementById('importPolygonsFile').click()}>
                  インポート
                </Button>
              </Box>

              <TableContainer component={Paper}>
                <Table size="small" sx={{ minWidth:600 }}>
                  <TableHead>
                    <TableRow>
                      <TableCell>町丁目名</TableCell>
                      <TableCell>ポリゴンデータ(JSON)</TableCell>
                      <TableCell>色</TableCell>
                      <TableCell>操作</TableCell>
                    </TableRow>
                  </TableHead>
                  <TableBody>
                    {polygonsData.map((row, i)=>(
                      <TableRow key={i}>
                        <TableCell>
                          <TextField
                            variant="outlined" size="small"
                            value={row.name||''}
                            onChange={(e)=>handlePolygonFieldChange(i,'name',e.target.value)}
                          />
                        </TableCell>
                        <TableCell>
                          <TextField
                            variant="outlined" size="small" fullWidth
                            placeholder='{"type":"Feature","geometry":{...}}'
                            value={row.polygonData||''}
                            onChange={(e)=>handlePolygonFieldChange(i,'polygonData',e.target.value)}
                          />
                        </TableCell>
                        <TableCell>
                          <input
                            type="color"
                            value={row.color||'#1976d2'}
                            onChange={(e)=>handlePolygonFieldChange(i,'color',e.target.value)}
                            style={{ width:'40px', height:'30px', border:'none' }}
                          />
                        </TableCell>
                        <TableCell>
                          <IconButton size="small" onClick={()=>handleDeletePolygonRow(i)}>
                            🗑️
                          </IconButton>
                        </TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              </TableContainer>
            </Box>
          )}
        </Box>
      </Box>
    </ThemeProvider>
  );
}

ReactDOM.createRoot(document.getElementById('root')).render(<App />);
</script>
</body>
</html>
