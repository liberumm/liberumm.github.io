<!DOCTYPE html>
<html>
<head>
  <title>All Features: React + Leaflet + MUI</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0">

  <!-- React / ReactDOM / Babel -->
  <script src="https://cdn.jsdelivr.net/npm/react@18/umd/react.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.21.0/babel.min.js"></script>

  <!-- MUI (Material UI) + Emotion -->
  <script src="https://cdn.jsdelivr.net/npm/@mui/material@5.11.15/umd/material-ui.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@emotion/react@11.11.0/dist/emotion-react.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@emotion/styled@11.11.0/dist/emotion-styled.umd.min.js"></script>

  <!-- Leaflet CSS/JS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

  <!-- osmtogeojson, turf.js -->
  <script src="https://cdn.jsdelivr.net/npm/osmtogeojson@3.0.0-beta.5/osmtogeojson.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

  <!-- SheetJS, PapaParse for file I/O -->
  <script src="https://cdn.sheetjs.com/xlsx-0.19.3/package/dist/xlsx.full.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.0/papaparse.min.js"></script>

  <style>
    /* ã‚¹ã‚¿ã‚¤ãƒ«ã‚’MUIã®ãƒ†ãƒ¼ãƒã«åˆã‚ã›ã¦æ›´æ–° */
    .map-section {
      height: calc(100vh - 128px); /* AppBarã®é«˜ã•ã‚’è€ƒæ…® */
      padding: 16px;
      background-color: #f5f5f5;
    }

    .map-container {
      border-radius: 4px;
      overflow: hidden;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    /* æ¤œç´¢ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã‚’MUIã‚¹ã‚¿ã‚¤ãƒ«ã« */
    .search-controls {
      background-color: white;
      padding: 16px;
      border-radius: 4px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    /* ãƒ†ãƒ¼ãƒ–ãƒ«ã‚¹ã‚¿ã‚¤ãƒ«ã®æ”¹å–„ */
    .compact-table .MuiTableCell-root {
      padding: 8px;
    }

    .compact-table .MuiTableCell-head {
      background-color: #f5f5f5;
      font-weight: bold;
    }

    /* Adjust the width of specific columns for better readability */
    .col-checkbox {
      width: 50px;
    }

    .col-move {
      width: 80px;
    }

    .col-name {
      width: 150px;
    }

    .col-address {
      width: 200px;
    }

    .col-coord {
      width: 100px;
    }

    .col-date {
      width: 120px;
    }

    .col-number {
      width: 100px;
    }

    .col-radius {
      width: 150px;
    }

    .col-action {
      width: 80px;
    }
  </style>
</head>
<body>
<div id="root"></div>

<script type="text/babel">
const {
  createTheme,
  ThemeProvider,
  CssBaseline,
  AppBar,
  Toolbar,
  Typography,
  Box,
  Button,
  TextField,
  Radio,
  RadioGroup,
  FormControlLabel,
  FormControl,
  Tabs,
  Tab,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  IconButton,
  Paper,
  Checkbox,
  TablePagination,
  Dialog,
  DialogTitle,
  DialogContent,
  Divider,
} = MaterialUI;

/**
 * å…¨æ©Ÿèƒ½ãƒ•ãƒ«ã‚³ãƒ¼ãƒ‰:
 *  - åˆæœŸæ¸‹è°·é§…ã®ãƒ—ãƒ­ãƒƒãƒˆ
 *  - ä½æ‰€/åº§æ¨™æ¤œç´¢ â†’ ãƒ†ãƒ¼ãƒ–ãƒ«è¿½åŠ  (åç§°/ä½æ‰€/lat/lon)
 *  - ãƒ†ãƒ¼ãƒ–ãƒ«ç·¨é›†ã§å³ãƒãƒƒãƒ—åæ˜ 
 *  - ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ã§æ–°è¦ãƒã‚¤ãƒ³ãƒˆ
 *  - åŠå¾„ä¸€æ‹¬é©ç”¨
 *  - Overpass APIã§ãƒãƒªã‚´ãƒ³è¡¨ç¤º
 *  - GSIã‚¸ã‚ªã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°
 *  - CSV/Excelã‚¤ãƒ³ãƒãƒ¼ãƒˆ/ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
 *  - ãƒãƒªã‚´ãƒ³ã‚¿ãƒ–(ç”ºä¸ç›®ãƒ‡ãƒ¼ã‚¿)ã‚‚ã‚¤ãƒ³ãƒãƒ¼ãƒˆ/ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã€åœ°å›³ã«åæ˜ (ä¾‹)
 */
function App() {
  const theme = createTheme({
    palette: {
      primary: {
        main: '#1976d2',
      },
      secondary: {
        main: '#9c27b0',
      },
      background: {
        default: '#f5f5f5',
      },
    },
    components: {
      MuiButton: {
        styleOverrides: {
          root: {
            textTransform: 'none',
          },
        },
      },
      MuiTextField: {
        defaultProps: {
          size: 'small',
          variant: 'outlined',
        },
      },
      MuiTableCell: {
        styleOverrides: {
          root: {
            padding: '8px',
          },
        },
      },
    },
  });

  // --------- æ¤œç´¢é–¢é€£state ---------
  const [searchType, setSearchType] = React.useState('address');
  const [address, setAddress] = React.useState('');
  const [latInput, setLatInput] = React.useState('');
  const [lonInput, setLonInput] = React.useState('');
  const [message, setMessage] = React.useState(null);

  // --------- ã‚¿ãƒ–é–¢é€£ ---------
  const [tabValue, setTabValue] = React.useState(0);

  // --------- åŠå¾„ä¸€æ‹¬é©ç”¨ ---------
  const [globalRadius1, setGlobalRadius1] = React.useState(500);
  const [globalColor1, setGlobalColor1] = React.useState('#1976d2');
  const [globalRadius2, setGlobalRadius2] = React.useState(1000);
  const [globalColor2, setGlobalColor2] = React.useState('#9c27b0');
  const [globalRadius3, setGlobalRadius3] = React.useState(1500);
  const [globalColor3, setGlobalColor3] = React.useState('#ff9800');

  // --------- ãƒ—ãƒ­ãƒƒãƒˆåœ°ç‚¹ãƒ†ãƒ¼ãƒ–ãƒ« ---------
  // 1è¡Œç›®: æ¸‹è°·é§…
  const [plotsData, setPlotsData] = React.useState([
    {
      selected: false,
      name: 'æ¸‹è°·é§…',
      address: 'æ±äº¬éƒ½æ¸‹è°·åŒºé“ç„å‚2ä¸ç›®',
      lat: 35.6580,
      lon: 139.7016,
      startDate: '',
      endDate: '',
      sales: '',
      customers: '',
      area: '',
      radius1: 500,
      color1: '#1976d2',
      radius2: 1000,
      color2: '#9c27b0',
      radius3: 1500,
      color3: '#ff9800'
    }
  ]);

  // --------- ãƒãƒªã‚´ãƒ³ã‚¿ãƒ–ç”¨ãƒ‡ãƒ¼ã‚¿ ---------
  const [polygonsData, setPolygonsData] = React.useState([]);

  // Leafleté–¢é€£
  const mapRef = React.useRef(null);
  const [mapInstance, setMapInstance] = React.useState(null);
  const [polygonLayer, setPolygonLayer] = React.useState(null);
  const [markers, setMarkers] = React.useState([]);
  const [circles, setCircles] = React.useState([]);

  // Overpass API ã‚­ãƒ£ãƒƒã‚·ãƒ¥
  const overpassCache = React.useRef(new Map());

  const [isCollapsed, setIsCollapsed] = React.useState(false);
  const [plotsPageSize, setPlotsPageSize] = React.useState(20);
  const [plotsPage, setPlotsPage] = React.useState(0);
  const [polygonsPageSize, setPolygonsPageSize] = React.useState(20);
  const [polygonsPage, setPolygonsPage] = React.useState(0);

  // ãƒšãƒ¼ã‚¸å¤‰æ›´ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
  const handlePlotsPageChange = (event, newPage) => {
    setPlotsPage(newPage);
  };

  const handlePlotsPageSizeChange = (event) => {
    setPlotsPageSize(parseInt(event.target.value, 10));
    setPlotsPage(0);
  };

  const handlePolygonsPageChange = (event, newPage) => {
    setPolygonsPage(newPage);
  };

  const handlePolygonsPageSizeChange = (event) => {
    setPolygonsPageSize(parseInt(event.target.value, 10));
    setPolygonsPage(0);
  };

  // æ¤œç´¢ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã®ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ç”¨state
  const [controlPosition, setControlPosition] = React.useState({ x: 16, y: 16 });
  const [isDragging, setIsDragging] = React.useState(false);
  const dragStartPos = React.useRef({ x: 0, y: 0 });
  const dragOffset = React.useRef({ x: 0, y: 0 });

  // ãƒ‰ãƒ©ãƒƒã‚°å‡¦ç†ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
  const handleDragStart = (e) => {
    setIsDragging(true);
    const rect = e.currentTarget.getBoundingClientRect();
    dragOffset.current = {
      x: e.clientX - rect.left,
      y: e.clientY - rect.top
    };
  };

  const handleDrag = (e) => {
    if (!isDragging) return;
    
    const x = e.clientX - dragOffset.current.x;
    const y = e.clientY - dragOffset.current.y;
    
    // ç”»é¢ç¯„å›²å†…ã«åˆ¶é™
    const maxX = window.innerWidth - 280; // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã®å¹…ã‚’è€ƒæ…®
    const maxY = window.innerHeight - 100; // é©å½“ãªãƒãƒ¼ã‚¸ãƒ³
    
    setControlPosition({
      x: Math.min(Math.max(0, x), maxX),
      y: Math.min(Math.max(0, y), maxY)
    });
  };

  const handleDragEnd = () => {
    setIsDragging(false);
  };

  // ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
  React.useEffect(() => {
    if (isDragging) {
      document.addEventListener('mousemove', handleDrag);
      document.addEventListener('mouseup', handleDragEnd);
    }
    return () => {
      document.removeEventListener('mousemove', handleDrag);
      document.removeEventListener('mouseup', handleDragEnd);
    };
  }, [isDragging]);

  // ãƒ¢ãƒ¼ãƒ€ãƒ«åˆ¶å¾¡ç”¨ã®state
  const [modalOpen, setModalOpen] = React.useState(false);

  // ãƒ¢ãƒ¼ãƒ€ãƒ«ã®é–‹é–‰ãƒãƒ³ãƒ‰ãƒ©
  const handleModalOpen = () => setModalOpen(true);
  const handleModalClose = () => setModalOpen(false);

  // =====================================
  // 1. åœ°å›³åˆæœŸåŒ– (æ¸‹è°·é§…ã‚’ä¸­å¿ƒ)
  // =====================================
  React.useEffect(() => {
    if (!mapRef.current || mapInstance) return;
    const Lmap = L.map(mapRef.current).setView([35.6580, 139.7016], 14);
    L.tileLayer('https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png', {
      attribution: 'Â© å›½åœŸåœ°ç†é™¢'
    }).addTo(Lmap);

    // ãƒãƒƒãƒ—ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ â†’ æ–°è¦è¡Œ
    Lmap.on('dblclick', (e) => {
      const lt = parseFloat(e.latlng.lat.toFixed(6));
      const ln = parseFloat(e.latlng.lng.toFixed(6));
      setPlotsData(prev => [
        ...prev,
        {
          selected: false,
          name: 'æ–°è¦ãƒã‚¤ãƒ³ãƒˆ',
          address: '',
          lat: lt,
          lon: ln,
          startDate: '',
          endDate: '',
          sales: '',
          customers: '',
          area: '',
          radius1: globalRadius1,
          color1: globalColor1,
          radius2: globalRadius2,
          color2: globalColor2,
          radius3: globalRadius3,
          color3: globalColor3
        }
      ]);
    });

    setMapInstance(Lmap);
  }, [mapRef, mapInstance]);

  // =====================================
  // 2. ãƒ—ãƒ­ãƒƒãƒˆãƒ†ãƒ¼ãƒ–ãƒ«å¤‰æ›´ â†’ ãƒãƒƒãƒ—å†æç”»
  // =====================================
  React.useEffect(() => {
    if (mapInstance) {
      applyPlotsData(mapInstance);
    }
  }, [plotsData, mapInstance]); 
  // plotsDataãŒå¤‰ã‚ã‚‹ãŸã³ã«åœ°å›³ã‚’å†æç”»

  // =====================================
  // 3. åˆå›ã«æ¸‹è°·é§…å‘¨è¾ºãƒãƒªã‚´ãƒ³è¡¨ç¤º
  // =====================================
  React.useEffect(() => {
    if (!mapInstance) return;
    showPolygons(35.6580, 139.7016);
  }, [mapInstance]);

  // =====================================
  // Overpass API / osmtogeojson
  // =====================================
  function generateOverpassQuery(lat, lon, radius) {
    return `
[out:json][timeout:25];
(
  way["boundary"="administrative"]["admin_level"~"^(8|9|10)$"](around:${radius},${lat},${lon});
  relation["boundary"="administrative"]["admin_level"~"^(8|9|10)$"](around:${radius},${lat},${lon});
);
out body;
>;
out skel qt;`;
  }

  async function fetchOverpassData(lat, lon, radius) {
    const key = `${lat},${lon},${radius}`;
    if (overpassCache.current.has(key)) {
      return overpassCache.current.get(key);
    }
    const query = generateOverpassQuery(lat, lon, radius);
    const res = await fetch('https://overpass-api.de/api/interpreter', {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: 'data=' + encodeURIComponent(query)
    });
    if (!res.ok) {
      throw new Error('Overpass APIã‚¨ãƒ©ãƒ¼');
    }
    const data = await res.json();
    const geojson = osmtogeojson(data);
    overpassCache.current.set(key, geojson);
    return geojson;
  }

  function renderGeoJSON(geojson) {
    if (!mapInstance) return;
    if (polygonLayer) {
      mapInstance.removeLayer(polygonLayer);
    }
    const newLayer = L.geoJSON(geojson, {
      style: {
        fillColor: '#2196f3',
        fillOpacity: 0.3,
        color: '#1976d2',
        weight: 2,
      },
      onEachFeature: (feature, layer) => {
        const name = feature.properties?.tags?.name || 'ä¸æ˜';
        const admin = feature.properties?.tags?.admin_level || 'ä¸æ˜';
        let content = `<strong>${name}</strong> (admin:${admin})`;
        // ä¸­å¿ƒåº§æ¨™
        try {
          const centroid = turf.centroid(feature);
          const lat = centroid.geometry.coordinates[1].toFixed(6);
          const lon = centroid.geometry.coordinates[0].toFixed(6);
          content += `<br>ä¸­å¿ƒ: lat=${lat}, lon=${lon}`;
        } catch(e){}
        layer.bindPopup(content);
      }
    }).addTo(mapInstance);
    setPolygonLayer(newLayer);
    updatePolygonStats(geojson);
  }

  function updatePolygonStats(geojson) {
    const statsDiv = document.getElementById('statsContainer');
    if (!statsDiv) return;
    const count = geojson.features.length;
    statsDiv.style.display = 'block';
    statsDiv.innerHTML = `å–å¾—ãƒãƒªã‚´ãƒ³æ•°: ${count}`;
  }

  async function showPolygons(lat, lon) {
    if (!mapInstance) return;
    try {
      const data = await fetchOverpassData(lat, lon, 1500);
      renderGeoJSON(data);
    } catch (err) {
      showError(`ãƒãƒªã‚´ãƒ³å–å¾—å¤±æ•—: ${err.message}`);
    }
  }

  window.showPolygons = (lat, lon) => showPolygons(lat, lon);

  // =====================================
  // GSI ã‚¸ã‚ªã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚° (ä½æ‰€â†’åº§æ¨™)
  // =====================================
  async function geocodeAddressGSI(addr) {
    const url = `https://msearch.gsi.go.jp/address-search/AddressSearch?q=${encodeURIComponent(addr)}`;
    const res = await fetch(url);
    if (!res.ok) {
      throw new Error('ã‚¸ã‚ªã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°APIã‚¨ãƒ©ãƒ¼');
    }
    const data = await res.json();
    if (!data || data.length === 0) {
      throw new Error('ä½æ‰€ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ');
    }
    const tokyo = data.filter(d => d.address && d.address.includes('æ±äº¬éƒ½'));
    const selected = tokyo.length > 0 ? tokyo[0] : data[0];
    const coords = selected.geometry.coordinates; // [lon, lat]
    return {
      lat: coords[1],
      lon: coords[0],
      displayName: selected.address || addr
    };
  }

  // =====================================
  // æ¤œç´¢ã§ãƒ†ãƒ¼ãƒ–ãƒ«ã«è¿½åŠ  (åç§°/ä½æ‰€/lat/lon)
  // =====================================
  async function handleSearch() {
    try {
      setMessage(null);
      if (!mapInstance) return;

      let latVal, lonVal, label;
      if (searchType === 'address') {
        if (!address.trim()) throw new Error('ä½æ‰€ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
        const result = await geocodeAddressGSI(address.trim());
        latVal = result.lat;
        lonVal = result.lon;
        label = result.displayName; 
      } else {
        // åº§æ¨™
        latVal = parseFloat(latInput);
        lonVal = parseFloat(lonInput);
        if (isNaN(latVal) || isNaN(lonVal)) {
          throw new Error('ç·¯åº¦çµŒåº¦ã‚’æ­£ã—ãå…¥åŠ›ã—ã¦ãã ã•ã„');
        }
        label = `åº§æ¨™æŒ‡å®š(${latVal},${lonVal})`;
      }

      // ãƒãƒƒãƒ—ç§»å‹• & ãƒãƒªã‚´ãƒ³è¡¨ç¤º
      mapInstance.setView([latVal, lonVal], 14);
      await showPolygons(latVal, lonVal);

      // ãƒ†ãƒ¼ãƒ–ãƒ«ã«è¿½åŠ 
      setPlotsData(prev => [
        ...prev,
        {
          selected: false,
          name: label,
          address: label,
          lat: latVal,
          lon: lonVal,
          startDate: '',
          endDate: '',
          sales: '',
          customers: '',
          area: '',
          radius1: globalRadius1,
          color1: globalColor1,
          radius2: globalRadius2,
          color2: globalColor2,
          radius3: globalRadius3,
          color3: globalColor3
        }
      ]);
      showSuccess('æ¤œç´¢å®Œäº†: ãƒ†ãƒ¼ãƒ–ãƒ«ã«è¿½åŠ ã—ã¾ã—ãŸ');
    } catch (err) {
      showError(err.message);
    }
  }

  // =====================================
  // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¡¨ç¤º
  // =====================================
  function showError(msg) {
    setMessage(<Box sx={{ color:'error.main', mt:1 }}>{msg}</Box>);
  }
  function showSuccess(msg) {
    setMessage(<Box sx={{ color:'success.main', mt:1 }}>{msg}</Box>);
  }

  // =====================================
  // plotsData â†’ åœ°å›³ã«åæ˜ 
  // =====================================
  function applyPlotsData(m = mapInstance) {
    if (!m) return;
    // æ—¢å­˜ã®ãƒãƒ¼ã‚«ãƒ¼/ã‚µãƒ¼ã‚¯ãƒ«å‰Šé™¤
    circles.forEach(c => m.removeLayer(c));
    markers.forEach(mark => m.removeLayer(mark));
    setCircles([]);
    setMarkers([]);

    const newCircles = [];
    const newMarkers = [];

    plotsData.forEach(row => {
      const lt = parseFloat(row.lat);
      const ln = parseFloat(row.lon);
      if (isNaN(lt) || isNaN(ln)) return;

      // å††3ã¤
      [1,2,3].forEach(i => {
        const r = parseFloat(row[`radius${i}`]);
        const c = row[`color${i}`];
        if (!isNaN(r) && r>0) {
          const circle = L.circle([lt, ln], {
            radius: r,
            color: c,
            fillColor: c,
            fillOpacity: 0.2 - (i*0.05),
          }).addTo(m);
          newCircles.push(circle);
        }
      });

      // ãƒãƒ¼ã‚«ãƒ¼
      const marker = L.marker([lt, ln], {
        icon: L.divIcon({
          className: 'custom-marker',
          html: 'ğŸ“',
          iconSize: [25,25],
          iconAnchor: [12,25]
        })
      }).addTo(m);

      // ãƒãƒ¼ã‚«ãƒ¼ã‚¯ãƒªãƒƒã‚¯ â†’ ãƒãƒªã‚´ãƒ³å†è¡¨ç¤º
      marker.on('click', async () => {
        const popupHtml = `
          <div style="min-width:220px">
            <h3>${row.name||'åç§°æœªè¨­å®š'}</h3>
            <p>ä½æ‰€: ${row.address||''}</p>
            <p>ç·¯åº¦: ${lt}</p>
            <p>çµŒåº¦: ${ln}</p>
            <p>å£²ä¸Š: ${row.sales||''}</p>
            <p>å®¢æ•°: ${row.customers||''}</p>
            <p>é¢ç©: ${row.area||''}</p>
            <p>æœŸé–“: ${row.startDate||''} ~ ${row.endDate||''}</p>
          </div>
        `;
        marker.bindPopup(popupHtml).openPopup();

        // åœ°å›³ç§»å‹• + ãƒãƒªã‚´ãƒ³
        m.setView([lt, ln], 14);
        await showPolygons(lt, ln);
      });

      newMarkers.push(marker);
    });

    setCircles(newCircles);
    setMarkers(newMarkers);
  }

  // =====================================
  // plotsData ãƒ†ãƒ¼ãƒ–ãƒ«æ“ä½œ
  // =====================================
  function handlePlotsFieldChange(i, field, value) {
    setPlotsData(prev => {
      const cp = [...prev];
      cp[i] = { ...cp[i], [field]: value };
      return cp;
    });
  }
  function handleDeletePlotRow(i) {
    setPlotsData(prev => prev.filter((_, idx) => idx!==i));
  }

  // åŠå¾„ä¸€æ‹¬é©ç”¨
  function handleApplyGlobalRadius() {
    setPlotsData(prev =>
      prev.map(item =>
        item.selected
        ? {
            ...item,
            radius1: globalRadius1,
            color1: globalColor1,
            radius2: globalRadius2,
            color2: globalColor2,
            radius3: globalRadius3,
            color3: globalColor3
          }
        : item
      )
    );
  }

  // =====================================
  // ãƒãƒªã‚´ãƒ³ã‚¿ãƒ–
  // =====================================
  function handleTabChange(e, val) {
    setTabValue(val);
  }

  function handlePolygonFieldChange(i, field, value) {
    setPolygonsData(prev => {
      const cp = [...prev];
      cp[i] = { ...cp[i], [field]: value };
      return cp;
    });
  }
  function handleAddPolygonRow() {
    setPolygonsData(prev => [
      ...prev,
      { name:'', polygonData:'', color:'#1976d2' }
    ]);
  }
  function handleDeletePolygonRow(i) {
    setPolygonsData(prev => prev.filter((_, idx)=> idx!==i));
  }

  // ãƒãƒªã‚´ãƒ³ã‚’åœ°å›³ã«åæ˜ (ä¾‹: polygonDataã‚’GeoJSONã¨ã—ã¦èª­ã¿è¾¼ã‚€æƒ³å®š)
  function applyPolygonsToMap() {
    if (!mapInstance) return;
    if (polygonLayer) {
      mapInstance.removeLayer(polygonLayer);
    }
    // polygonDataã‚’ JSON.parse ã™ã‚‹ãªã©ã—ã¦èª­ã¿è¾¼ã¿ã€L.geoJSON(...) ã§è¡¨ç¤ºã™ã‚‹ä¾‹
    // ç°¡æ˜“å®Ÿè£…ãªã®ã§ã€å„è¡Œã® polygonData ãŒæœ‰åŠ¹ãªGeoJSONå½¢å¼ã§ã‚ã‚‹ã“ã¨ã‚’æƒ³å®š
    let features = [];
    polygonsData.forEach(row => {
      try {
        if (!row.polygonData) return;
        const geo = JSON.parse(row.polygonData); 
        // color
        features.push({
          ...geo,
          properties: {
            color: row.color||'#1976d2',
            name: row.name||''
          }
        });
      } catch(e){}
    });
    const geojson = {
      type: 'FeatureCollection',
      features: features
    };
    const newLayer = L.geoJSON(geojson, {
      style: (feature) => ({
        color: feature.properties.color||'#1976d2',
        fillColor: feature.properties.color||'#1976d2',
        fillOpacity:0.2,
        weight:2
      }),
      onEachFeature:(feature, layer) => {
        let popup = `<strong>${feature.properties.name||'åç§°ä¸æ˜'}</strong>`;
        layer.bindPopup(popup);
      }
    }).addTo(mapInstance);
    setPolygonLayer(newLayer);
  }

  // =====================================
  // CSV/Excelã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ»ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
  // =====================================
  function exportData(type, data) {
    const ws = XLSX.utils.json_to_sheet(data);
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, 'Data');
    const buffer = XLSX.write(wb, {bookType:'xlsx', type:'array'});
    const blob = new Blob([buffer], {
      type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `${type}_data.xlsx`;
    link.click();
    URL.revokeObjectURL(url);
  }

  function processImportedData(jsonData, type) {
    if (type === 'plots') {
      const rows = jsonData.map(item => ({
        selected: false,
        name: item.name || '',
        address: item.address || '',
        lat: item.lat || '',
        lon: item.lon || '',
        startDate: item.startDate || '',
        endDate: item.endDate || '',
        sales: item.sales || '',
        customers: item.customers || '',
        area: item.area || '',
        radius1: item.radius1 || 500,
        color1: item.color1 || '#1976d2',
        radius2: item.radius2 || 1000,
        color2: item.color2 || '#9c27b0',
        radius3: item.radius3 || 1500,
        color3: item.color3 || '#ff9800'
      }));
      setPlotsData(prev => [...prev, ...rows]);
    } else {
      // polygons
      const rows = jsonData.map(item => ({
        name: item.name || '',
        polygonData: item.polygonData || '',
        color: item.color || '#1976d2'
      }));
      setPolygonsData(prev => [...prev, ...rows]);
    }
  }

  // =====================================
  // Map Centering Function
  // =====================================
  function handleMoveToMarker(lat, lon) {
    if (mapInstance) {
      mapInstance.setView([lat, lon], 16); // Zoom level can be adjusted
    }
  }

  // =====================================
  // Import Data Function
  // =====================================
  function importData(file, type) {
    const reader = new FileReader();
    reader.onload = (e) => {
      const content = e.target.result;
      let jsonData = [];
      if (file.name.endsWith('.csv')) {
        jsonData = Papa.parse(content, { header: true }).data;
      } else {
        const workbook = XLSX.read(content, { type: 'binary' });
        const sheetName = workbook.SheetNames[0];
        jsonData = XLSX.utils.sheet_to_json(workbook.Sheets[sheetName]);
      }
      processImportedData(jsonData, type);
      showSuccess('ã‚¤ãƒ³ãƒãƒ¼ãƒˆå®Œäº†');
    };
    if (file.name.endsWith('.csv')) {
      reader.readAsText(file);
    } else {
      reader.readAsBinaryString(file);
    }
  }

  // =====================================
  // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
  // =====================================
  return (
    <ThemeProvider theme={theme}>
      <CssBaseline />
      
      <Box sx={{ display: 'flex', flexDirection: 'column', minHeight: '100vh' }}>
        {/* AppBar with Search & Settings Button */}
        <AppBar position="static" elevation={0}>
          <Toolbar>
            <Typography variant="h6" sx={{ flexGrow: 1 }}>
              All Features: React + Leaflet + MUI
            </Typography>
            {/* Search & Settings Button */}
            <Button 
              color="inherit" 
              onClick={handleModalOpen}
              startIcon={<span>ğŸ”</span>}
            >
              æ¤œç´¢ï¼†è¨­å®š
            </Button>
          </Toolbar>
        </AppBar>

        {/* ãƒ¡ã‚¤ãƒ³ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ */}
        <Box sx={{ flex: 1, display: 'flex', flexDirection: 'column', gap: 2, p: 2 }}>
          {/* ãƒãƒƒãƒ—ã‚»ã‚¯ã‚·ãƒ§ãƒ³ */}
          <Paper elevation={1} sx={{ height: '60vh', position: 'relative' }}>
            <div id="map" ref={mapRef} style={{ height: '100%' }}></div>
          </Paper>

          {/* ã‚¿ãƒ–ã‚»ã‚¯ã‚·ãƒ§ãƒ³ */}
          <Paper elevation={1}>
            <Tabs 
              value={tabValue} 
              onChange={handleTabChange}
              sx={{ borderBottom: 1, borderColor: 'divider' }}
            >
              <Tab label="ãƒ—ãƒ­ãƒƒãƒˆåœ°ç‚¹" />
              <Tab label="ç”ºä¸ç›®ãƒãƒªã‚´ãƒ³" />
            </Tabs>
            
            {/* ã‚¿ãƒ–ãƒ‘ãƒãƒ«å†…å®¹ã¯æ—¢å­˜ã‚³ãƒ¼ãƒ‰ã‚’ç¶­æŒ */}
            {tabValue===0 && (
              <Box sx={{ p:2, overflow:'auto' }}>
                <Box sx={{ display:'flex', gap:1, mb:2 }}>
                  <Button variant="contained" onClick={()=>exportData('plots',plotsData)}>
                    ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
                  </Button>
                  <input
                    id="importPlotsFile"
                    type="file"
                    accept=".csv,.xlsx"
                    style={{ display:'none' }}
                    onChange={(e)=>{
                      if(e.target.files?.[0]) importData(e.target.files[0],'plots');
                    }}
                  />
                  <Button variant="contained" onClick={()=>document.getElementById('importPlotsFile').click()}>
                    ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
                  </Button>
                </Box>
                <TableContainer 
                  component={Paper} 
                  sx={{ 
                    maxHeight: 'calc(100vh - 300px)',
                    '& .MuiTable-root': {
                      borderCollapse: 'collapse',
                      width: 'max-content',
                      minWidth: '100%'
                    }
                  }}
                >
                  <Table className="compact-table" size="small" stickyHeader>
                    <TableHead>
                      <TableRow>
                        <TableCell className="col-checkbox" padding="checkbox"></TableCell>
                        {/* New Move Column Header */}
                        <TableCell className="col-move">ç§»å‹•</TableCell>
                        <TableCell className="col-name">åç§°</TableCell>
                        <TableCell className="col-address">ä½æ‰€</TableCell>
                        <TableCell className="col-coord">ç·¯åº¦</TableCell>
                        <TableCell className="col-coord">çµŒåº¦</TableCell>
                        <TableCell className="col-date">é–‹å§‹æ—¥</TableCell>
                        <TableCell className="col-date">çµ‚äº†æ—¥</TableCell>
                        <TableCell className="col-number">å£²ä¸Š</TableCell>
                        <TableCell className="col-number">å®¢æ•°</TableCell>
                        <TableCell className="col-number">é¢ç©</TableCell>
                        <TableCell className="col-radius">åŠå¾„1&è‰²</TableCell>
                        <TableCell className="col-radius">åŠå¾„2&è‰²</TableCell>
                        <TableCell className="col-radius">åŠå¾„3&è‰²</TableCell>
                        <TableCell className="col-action">æ“ä½œ</TableCell>
                      </TableRow>
                    </TableHead>
                    <TableBody>
                      {plotsData
                        .slice(plotsPage * plotsPageSize, plotsPage * plotsPageSize + plotsPageSize)
                        .map((row, i) => (
                        <TableRow key={i}>
                          <TableCell padding="checkbox">
                            <Checkbox
                              checked={row.selected||false}
                              onChange={(e)=>
                                handlePlotsFieldChange(i,'selected',e.target.checked)
                              }
                            />
                          </TableCell>
                          {/* New Move Button Column */}
                          <TableCell>
                            <Button 
                              variant="outlined" 
                              size="small"
                              onClick={() => handleMoveToMarker(row.lat, row.lon)}
                            >
                              ç§»å‹•
                            </Button>
                          </TableCell>
                          <TableCell>
                            <TextField
                              variant="outlined" size="small"
                              value={row.name||''}
                              onChange={(e)=>handlePlotsFieldChange(i,'name',e.target.value)}
                            />
                          </TableCell>
                          <TableCell>
                            <TextField
                              variant="outlined" size="small"
                              value={row.address||''}
                              onChange={(e)=>handlePlotsFieldChange(i,'address',e.target.value)}
                            />
                          </TableCell>
                          <TableCell>
                            <TextField
                              type="number" variant="outlined" size="small"
                              value={row.lat||''}
                              onChange={(e)=>handlePlotsFieldChange(i,'lat',e.target.value)}
                            />
                          </TableCell>
                          <TableCell>
                            <TextField
                              type="number" variant="outlined" size="small"
                              value={row.lon||''}
                              onChange={(e)=>handlePlotsFieldChange(i,'lon',e.target.value)}
                            />
                          </TableCell>
                          <TableCell>
                            <TextField
                              type="date" variant="outlined" size="small"
                              value={row.startDate||''}
                              onChange={(e)=>handlePlotsFieldChange(i,'startDate',e.target.value)}
                            />
                          </TableCell>
                          <TableCell>
                            <TextField
                              type="date" variant="outlined" size="small"
                              value={row.endDate||''}
                              onChange={(e)=>handlePlotsFieldChange(i,'endDate',e.target.value)}
                            />
                          </TableCell>
                          <TableCell>
                            <TextField
                              type="number" variant="outlined" size="small"
                              value={row.sales||''}
                              onChange={(e)=>handlePlotsFieldChange(i,'sales',e.target.value)}
                            />
                          </TableCell>
                          <TableCell>
                            <TextField
                              type="number" variant="outlined" size="small"
                              value={row.customers||''}
                              onChange={(e)=>handlePlotsFieldChange(i,'customers',e.target.value)}
                            />
                          </TableCell>
                          <TableCell>
                            <TextField
                              type="number" variant="outlined" size="small"
                              value={row.area||''}
                              onChange={(e)=>handlePlotsFieldChange(i,'area',e.target.value)}
                            />
                          </TableCell>
                          <TableCell>
                            <Box sx={{ display:'flex', gap:1, alignItems:'center' }}>
                              <TextField
                                type="number" variant="outlined" size="small"
                                sx={{ width:60 }}
                                value={row.radius1||500}
                                onChange={(e)=>handlePlotsFieldChange(i,'radius1',e.target.value)}
                              />
                              <input
                                type="color"
                                value={row.color1||'#1976d2'}
                                onChange={(e)=>handlePlotsFieldChange(i,'color1',e.target.value)}
                                style={{ width:'40px', height:'30px', border:'none' }}
                              />
                            </Box>
                          </TableCell>
                          <TableCell>
                            <Box sx={{ display:'flex', gap:1, alignItems:'center' }}>
                              <TextField
                                type="number" variant="outlined" size="small"
                                sx={{ width:60 }}
                                value={row.radius2||1000}
                                onChange={(e)=>handlePlotsFieldChange(i,'radius2',e.target.value)}
                              />
                              <input
                                type="color"
                                value={row.color2||'#9c27b0'}
                                onChange={(e)=>handlePlotsFieldChange(i,'color2',e.target.value)}
                                style={{ width:'40px', height:'30px', border:'none' }}
                              />
                            </Box>
                          </TableCell>
                          <TableCell>
                            <Box sx={{ display:'flex', gap:1, alignItems:'center' }}>
                              <TextField
                                type="number" variant="outlined" size="small"
                                sx={{ width:60 }}
                                value={row.radius3||1500}
                                onChange={(e)=>handlePlotsFieldChange(i,'radius3',e.target.value)}
                              />
                              <input
                                type="color"
                                value={row.color3||'#ff9800'}
                                onChange={(e)=>handlePlotsFieldChange(i,'color3',e.target.value)}
                                style={{ width:'40px', height:'30px', border:'none' }}
                              />
                            </Box>
                          </TableCell>
                          <TableCell>
                            <IconButton size="small" onClick={()=>handleDeletePlotRow(i)}>
                              ğŸ—‘ï¸
                            </IconButton>
                          </TableCell>
                        </TableRow>
                      ))}
                    </TableBody>
                  </Table>
                </TableContainer>
                <Box sx={{ display: 'flex', alignItems: 'center', gap: 2, mt: 2 }}>
                  <TablePagination
                    component="div"
                    count={plotsData.length}
                    page={plotsPage}
                    onPageChange={handlePlotsPageChange}
                    rowsPerPage={plotsPageSize}
                    onRowsPerPageChange={handlePlotsPageSizeChange}
                    rowsPerPageOptions={[10, 20, 30, { label: 'å…¨ã¦', value: -1 }]}
                    labelRowsPerPage="è¡¨ç¤ºä»¶æ•°:"
                  />
                </Box>
              </Box>
            )}

            {/* ãƒãƒªã‚´ãƒ³ã‚¿ãƒ– */}
            {tabValue===1 && (
              <Box sx={{ p:2, overflowX:'auto' }}>
                <Box sx={{ display:'flex', gap:1, mb:2 }}>
                  <Button variant="contained" onClick={handleAddPolygonRow}>
                    æ–°è¦è¿½åŠ 
                  </Button>
                  <Button variant="contained" onClick={applyPolygonsToMap}>
                    åœ°å›³ã«åæ˜ 
                  </Button>
                  <Button variant="contained" onClick={()=>exportData('polygons', polygonsData)}>
                    ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
                  </Button>
                  <input
                    id="importPolygonsFile"
                    type="file"
                    accept=".csv,.xlsx"
                    style={{ display:'none' }}
                    onChange={(e)=>{
                      if(e.target.files?.[0]) importData(e.target.files[0], 'polygons');
                    }}
                  />
                  <Button variant="contained" onClick={()=>document.getElementById('importPolygonsFile').click()}>
                    ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
                  </Button>
                </Box>

                <TableContainer component={Paper} sx={{ maxHeight: 'calc(100vh - 350px)' }}>
                  <Table className="compact-table" size="small" stickyHeader>
                    <TableHead>
                      <TableRow>
                        <TableCell>ç”ºä¸ç›®å</TableCell>
                        <TableCell>ãƒãƒªã‚´ãƒ³ãƒ‡ãƒ¼ã‚¿(JSON)</TableCell>
                        <TableCell>è‰²</TableCell>
                        <TableCell>æ“ä½œ</TableCell>
                      </TableRow>
                    </TableHead>
                    <TableBody>
                      {polygonsData
                        .slice(polygonsPage * polygonsPageSize, polygonsPage * polygonsPageSize + polygonsPageSize)
                        .map((row, i) => (
                        <TableRow key={i}>
                          <TableCell>
                            <TextField
                              variant="outlined" size="small"
                              value={row.name||''}
                              onChange={(e)=>handlePolygonFieldChange(i,'name',e.target.value)}
                            />
                          </TableCell>
                          <TableCell>
                            <TextField
                              variant="outlined" size="small" fullWidth
                              placeholder='{"type":"Feature","geometry":{...}}'
                              value={row.polygonData||''}
                              onChange={(e)=>handlePolygonFieldChange(i,'polygonData',e.target.value)}
                            />
                          </TableCell>
                          <TableCell>
                            <input
                              type="color"
                              value={row.color||'#1976d2'}
                              onChange={(e)=>handlePolygonFieldChange(i,'color',e.target.value)}
                              style={{ width:'40px', height:'30px', border:'none' }}
                            />
                          </TableCell>
                          <TableCell>
                            <IconButton size="small" onClick={()=>handleDeletePolygonRow(i)}>
                              ğŸ—‘ï¸
                            </IconButton>
                          </TableCell>
                        </TableRow>
                      ))}
                    </TableBody>
                  </Table>
                </TableContainer>
                <Box sx={{ display: 'flex', alignItems: 'center', gap: 2, mt: 2 }}>
                  <TablePagination
                    component="div"
                    count={polygonsData.length}
                    page={polygonsPage}
                    onPageChange={handlePolygonsPageChange}
                    rowsPerPage={polygonsPageSize}
                    onRowsPerPageChange={handlePolygonsPageSizeChange}
                    rowsPerPageOptions={[10, 20, 30, { label: 'å…¨ã¦', value: -1 }]}
                    labelRowsPerPage="è¡¨ç¤ºä»¶æ•°:"
                  />
                </Box>
              </Box>
            )}
          </Paper>
        </Box>

        {/* ãƒ•ãƒƒã‚¿ãƒ¼ */}
        <Box component="footer" sx={{ 
          py: 2, 
          px: 3, 
          mt: 'auto', 
          backgroundColor: 'background.paper',
          borderTop: 1,
          borderColor: 'divider'
        }}>
          <Typography variant="body2" color="text.secondary" align="center">
            Â© 2023 Map Application
          </Typography>
        </Box>
      </Box>

      {/* ãƒ¢ãƒ¼ãƒ€ãƒ«ãƒ€ã‚¤ã‚¢ãƒ­ã‚° */}
      <Dialog 
        open={modalOpen} 
        onClose={handleModalClose}
        maxWidth="sm"
        fullWidth
        PaperProps={{
          elevation: 2,
          sx: { borderRadius: 2 }
        }}
      >
        <DialogTitle>
          <Box className="modal-header" sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
            æ¤œç´¢ï¼†è¨­å®š
            <IconButton 
              className="close-button"
              onClick={handleModalClose}
            >
              âœ–
            </IconButton>
          </Box>
        </DialogTitle>
        <DialogContent className="modal-content">
          {/* æ¤œç´¢ã‚»ã‚¯ã‚·ãƒ§ãƒ³ */}
          <Box className="modal-section" sx={{ mb: 4 }}>
            <Typography variant="subtitle1" className="modal-section-title">
              ğŸ” åœ°ç‚¹æ¤œç´¢
            </Typography>
            <FormControl>
              <RadioGroup row value={searchType} onChange={(e)=>setSearchType(e.target.value)}>
                <FormControlLabel value="address" control={<Radio/>} label="ä½æ‰€æ¤œç´¢"/>
                <FormControlLabel value="coords" control={<Radio/>} label="åº§æ¨™æ¤œç´¢"/>
              </RadioGroup>
            </FormControl>
            
            {searchType==='address' ? (
              <TextField
                label="ä½æ‰€"
                variant="outlined"
                size="small"
                fullWidth
                value={address}
                onChange={(e)=>setAddress(e.target.value)}
                sx={{ mt:1 }}
              />
            ) : (
              <Box sx={{ display:'flex', gap:1, mt:1 }}>
                <TextField
                  label="ç·¯åº¦"
                  variant="outlined"
                  size="small"
                  fullWidth
                  value={latInput}
                  onChange={(e)=>setLatInput(e.target.value)}
                />
                <TextField
                  label="çµŒåº¦"
                  variant="outlined"
                  size="small"
                  fullWidth
                  value={lonInput}
                  onChange={(e)=>setLonInput(e.target.value)}
                />
              </Box>
            )}
            <Box className="modal-actions" sx={{ mt:2 }}>
              <Button 
                variant="contained" 
                onClick={() => {
                  handleSearch();
                  handleModalClose();
                }}
                startIcon={<span>ğŸ”</span>}
              >
                æ¤œç´¢ã—ã¦è¿½åŠ 
              </Button>
            </Box>
            {message && <Box sx={{mt:2}}>{message}</Box>}
          </Box>

          {/* åŠå¾„è¨­å®šã‚»ã‚¯ã‚·ãƒ§ãƒ³ */}
          <Box className="modal-section">
            <Typography variant="subtitle1" className="modal-section-title">
              â­• åŠå¾„è¨­å®šã®ä¸€æ‹¬é©ç”¨
            </Typography>
            <Box sx={{ display:'flex', flexDirection:'column', gap:2, mt:1 }}>
              <Box sx={{ display:'flex', gap:1, alignItems:'center' }}>
                <TextField
                  label="åŠå¾„1"
                  type="number"
                  size="small"
                  value={globalRadius1}
                  onChange={(e)=>setGlobalRadius1(e.target.value)}
                  sx={{ width:120 }}
                />
                <input
                  type="color"
                  value={globalColor1}
                  onChange={(e)=>setGlobalColor1(e.target.value)}
                  style={{ width:'40px', height:'30px', border:'none' }}
                />
                <Typography variant="body2" color="text.secondary">m</Typography>
              </Box>
              <Box sx={{ display:'flex', gap:1, alignItems:'center' }}>
                <TextField
                  label="åŠå¾„2"
                  type="number"
                  size="small"
                  value={globalRadius2}
                  onChange={(e)=>setGlobalRadius2(e.target.value)}
                  sx={{ width:120 }}
                />
                <input
                  type="color"
                  value={globalColor2}
                  onChange={(e)=>setGlobalColor2(e.target.value)}
                  style={{ width:'40px', height:'30px', border:'none' }}
                />
                <Typography variant="body2" color="text.secondary">m</Typography>
              </Box>
              <Box sx={{ display:'flex', gap:1, alignItems:'center' }}>
                <TextField
                  label="åŠå¾„3"
                  type="number"
                  size="small"
                  value={globalRadius3}
                  onChange={(e)=>setGlobalRadius3(e.target.value)}
                  sx={{ width:120 }}
                />
                <input
                  type="color"
                  value={globalColor3}
                  onChange={(e)=>setGlobalColor3(e.target.value)}
                  style={{ width:'40px', height:'30px', border:'none' }}
                />
                <Typography variant="body2" color="text.secondary">m</Typography>
              </Box>
            </Box>
            <Box className="modal-actions" sx={{ display:'flex', justifyContent: 'flex-end', gap:1, mt:2 }}>
              <Button 
                variant="outlined" 
                onClick={handleModalClose}
                startIcon={<span>âœ–</span>}
              >
                ã‚­ãƒ£ãƒ³ã‚»ãƒ«
              </Button>
              <Button 
                variant="contained" 
                color="primary"
                onClick={() => {
                  handleApplyGlobalRadius();
                  handleModalClose();
                }}
                startIcon={<span>âœ“</span>}
              >
                é¸æŠé …ç›®ã«é©ç”¨
              </Button>
            </Box>
          </Box>
        </DialogContent>
      </Dialog>

    </ThemeProvider>
  );
}

ReactDOM.createRoot(document.getElementById('root')).render(<App />);
</script>
</body>
</html>
