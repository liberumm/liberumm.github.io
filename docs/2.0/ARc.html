<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Modern A-Frame Physics Playground</title>

  <!-- A-Frame & Physics -->
  <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-physics-system@v4.2.2/dist/aframe-physics-system.min.js"></script>
  <script src="https://unpkg.com/aframe-particle-system-component@1.1.3/dist/aframe-particle-system-component.min.js"></script>

  <style>
    :root {
      --primary-color: #667eea;
      --secondary-color: #764ba2;
      --accent-color: #f093fb;
      --surface-color: rgba(255, 255, 255, 0.1);
      --text-color: #ffffff;
      --success-color: #4ade80;
      --warning-color: #fbbf24;
      --danger-color: #ef4444;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      margin: 0;
      overflow: hidden;
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
    }

    a-scene {
      width: 100vw;
      height: 100vh;
    }

    /* „É¢„ÉÄ„É≥„Å™„Ç≥„É≥„Éà„É≠„Éº„É´„Éë„Éç„É´ */
    .control-panel {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      gap: 12px;
      max-width: 280px;
    }

    .control-group {
      background: var(--surface-color);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 16px;
      padding: 16px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }

    .control-button {
      width: 100%;
      padding: 12px 16px;
      background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
      border: none;
      border-radius: 12px;
      color: var(--text-color);
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      margin-bottom: 8px;
    }

    .control-button:last-child {
      margin-bottom: 0;
    }

    .control-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
    }

    .control-button:active {
      transform: translateY(0);
    }

    .control-button.active {
      background: linear-gradient(135deg, var(--success-color), #22c55e);
    }

    .control-button.danger {
      background: linear-gradient(135deg, var(--danger-color), #dc2626);
    }

    .control-button.warning {
      background: linear-gradient(135deg, var(--warning-color), #f59e0b);
    }

    .status-indicator {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--success-color);
      margin-right: 8px;
    }

    .status-indicator.off {
      background: #6b7280;
    }

    /* „Éò„É´„ÉóË°®Á§∫ */
    .help-panel {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 1000;
      background: var(--surface-color);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 16px;
      padding: 16px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      color: var(--text-color);
      font-size: 12px;
      line-height: 1.4;
      max-width: 250px;
    }

    .help-title {
      font-weight: 600;
      margin-bottom: 8px;
      color: var(--accent-color);
    }

    /* „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπË°®Á§∫ */
    .performance-panel {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 1000;
      background: var(--surface-color);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 12px;
      padding: 12px;
      color: var(--text-color);
      font-size: 12px;
      font-family: 'Courier New', monospace;
    }

    /* „É¨„Çπ„Éù„É≥„Ç∑„ÉñÂØæÂøú */
    @media (max-width: 768px) {
      .control-panel {
        max-width: 240px;
        gap: 8px;
      }
      
      .control-group {
        padding: 12px;
      }
      
      .control-button {
        padding: 10px 12px;
        font-size: 13px;
      }
      
      .help-panel {
        bottom: 100px;
        max-width: 200px;
      }
    }
  </style>

  <script>
    // „É¢„ÉÄ„É≥„Å™„Éá„Éê„ÉÉ„Ç∞„Ç∑„Çπ„ÉÜ„É†
    class Logger {
      constructor(name, level = 'info') {
        this.name = name;
        this.level = level;
        this.levels = { debug: 0, info: 1, warn: 2, error: 3 };
      }

      log(level, ...args) {
        if (this.levels[level] >= this.levels[this.level]) {
          const timestamp = new Date().toLocaleTimeString();
          console[level](`[${timestamp}] [${this.name}]`, ...args);
        }
      }

      debug(...args) { this.log('debug', ...args); }
      info(...args) { this.log('info', ...args); }
      warn(...args) { this.log('warn', ...args); }
      error(...args) { this.log('error', ...args); }
    }

    const logger = new Logger('PhysicsDemo');

    // Ë®≠ÂÆöÁÆ°ÁêÜ„ÇØ„É©„Çπ
    class GameSettings {
      constructor() {
        this.settings = {
          snapToGrid: true,
          destructionMode: 'conditional', // 'always', 'conditional', 'never'
          fragmentBehavior: 'disappear', // 'disappear', 'remain'
          gravity: -9.8,
          debugMode: false
        };
        this.callbacks = new Map();
      }

      get(key) {
        return this.settings[key];
      }

      set(key, value) {
        const oldValue = this.settings[key];
        this.settings[key] = value;
        
        if (this.callbacks.has(key)) {
          this.callbacks.get(key).forEach(cb => cb(value, oldValue));
        }
        
        logger.info(`Setting changed: ${key} = ${value}`);
      }

      onChange(key, callback) {
        if (!this.callbacks.has(key)) {
          this.callbacks.set(key, []);
        }
        this.callbacks.get(key).push(callback);
      }

      reset() {
        Object.assign(this.settings, {
          snapToGrid: true,
          destructionMode: 'conditional',
          fragmentBehavior: 'disappear',
          gravity: -9.8,
          debugMode: false
        });
        logger.info('Settings reset to defaults');
      }
    }

    const gameSettings = new GameSettings();

    // „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÁõ£Ë¶ñ
    class PerformanceMonitor {
      constructor() {
        this.fps = 0;
        this.frameCount = 0;
        this.lastTime = performance.now();
        this.entityCount = 0;
        this.panel = null;
      }

      init() {
        this.panel = document.getElementById('performance-panel');
        this.startMonitoring();
      }

      startMonitoring() {
        const updateStats = () => {
          const now = performance.now();
          this.frameCount++;
          
          if (now - this.lastTime >= 1000) {
            this.fps = Math.round((this.frameCount * 1000) / (now - this.lastTime));
            this.frameCount = 0;
            this.lastTime = now;
            
            const scene = document.querySelector('a-scene');
            if (scene) {
              this.entityCount = scene.querySelectorAll('.cube, .fragment').length;
            }
            
            this.updateDisplay();
          }
          
          requestAnimationFrame(updateStats);
        };
        updateStats();
      }

      updateDisplay() {
        if (this.panel) {
          this.panel.innerHTML = `
            FPS: ${this.fps}<br>
            Objects: ${this.entityCount}
          `;
        }
      }
    }

    const perfMonitor = new PerformanceMonitor();

    // Áä∂ÊÖãÁÆ°ÁêÜ„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà
    AFRAME.registerComponent('game-manager', {
      init: function() {
        this.scene = this.el;
        this.cubeCount = 0;
        
        // Ë®≠ÂÆöÂ§âÊõ¥„ÅÆ„É™„Çπ„Éä„Éº
        gameSettings.onChange('destructionMode', (value) => {
          this.updateDestructionMode(value);
        });
        
        gameSettings.onChange('gravity', (value) => {
          this.scene.setAttribute('physics', { gravity: value });
        });
      },

      updateDestructionMode: function(mode) {
        const cubes = this.scene.querySelectorAll('.cube');
        cubes.forEach(cube => {
          if (cube.components['destructible']) {
            cube.components['destructible'].data.mode = mode;
          }
        });
      }
    });

    // ÊîπËâØ„Åï„Çå„ÅüÁ†¥Â£ä„Ç∑„Çπ„ÉÜ„É†
    AFRAME.registerComponent('destructible', {
      schema: {
        threshold: { type: 'number', default: 5 },
        mode: { type: 'string', default: 'conditional' }
      },

      init: function() {
        this.el.addEventListener('body-loaded', () => {
          this.attachCollisionHandler();
        });
      },

      attachCollisionHandler: function() {
        if (!this.el.body) return;

        this.el.body.addEventListener('collide', (event) => {
          const collision = event.contact;
          const impactVelocity = collision.getImpactVelocityAlongNormal?.() || 0;
          
          if (this.shouldDestroy(impactVelocity)) {
            this.destroy();
          }
        });
      },

      shouldDestroy: function(impactVelocity) {
        const mode = gameSettings.get('destructionMode');
        const isHighDrop = this.el.getAttribute('data-high-drop') === 'true';
        
        switch (mode) {
          case 'always':
            return true;
          case 'conditional':
            return impactVelocity > this.data.threshold || isHighDrop;
          case 'never':
            return false;
          default:
            return false;
        }
      },

      destroy: function() {
        this.createExplosion();
        this.el.parentNode?.removeChild(this.el);
        logger.info(`Cube destroyed: ${this.el.id}`);
      },

      createExplosion: function() {
        const position = this.el.object3D.position;
        const color = this.el.getAttribute('color');
        
        // „Éë„Éº„ÉÜ„Ç£„ÇØ„É´„Ç®„Éï„Çß„ÇØ„Éà
        this.createParticleEffect(position);
        
        // „Éï„É©„Ç∞„É°„É≥„ÉàÁîüÊàê
        this.createFragments(position, color);
      },

      createParticleEffect: function(position) {
        const explosion = document.createElement('a-entity');
        explosion.setAttribute('position', position);
        explosion.setAttribute('particle-system', {
          preset: 'dust',
          color: '#FF4500, #FFD700, #FF6347',
          size: 0.1,
          particleCount: 150,
          opacity: 0.8,
          accelerationValue: '0 -5 0',
          velocityValue: '0 5 0',
          velocitySpread: '2 2 2'
        });
        
        this.el.sceneEl.appendChild(explosion);
        setTimeout(() => explosion.parentNode?.removeChild(explosion), 2000);
      },

      createFragments: function(position, color) {
        const fragmentCount = 8;
        const fragmentSize = 0.15;
        const shouldDisappear = gameSettings.get('fragmentBehavior') === 'disappear';
        
        for (let i = 0; i < fragmentCount; i++) {
          const fragment = document.createElement('a-box');
          
          // „É©„É≥„ÉÄ„É†„Å™‰ΩçÁΩÆ„Ç™„Éï„Çª„ÉÉ„Éà
          const offset = new THREE.Vector3(
            (Math.random() - 0.5) * 0.3,
            (Math.random() - 0.5) * 0.3,
            (Math.random() - 0.5) * 0.3
          );
          
          fragment.setAttribute('position', {
            x: position.x + offset.x,
            y: position.y + offset.y,
            z: position.z + offset.z
          });
          
          fragment.setAttribute('geometry', {
            primitive: 'box',
            width: fragmentSize,
            height: fragmentSize,
            depth: fragmentSize
          });
          
          fragment.setAttribute('material', {
            color: color,
            transparent: true,
            opacity: 1
          });
          
          fragment.setAttribute('dynamic-body', { mass: 0.1 });
          fragment.classList.add('fragment');
          
          // Áâ©ÁêÜ„Éú„Éá„Ç£Ê∫ñÂÇôÂæå„Å´ÂàùÈÄü„ÇíË®≠ÂÆö
          fragment.addEventListener('body-loaded', () => {
            const velocity = new THREE.Vector3(
              (Math.random() - 0.5) * 4,
              Math.random() * 4,
              (Math.random() - 0.5) * 4
            );
            fragment.body.velocity.copy(velocity);
            
            const angularVelocity = new THREE.Vector3(
              (Math.random() - 0.5) * 8,
              (Math.random() - 0.5) * 8,
              (Math.random() - 0.5) * 8
            );
            fragment.body.angularVelocity.copy(angularVelocity);
          });
          
          // Ê∂à„Åà„ÇãË®≠ÂÆö„ÅÆÂ†¥Âêà„ÅØ„Éï„Çß„Éº„Éâ„Ç¢„Ç¶„Éà
          if (shouldDisappear) {
            fragment.setAttribute('animation', {
              property: 'material.opacity',
              to: 0,
              dur: 3000,
              easing: 'easeOutQuad'
            });
            
            setTimeout(() => {
              fragment.parentNode?.removeChild(fragment);
            }, 3000);
          }
          
          this.el.sceneEl.appendChild(fragment);
        }
      }
    });

    // ËêΩ‰∏ãÁõ£Ë¶ñ„Ç∑„Çπ„ÉÜ„É†
    AFRAME.registerComponent('fall-detector', {
      schema: {
        heightThreshold: { type: 'number', default: 3 },
        velocityThreshold: { type: 'number', default: 0.2 }
      },

      init: function() {
        this.initialY = this.el.object3D.position.y;
        this.isFalling = false;
      },

      tick: function() {
        if (!this.el.body) return;
        
        const currentY = this.el.object3D.position.y;
        const velocity = this.el.body.velocity.y;
        const fallDistance = this.initialY - currentY;
        
        const shouldMarkAsHighDrop = 
          fallDistance > this.data.heightThreshold && 
          velocity < -this.data.velocityThreshold;
        
        if (shouldMarkAsHighDrop && !this.isFalling) {
          this.isFalling = true;
          this.el.setAttribute('data-high-drop', 'true');
          logger.debug(`High drop detected for ${this.el.id}`);
        } else if (!shouldMarkAsHighDrop && this.isFalling) {
          this.isFalling = false;
          this.el.removeAttribute('data-high-drop');
        }
      }
    });

    // ÊîπËâØ„Åï„Çå„Åü„Éâ„É©„ÉÉ„Ç∞„Ç∑„Çπ„ÉÜ„É†
    AFRAME.registerComponent('advanced-drag', {
      init: function() {
        this.draggedElement = null;
        this.isDragging = false;
        this.shiftPressed = false;
        this.originalColor = null;
        
        this.raycaster = new THREE.Raycaster();
        this.mouse = new THREE.Vector2();
        this.camera = null;
        this.canvas = null;
        
        this.bindEvents();
        this.createDragIndicator();
      },

      bindEvents: function() {
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Shift') this.shiftPressed = true;
        });
        
        document.addEventListener('keyup', (e) => {
          if (e.key === 'Shift') this.shiftPressed = false;
        });
        
        this.el.sceneEl.addEventListener('loaded', () => {
          this.camera = this.el.sceneEl.camera;
          this.canvas = this.el.sceneEl.canvas;
          
          this.canvas.addEventListener('dblclick', this.onDoubleClick.bind(this));
          this.canvas.addEventListener('mousemove', this.onMouseMove.bind(this));
          this.canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
        });
      },

      createDragIndicator: function() {
        this.indicator = document.createElement('a-ring');
        this.indicator.setAttribute('geometry', {
          radiusInner: 0.4,
          radiusOuter: 0.6
        });
        this.indicator.setAttribute('material', {
          color: '#00ff00',
          transparent: true,
          opacity: 0.6
        });
        this.indicator.setAttribute('visible', false);
        this.el.sceneEl.appendChild(this.indicator);
      },

      onDoubleClick: function(event) {
        const intersectedElement = this.getIntersectedElement(event);
        if (!intersectedElement || !intersectedElement.components['dynamic-body']) return;
        
        this.startDragging(intersectedElement);
      },

      onMouseMove: function(event) {
        if (!this.isDragging || !this.draggedElement) return;
        
        const newPosition = this.calculateNewPosition(event);
        if (newPosition) {
          this.updateElementPosition(newPosition);
        }
      },

      onMouseUp: function() {
        if (this.isDragging) {
          this.stopDragging();
        }
      },

      getIntersectedElement: function(event) {
        const rect = this.canvas.getBoundingClientRect();
        this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        
        this.raycaster.setFromCamera(this.mouse, this.camera);
        
        const targetObjects = [];
        this.el.sceneEl.object3D.traverse((obj) => {
          if (obj.el?.components['dynamic-body']) {
            targetObjects.push(obj);
          }
        });
        
        const intersects = this.raycaster.intersectObjects(targetObjects, true);
        return intersects.length > 0 ? intersects[0].object.el : null;
      },

      startDragging: function(element) {
        this.draggedElement = element;
        this.isDragging = true;
        this.originalColor = element.getAttribute('color');
        
        // „Éè„Ç§„É©„Ç§„ÉàË°®Á§∫
        element.setAttribute('color', '#ffff00');
        
        // Áâ©ÁêÜ„Çí‰∏ÄÊôÇÂÅúÊ≠¢
        if (element.body) {
          element.body.sleep();
        }
        
        logger.info(`Started dragging: ${element.id}`);
      },

      calculateNewPosition: function(event) {
        const rect = this.canvas.getBoundingClientRect();
        this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        
        this.raycaster.setFromCamera(this.mouse, this.camera);
        
        const currentPos = this.draggedElement.object3D.position;
        const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -currentPos.y);
        const intersectPoint = new THREE.Vector3();
        
        if (this.raycaster.ray.intersectPlane(plane, intersectPoint)) {
          // „Ç∞„É™„ÉÉ„Éâ„Çπ„Éä„ÉÉ„Éó
          if (gameSettings.get('snapToGrid')) {
            const gridSize = 1;
            intersectPoint.x = Math.round(intersectPoint.x / gridSize) * gridSize;
            intersectPoint.z = Math.round(intersectPoint.z / gridSize) * gridSize;
          }
          
          return intersectPoint;
        }
        
        return null;
      },

      updateElementPosition: function(position) {
        if (this.draggedElement.body) {
          this.draggedElement.body.position.copy(position);
          this.draggedElement.body.velocity.set(0, 0, 0);
          this.draggedElement.body.angularVelocity.set(0, 0, 0);
        }
        
        // „Ç§„É≥„Ç∏„Ç±„Éº„Çø„ÉºË°®Á§∫
        this.indicator.setAttribute('position', position);
        this.indicator.setAttribute('visible', true);
      },

      stopDragging: function() {
        if (this.draggedElement) {
          // ÂÖÉ„ÅÆËâ≤„Å´Êàª„Åô
          this.draggedElement.setAttribute('color', this.originalColor);
          
          // Áâ©ÁêÜ„ÇíÂÜçÈñã
          if (this.draggedElement.body) {
            this.draggedElement.body.wakeUp();
          }
          
          logger.info(`Stopped dragging: ${this.draggedElement.id}`);
        }
        
        this.draggedElement = null;
        this.isDragging = false;
        this.indicator.setAttribute('visible', false);
      }
    });

    // „Ç≠„É•„Éº„ÉñÁîüÊàê„Ç∑„Çπ„ÉÜ„É†
    class CubeGenerator {
      constructor(scene) {
        this.scene = scene;
        this.colors = [
          '#4CC3D9', '#EF2D5E', '#7BC8A4', '#FFC65D', 
          '#FF6347', '#32CD32', '#8A2BE2', '#FFD700', '#00CED1'
        ];
      }

      createCube(position, color = null) {
        const cube = document.createElement('a-box');
        const cubeColor = color || this.getRandomColor();
        const id = `cube-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        
        cube.setAttribute('id', id);
        cube.setAttribute('position', position);
        cube.setAttribute('geometry', {
          width: 1,
          height: 1,
          depth: 1
        });
        cube.setAttribute('material', {
          color: cubeColor,
          roughness: 0.3,
          metalness: 0.1
        });
        cube.setAttribute('dynamic-body', { mass: 1 });
        cube.setAttribute('destructible', {});
        cube.setAttribute('fall-detector', {});
        cube.classList.add('cube');
        
        this.scene.appendChild(cube);
        logger.info(`Created cube: ${id} at ${JSON.stringify(position)}`);
        
        return cube;
      }

      createRandomCube() {
        const position = {
          x: (Math.random() - 0.5) * 10,
          y: Math.random() * 5 + 5,
          z: (Math.random() - 0.5) * 10
        };
        
        return this.createCube(position);
      }

      createInitialGrid() {
        this.clearAllCubes();
        
        const gridSize = 5;
        const spacing = 2;
        const startX = -(gridSize - 1) * spacing / 2;
        const startZ = -(gridSize - 1) * spacing / 2;
        
        for (let i = 0; i < gridSize; i++) {
          for (let j = 0; j < gridSize; j++) {
            const position = {
              x: startX + i * spacing,
              y: 2,
              z: startZ + j * spacing
            };
            
            this.createCube(position);
          }
        }
        
        logger.info(`Created ${gridSize * gridSize} cubes in grid formation`);
      }

      clearAllCubes() {
        const cubes = this.scene.querySelectorAll('.cube');
        cubes.forEach(cube => cube.parentNode?.removeChild(cube));
        
        const fragments = this.scene.querySelectorAll('.fragment');
        fragments.forEach(fragment => fragment.parentNode?.removeChild(fragment));
        
        logger.info('Cleared all cubes and fragments');
      }

      getRandomColor() {
        return this.colors[Math.floor(Math.random() * this.colors.length)];
      }
    }

    // UIÂà∂Âæ°
    class UIController {
      constructor() {
        this.cubeGenerator = null;
      }

      init() {
        const scene = document.querySelector('a-scene');
        this.cubeGenerator = new CubeGenerator(scene);
        
        this.bindEvents();
        this.updateUI();
        
        // ÂàùÊúü„Ç≠„É•„Éº„ÉñÁîüÊàê
        setTimeout(() => {
          this.cubeGenerator.createInitialGrid();
        }, 1000);
      }

      bindEvents() {
        // „Çπ„Éä„ÉÉ„ÉóÂàá„ÇäÊõø„Åà
        document.getElementById('snap-btn').addEventListener('click', () => {
          const current = gameSettings.get('snapToGrid');
          gameSettings.set('snapToGrid', !current);
          this.updateUI();
        });

        // Á†¥Â£ä„É¢„Éº„ÉâÂàá„ÇäÊõø„Åà
        document.getElementById('destruction-btn').addEventListener('click', () => {
          const modes = ['always', 'conditional', 'never'];
          const current = gameSettings.get('destructionMode');
          const nextIndex = (modes.indexOf(current) + 1) % modes.length;
          gameSettings.set('destructionMode', modes[nextIndex]);
          this.updateUI();
        });

        // „Éï„É©„Ç∞„É°„É≥„ÉàÂãï‰ΩúÂàá„ÇäÊõø„Åà
        document.getElementById('fragment-btn').addEventListener('click', () => {
          const current = gameSettings.get('fragmentBehavior');
          gameSettings.set('fragmentBehavior', current === 'disappear' ? 'remain' : 'disappear');
          this.updateUI();
        });

        // „Ç≠„É•„Éº„ÉñÁîüÊàê
        document.getElementById('generate-btn').addEventListener('click', () => {
          this.cubeGenerator.createRandomCube();
        });

        // „Ç∞„É™„ÉÉ„ÉâÁîüÊàê
        document.getElementById('grid-btn').addEventListener('click', () => {
          this.cubeGenerator.createInitialGrid();
        });

        // ÂÖ®Á†¥Â£ä
        document.getElementById('destroy-btn').addEventListener('click', () => {
          this.destroyAllCubes();
        });

        // „É™„Çª„ÉÉ„Éà
        document.getElementById('reset-btn').addEventListener('click', () => {
          this.resetScene();
        });
      }

      updateUI() {
        // „Çπ„Éä„ÉÉ„Éó„Éú„Çø„É≥
        const snapBtn = document.getElementById('snap-btn');
        const snapStatus = gameSettings.get('snapToGrid');
        snapBtn.innerHTML = `
          <span class="status-indicator ${snapStatus ? '' : 'off'}"></span>
          Grid Snap: ${snapStatus ? 'ON' : 'OFF'}
        `;
        snapBtn.className = `control-button ${snapStatus ? 'active' : ''}`;

        // Á†¥Â£ä„É¢„Éº„Éâ„Éú„Çø„É≥
        const destructionBtn = document.getElementById('destruction-btn');
        const destructionMode = gameSettings.get('destructionMode');
        const destructionLabels = {
          always: 'Always Destroy',
          conditional: 'Smart Destroy',
          never: 'Never Destroy'
        };
        destructionBtn.innerHTML = destructionLabels[destructionMode];

        // „Éï„É©„Ç∞„É°„É≥„Éà„Éú„Çø„É≥
        const fragmentBtn = document.getElementById('fragment-btn');
        const fragmentBehavior = gameSettings.get('fragmentBehavior');
        fragmentBtn.innerHTML = `Fragments: ${fragmentBehavior === 'disappear' ? 'Fade' : 'Stay'}`;
      }

      destroyAllCubes() {
        const cubes = document.querySelectorAll('.cube');
        cubes.forEach(cube => {
          if (cube.components['destructible']) {
            cube.components['destructible'].destroy();
          }
        });
      }

      resetScene() {
        this.cubeGenerator.clearAllCubes();
        gameSettings.reset();
        this.updateUI();
        logger.info('Scene reset complete');
      }
    }

    // „Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥ÂàùÊúüÂåñ
    document.addEventListener('DOMContentLoaded', () => {
      const uiController = new UIController();
      
      // A-Frame„Ç∑„Éº„É≥„ÅÆÊ∫ñÂÇôÂÆå‰∫Ü„ÇíÂæÖ„Å§
      const scene = document.querySelector('a-scene');
      scene.addEventListener('loaded', () => {
        uiController.init();
        perfMonitor.init();
        logger.info('Application initialized successfully');
      });
    });
  </script>
</head>

<body>
  <!-- „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπË°®Á§∫ -->
  <div id="performance-panel" class="performance-panel">
    FPS: --<br>
    Objects: --
  </div>

  <!-- „Ç≥„É≥„Éà„É≠„Éº„É´„Éë„Éç„É´ -->
  <div class="control-panel">
    <div class="control-group">
      <button id="snap-btn" class="control-button">
        <span class="status-indicator"></span>
        Grid Snap: ON
      </button>
      <button id="destruction-btn" class="control-button">Smart Destroy</button>
      <button id="fragment-btn" class="control-button">Fragments: Fade</button>
    </div>

    <div class="control-group">
      <button id="generate-btn" class="control-button">üé≤ Generate Cube</button>
      <button id="grid-btn" class="control-button">üìã Create Grid</button>
      <button id="destroy-btn" class="control-button danger">üí• Destroy All</button>
      <button id="reset-btn" class="control-button warning">üîÑ Reset Scene</button>
    </div>
  </div>

  <!-- „Éò„É´„Éó„Éë„Éç„É´ -->
  <div class="help-panel">
    <div class="help-title">üéÆ Controls</div>
    <div>
      ‚Ä¢ Double-click: Grab & drag cubes<br>
      ‚Ä¢ Hold Shift: No-clip mode<br>
      ‚Ä¢ High drops: Auto-destruction<br>
      ‚Ä¢ Grid snap: Align to grid<br>
    </div>
  </div>

  <!-- A-Frame Scene -->
  <a-scene 
    physics="debug: false; gravity: -9.8; solver: hinge" 
    game-manager 
    advanced-drag
    background="color: linear-gradient(180deg, #667eea 0%, #764ba2 100%)"
    vr-mode-ui="enabled: false">
    
    <!-- Environment -->
    <a-plane 
      position="0 0 0" 
      rotation="-90 0 0" 
      width="30" 
      height="30" 
      color="#2d3748"
      material="roughness: 0.8; metalness: 0.1"
      static-body>
    </a-plane>

    <!-- Decorative slopes -->
    <a-box 
      position="8 0.25 0" 
      rotation="0 0 -15" 
      width="6" 
      height="0.5" 
      depth="4" 
      color="#4a5568"
      material="roughness: 0.6; metalness: 0.2"
      static-body>
    </a-box>

    <a-box 
      position="-8 0.25 5" 
      rotation="0 45 10" 
      width="4" 
      height="0.5" 
      depth="6" 
      color="#2d3748"
      material="roughness: 0.6; metalness: 0.2"
      static-body>
    </a-box>

    <!-- Walls for boundaries -->
    <a-box position="15 2 0" width="0.5" height="4" depth="30" color="#1a202c" static-body></a-box>
    <a-box position="-15 2 0" width="0.5" height="4" depth="30" color="#1a202c" static-body></a-box>
    <a-box position="0 2 15" width="30" height="4" depth="0.5" color="#1a202c" static-body></a-box>
    <a-box position="0 2 -15" width="30" height="4" depth="0.5" color="#1a202c" static-body></a-box>

    <!-- Enhanced Camera with smooth controls -->
    <a-entity id="camera-rig" position="0 8 12">
      <a-camera 
        look-controls="pointerLockEnabled: false; reverseMouseDrag: true"
        wasd-controls="enabled: true; acceleration: 100"
        position="0 0 0">
        
        <!-- Camera light -->
        <a-light 
          type="point" 
          intensity="0.3" 
          color="#ffffff"
          position="0 0 2">
        </a-light>
      </a-camera>
    </a-entity>

    <!-- Enhanced Lighting Setup -->
    <a-light 
      type="ambient" 
      color="#404040" 
      intensity="0.4">
    </a-light>
    
    <a-light 
      type="directional" 
      color="#ffffff" 
      intensity="0.8"
      position="5 10 2"
      shadow="cast: true; mapSize: 2048">
    </a-light>
    
    <a-light 
      type="point" 
      color="#667eea" 
      intensity="0.5"
      position="-5 5 5">
    </a-light>
    
    <a-light 
      type="point" 
      color="#764ba2" 
      intensity="0.3"
      position="5 3 -5">
    </a-light>

    <!-- Atmospheric fog -->
    <a-entity 
      geometry="primitive: sphere; radius: 50" 
      material="color: #667eea; transparent: true; opacity: 0.1; side: back"
      position="0 0 0">
    </a-entity>

    <!-- Particle system for ambient effects -->
    <a-entity
      position="0 15 0"
      particle-system="
        preset: snow;
        particleCount: 100;
        color: #ffffff, #e2e8f0;
        size: 0.02;
        opacity: 0.3;
        accelerationValue: 0 -0.1 0;
        velocityValue: 0 -0.5 0;
        velocitySpread: 2 0 2;
        positionSpread: 20 0 20;
      ">
    </a-entity>
  </a-scene>

  <!-- Loading Screen -->
  <div id="loading-screen" style="
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10000;
    color: white;
    font-size: 24px;
    font-weight: 600;
  ">
    <div style="text-align: center;">
      <div style="margin-bottom: 20px;">‚ö° Loading Physics Demo...</div>
      <div style="width: 200px; height: 4px; background: rgba(255,255,255,0.3); border-radius: 2px; overflow: hidden;">
        <div id="loading-bar" style="width: 0%; height: 100%; background: white; transition: width 0.3s ease;"></div>
      </div>
    </div>
  </div>

  <script>
    // Loading screen management
    let loadingProgress = 0;
    const loadingBar = document.getElementById('loading-bar');
    const loadingScreen = document.getElementById('loading-screen');

    function updateLoading(progress) {
      loadingProgress = Math.min(100, progress);
      loadingBar.style.width = loadingProgress + '%';
      
      if (loadingProgress >= 100) {
        setTimeout(() => {
          loadingScreen.style.opacity = '0';
          loadingScreen.style.transition = 'opacity 0.5s ease';
          setTimeout(() => {
            loadingScreen.style.display = 'none';
          }, 500);
        }, 500);
      }
    }

    // Simulate loading progress
    let progress = 0;
    const loadingInterval = setInterval(() => {
      progress += Math.random() * 15;
      updateLoading(progress);
      
      if (progress >= 100) {
        clearInterval(loadingInterval);
      }
    }, 200);

    // Complete loading when scene is ready
    document.addEventListener('DOMContentLoaded', () => {
      const scene = document.querySelector('a-scene');
      scene.addEventListener('loaded', () => {
        updateLoading(100);
      });
    });
  </script>